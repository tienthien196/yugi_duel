=== DUMP CODE T·ª™: E:\GODOT\yugi_duel\server_yugiDuel ===
Ch·ªâ dump c√°c file: .afinn, .c, .cfg, .conf, .cpp, .css, .gd, .go, .h, .hpp, .html, .ini, .java, .js, .json, .lark, .py, .rs, .toml, .ts, .yaml, .yml
================================================================================

--- FILE: autoload\agent.gd ---
# ===========================================================================
# Agent.gd - C·∫¨P NH·∫¨T: H·ªçc t·ª´ EVENTS v√† CHAIN (kh√¥ng ch·ªâ state/action)
# ===========================================================================

extends Node

# --- State ---
var current_game_state
var my_player_id
var learning_mode = true

# --- Q-Table (v·∫´n gi·ªØ ƒë·ªÉ ch·ªçn h√†nh ƒë·ªông ch√≠nh) ---
var q_table = {}
var learning_rate = 0.1
var discount_factor = 0.9
var exploration_rate = 0.3

# --- Rule-based Response Database (m·ªõi) ---
# Khi c√≥ event ‚Üí ph·∫£n ·ª©ng n√†o h·ª£p l√Ω?
var response_rules = {
	"TRIGGER_EFFECT": {
		"Mirror Force": ["ACTIVATE_EFFECT", "card_id", "Effect Veiler"],
		"Solemn Judgment": ["ACTIVATE_EFFECT", "card_id", "Infinite Emperor"]
	},
	"DAMAGE_STEP": {
		"common": ["ACTIVATE_EFFECT", "card_id", "Book of Moon"]
	}
}

# --- Feature Extraction ---
func _extract_state_key(game_state, player_id):
	var p = game_state["players"][player_id]
	var opp = game_state["players"][_get_opponent_id(game_state, player_id)]
	var my_lr = int(p.life_points / 2000)
	var opp_lr = int(opp.life_points / 2000)
	var my_mc = 0
	for m in p.monster_zones:
		if m: my_mc += 1
	var opp_mc = 0
	for m in opp.monster_zones:
		if m: opp_mc += 1
	return "%d_%d_%d_%d_%s" % [my_lr, opp_lr, my_mc, opp_mc, game_state["phase"]]

func _get_q_value(state_key, action):
	return q_table.get(state_key, {}).get(action, 0.0)

# ===========================================================================
# get_action(game_state, player_id, available_actions)
# Tr·∫£ v·ªÅ h√†nh ƒë·ªông ch√≠nh (l∆∞·ª£t c·ªßa t√¥i)
# ===========================================================================
func get_action(game_state, player_id, available_actions):
	my_player_id = player_id
	current_game_state = game_state.duplicate(true)
	
	var state_key = _extract_state_key(game_state, player_id)
	
	# Kh√°m ph√° ho·∫∑c khai th√°c
	if randf() < exploration_rate:
		return available_actions[randi() % available_actions.size()]
	
	var best_action = "END_TURN"
	var best_value = -1e9
	for action in available_actions:
		var q = _get_q_value(state_key, action)
		if q > best_value:
			best_value = q
			best_action = action
	return best_action

# ===========================================================================
# on_event(game_state, event_list)
# üÜï H√†m m·ªõi: Khi c√≥ s·ª± ki·ªán ‚Üí xem c√≥ c·∫ßn ph·∫£n ·ª©ng kh√¥ng?
# D√πng ƒë·ªÉ h·ªçc c√°ch "ƒë√°p l·∫°i hi·ªáu ·ª©ng"
# ===========================================================================
func on_event(game_state, events, player_id):
	my_player_id = player_id
	current_game_state = game_state.duplicate(true)
	
	for event in events:
		match event["type"]:
			"TRIGGER_EFFECT":
				return _handle_trigger_effect(game_state, event)
			"CHAIN_STARTED":
				return _handle_chain_started(game_state, event)
			"DAMAGE_STEP":
				return _handle_damage_step(game_state, event)
			"SUMMON":
				return _handle_summon_reaction(game_state, event)
	return null  # Kh√¥ng ph·∫£n ·ª©ng

# --- X·ª≠ l√Ω c√°c lo·∫°i event ---

func _handle_trigger_effect(game_state, event):
	var card_name = CardDatabase.get(event["card_id"]).name
	if response_rules.TRIGGER_EFFECT.has(card_name):
		var rule = response_rules.TRIGGER_EFFECT[card_name]
		if rule[0] == "ACTIVATE_EFFECT":
			var target_card = rule[2]
			if _has_card_in_hand(game_state, my_player_id, target_card):
				return {
					"type": "ACTIVATE_EFFECT",
					"payload": { "card_id": target_card }
				}
	return null

func _handle_summon_reaction(game_state, event):
	# N·∫øu ƒë·ªëi ph∆∞∆°ng tri·ªáu h·ªìi qu√°i m·∫°nh ‚Üí ch·∫∑n b·∫±ng b·∫´y
	var card_data = CardDatabase.get(event["card_id"])
	if card_data["attack"] >= 2500:
		if _has_card_in_hand(game_state, my_player_id, "MIRROR_FORCE"):
			return {
				"type": "PLAY_TRAP",
				"payload": { "card_id": "MIRROR_FORCE", "to_zone": 0 }
			}
	return null

func _handle_chain_started(game_state, event):
	# ƒêang trong chain ‚Üí c√≥ th·ªÉ ph·∫£n ·ª©ng
	return null  # T·∫°m th·ªùi kh√¥ng l√†m g√¨

func _handle_damage_step(game_state, event):
	return response_rules.get("DAMAGE_STEP", {}).get("common", null)

# --- H·ªó tr·ª£ ---

func _has_card_in_hand(game_state, player_id, card_id):
	return game_state["players"][player_id].hand.has(card_id)

func _get_opponent_id(game_state, player_id):
	for pid in game_state["players"].keys():
		if pid != player_id:
			return pid
	return null

# ===========================================================================
# learn_from_result(old_state, action, result)
# üÜï H·ªçc t·ª´ to√†n b·ªô result, kh√¥ng ch·ªâ reward
# ===========================================================================
func learn_from_result(old_state, action, result):
	if not result["success"]:
		return
	
	var new_state = result["game_state"]
	var events = result["events"]
	var state_key = _extract_state_key(old_state, action["player_id"])
	var next_key = _extract_state_key(new_state, action["player_id"])
	
	# T√≠nh reward t·ª´ events
	var reward = 0.0
	for event in events:
		match event["type"]:
			"DAMAGE":
				if event["target"] == action["player_id"]:
					reward -= event["amount"] / 100.0
				else:
					reward += event["amount"] / 100.0
			"WIN":
				if event["winner"] == action["player_id"]:
					reward += 10.0
				else:
					reward -= 10.0
			"SUMMON":
				var card = CardDatabase.get(event["card_id"])
				if card and card["attack"] > 2500:
					reward += 0.5
			"DESTROYED":
				if event["player"] == action["player_id"]:
					reward -= 1.0
				else:
					reward += 1.0
	
	# C·∫≠p nh·∫≠t Q-value
	var old_q = _get_q_value(state_key, action["type"])
	var future = 0.0
	if new_state["status"] != "finished":
		for a in ["END_TURN", "PLAY_MONSTER", "ACTIVATE_EFFECT"]:
			future = max(future, _get_q_value(next_key, a))
	var new_q = (1 - learning_rate) * old_q + learning_rate * (reward + discount_factor * future)
	
	if not q_table.has(state_key):
		q_table[state_key] = {}
	q_table[state_key][action["type"]] = new_q
	
	# üÜï H·ªçc t·ª´ events ƒë·ªÉ c·∫≠p nh·∫≠t response_rules
	_learn_from_events(events, action["player_id"])

func _learn_from_events(events, player_id):
	for event in events:
		if event["type"] == "TRIGGER_EFFECT" and event["card_id"] == "MIRROR_FORCE":
			# N·∫øu t√¥i kh√¥ng ph·∫£n ·ª©ng ‚Üí b·ªã thi·ªát ‚Üí n√™n h·ªçc d√πng Effect Veiler
			if _recently_lost_battle_due_to(event["card_id"]):
				_add_response_rule("TRIGGER_EFFECT", "Mirror Force", [
					"ACTIVATE_EFFECT", "card_id", "EFFECT_VEILER"
				])

func _add_response_rule(category, trigger, action):
	if not response_rules.has(category):
		response_rules[category] = {}
	response_rules[category][trigger] = action

func _recently_lost_battle_due_to(card_id):
	# C√≥ th·ªÉ l∆∞u log tr·∫≠n thua
	return false  # T·∫°m th·ªùi




================================================================================

--- FILE: autoload\AuthManager.gd ---
# ===========================================================================
# AuthManager.gd - Simple token auth (Godot 3.6) + Console Debug
# ===========================================================================
extends Node

const TOKEN_EXPIRE_TIME = 3600

var sessions = {}    # token -> { player_id, peer_id, created_time }
signal player_authenticated(player_id, session_token, peer_id)
signal player_logged_out(player_id)
signal auth_failed(peer_id, error_code)

onready var network_manager = NetworkManager

func _ready():
	print("[S-AUTH] Ready")
	network_manager.connect("client_connected", self, "_on_client_connected")
	network_manager.connect("message_received", self, "_on_message_received")

func _on_client_connected(player_id, peer_id):
	print("[S-AUTH] Client connected player_id=%s peer_id=%s" % [str(player_id), str(peer_id)])
	# No-op; NetworkManager already sent AUTH_REQUEST
	pass

func _on_message_received(player_id, message):
	var t = str(message.get("type",""))
	match t:
		"AUTH_LOGIN":
			_handle_login(player_id, message)
		"LOGOUT":
			_handle_logout(player_id, message)
		_:
			pass

func _handle_login(temp_player_id, message):
	var username = str(message.get("username","")).strip_edges()
	print("[S-AUTH] ‚ñ∂Ô∏è AUTH_LOGIN from temp_pid=%s username='%s'" % [str(temp_player_id), username])
	# Accept all usernames (guest or real); generate token and bind to current peer
	var token = _generate_token()
	var peer_id = network_manager._get_peer_from_player(temp_player_id)
	sessions[token] = {
		"player_id": username,
		"peer_id": peer_id,
		"created_time": OS.get_unix_time()
	}
	# Update mapping in NetworkManager
	for pid in network_manager.peer_to_player.keys():
		if pid == peer_id:
			network_manager.peer_to_player[pid] = username
	# Notify server-side managers
	emit_signal("player_authenticated", username, token, peer_id)
	# SEND AUTH_SUCCESS so client can store token
	network_manager.send_message_to_player(username, {
		"type": "AUTH_SUCCESS",
		"player_id": username,
		"token": token
	})
	print("[S-AUTH] ‚úÖ Authenticated '%s' token_len=%d (peer=%s)" % [username, token.length(), str(peer_id)])

func _handle_logout(player_id, message):
	var token = str(message.get("token",""))
	print("[S-AUTH] ‚ñ∂Ô∏è LOGOUT player_id=%s token_len=%d" % [player_id, token.length()])
	if token == "" or not sessions.has(token):
		var peer = network_manager._get_peer_from_player(player_id)
		if peer != 0:
			print("[S-AUTH] ‚ùå Invalid token on logout")
			network_manager.rpc_id(peer, "receive_message", { "type": "AUTH_ERROR", "code": "INVALID_TOKEN" })
		return
	sessions.erase(token)
	print("[S-AUTH] üö™ Player logged out: %s" % player_id)
	emit_signal("player_logged_out", player_id)

func verify(player_id: String, token: String) -> bool:
	if token == "" or not sessions.has(token):
		return false
	var s = sessions[token]
	return s.player_id == player_id and (OS.get_unix_time() - int(s.created_time)) <= TOKEN_EXPIRE_TIME

func _generate_token() -> String:
	var chars = "abcdefghijklmnopqrstuvwxyz0123456789"
	var s = ""
	for i in range(32):
		s += chars[randi() % chars.length()]
	return s

================================================================================

--- FILE: autoload\BattleCore.gd ---
# ===========================================================================
# BattleCore.gd - Core x·ª≠ l√Ω tr·∫≠n ƒë·∫•u Yu-Gi-Oh! (Godot 3.6)
# Autoload Singleton - D√πng ƒë·ªÉ qu·∫£n l√Ω to√†n b·ªô logic tr·∫≠n ƒë·∫•u
# Kh√¥ng c·∫ßn UI, kh√¥ng c·∫ßn m·∫°ng - ch·ªâ c·∫ßn ch·∫°y trong Godot
# ===========================================================================

extends Node

# Danh s√°ch c√°c tr·∫≠n ƒëang di·ªÖn ra: room_id ‚Üí game_state
var active_duels = {}

# Th·ª© t·ª± c√°c phase trong m·ªôt l∆∞·ª£t
const TURN_PHASES = ["draw", "standby", "main1", "battle", "main2", "end"]

# C√°c l√Ω do chi·∫øn th·∫Øng
const WIN_REASON_LP_ZERO = "lp_zero"
const WIN_REASON_DECK_OUT = "deck_out"
const WIN_REASON_SURRENDER = "surrender"
const WIN_REASON_EXODIA = "exodia"
const WIN_REASON_FORFEIT = "forfeit"

# Error codes
const ERR_ROOM_NOT_FOUND = "ROOM_NOT_FOUND"
const ERR_DUEL_NOT_ACTIVE = "DUEL_NOT_ACTIVE"
const ERR_INVALID_PLAYER = "INVALID_PLAYER"
const ERR_NOT_YOUR_TURN = "NOT_YOUR_TURN"
const ERR_NOT_IN_DRAW_PHASE = "NOT_IN_DRAW_PHASE"
const ERR_NO_DRAW_FIRST_TURN = "NO_DRAW_FIRST_TURN"
const ERR_DECK_EMPTY = "DECK_EMPTY"
const ERR_CARD_NOT_IN_HAND = "CARD_NOT_IN_HAND"
const ERR_ZONE_OCCUPIED = "ZONE_OCCUPIED"
const ERR_NOT_IN_MAIN_PHASE = "NOT_IN_MAIN_PHASE"
const ERR_NOT_MONSTER_CARD = "NOT_MONSTER_CARD"
const ERR_NOT_SPELL_CARD = "NOT_SPELL_CARD"
const ERR_NOT_TRAP_CARD = "NOT_TRAP_CARD"
const ERR_SPELL_ZONE_OCCUPIED = "SPELL_ZONE_OCCUPIED"
const ERR_TRAP_ZONE_OCCUPIED = "TRAP_ZONE_OCCUPIED"
const ERR_INVALID_ZONE = "INVALID_ZONE"
const ERR_CANNOT_CHANGE_POS_THIS_TURN = "CANNOT_CHANGE_POS_THIS_TURN"
const ERR_SAME_POSITION = "SAME_POSITION"
const ERR_CARD_NOT_ON_FIELD = "CARD_NOT_ON_FIELD"
const ERR_NO_EFFECT = "NO_EFFECT"
const ERR_NOT_IN_BATTLE_PHASE = "NOT_IN_BATTLE_PHASE"
const ERR_INVALID_ATTACKER = "INVALID_ATTACKER"
const ERR_NOT_IN_ATTACK_POSITION = "NOT_IN_ATTACK_POSITION"
const ERR_ALREADY_ATTACKED = "ALREADY_ATTACKED"
const ERR_CANNOT_ATTACK_SUMMON_TURN = "CANNOT_ATTACK_SUMMON_TURN"
const ERR_CANNOT_DIRECT_ATTACK = "CANNOT_DIRECT_ATTACK"
const ERR_INVALID_TARGET = "INVALID_TARGET"
const ERR_INVALID_PHASE = "INVALID_PHASE"
const ERR_INVALID_CARD = "INVALID_CARD"

# ===========================================================================
# start_duel(player_a_id, player_b_id, deck_a, deck_b, rules)
# T·∫°o m·ªôt tr·∫≠n ƒë·∫•u m·ªõi
# ===========================================================================
func start_duel(player_a_id, player_b_id, deck_a, deck_b, rules = {}):
	var room_id: String = "duel_%d_%d" % [OS.get_unix_time(), randi() % 10000]



	
	# Validate deck
	for card_id in deck_a + deck_b:
		if not CardDatabase.exists(card_id):
			return _error(ERR_INVALID_CARD)
		if card_id in rules.get("forbidden_cards", []):
			return _error("FORBIDDEN_CARD_IN_DECK")
	
	# Sao ch√©p v√† x√°o b√†i
	var deck_a_copy = deck_a.duplicate(true)
	var deck_b_copy = deck_b.duplicate(true)
	_shuffle(deck_a_copy)
	_shuffle(deck_b_copy)
	
	# B·ªëc 5 b√†i ƒë·∫ßu
	var hand_a = _draw_cards(deck_a_copy, 5)
	var hand_b = _draw_cards(deck_b_copy, 5)
	
	# Ch·ªçn ai ƒëi tr∆∞·ªõc
	var first_player = [player_a_id, player_b_id][randi() % 2]
	
	# T·∫°o tr·∫°ng th√°i tr·∫≠n ƒë·∫•u
	var start_lp = rules.get("start_lp", 8000)
	var game_state = {
		"room_id": room_id,
		"turn": first_player,
		"phase": "draw",
		"current_turn_count": 1,
		"is_first_turn": true,
		"first_player": first_player,
		"players": {
			player_a_id: _create_player_state(player_a_id, deck_a_copy, hand_a, start_lp),
			player_b_id: _create_player_state(player_b_id, deck_b_copy, hand_b, start_lp)
		},
		"status": "active",
		"winner": null,
		"win_reason": null,
		"chain": [],
		"chain_trigger": null,  # L∆∞u h√†nh ƒë·ªông trigger chain
		"rules": {
			"start_lp": start_lp,
			"max_hand_size": rules.get("max_hand_size", 6),
			"forbidden_cards": rules.get("forbidden_cards", [])
		}
	}
	
	# L∆∞u v√†o h·ªá th·ªëng
	active_duels[room_id] = game_state
	print("‚úÖ BattleCore: Tr·∫≠n '%s' ƒë√£ kh·ªüi t·∫°o. Ng∆∞·ªùi ƒëi tr∆∞·ªõc: %s" % [room_id, first_player])
	var temp: String = room_id
	
	
	return temp


# ===========================================================================
# submit_action(room_id, action)
# X·ª≠ l√Ω h√†nh ƒë·ªông t·ª´ ng∆∞·ªùi ch∆°i ho·∫∑c bot
# Tr·∫£ v·ªÅ: { success, events, available_actions, errors }
# ===========================================================================
func submit_action(room_id, action):
	if not active_duels.has(room_id):
		return _error(ERR_ROOM_NOT_FOUND)
	
	var game_state = active_duels[room_id]
	if game_state["status"] != "active":
		return _error(ERR_DUEL_NOT_ACTIVE)
	
	var player_id = action.get("player_id", "")
	if not game_state["players"].has(player_id):
		return _error(ERR_INVALID_PLAYER)
	
	# Ki·ªÉm tra l∆∞·ª£t ƒëi (tr·ª´ khi chain ho·∫∑c quick effect)
	if game_state["turn"] != player_id and action["type"] != "ACTIVATE_EFFECT":
		if not _can_activate_effect_out_of_turn(game_state, action):
			return _error(ERR_NOT_YOUR_TURN)
	
	# X·ª≠ l√Ω h√†nh ƒë·ªông
	var result = _process_action(game_state, action)
	
	# C·∫≠p nh·∫≠t tr·∫°ng th√°i
	if result["success"] and action["type"] == "ACTIVATE_EFFECT":
		_resolve_chain(game_state, action)
	
	# C·∫≠p nh·∫≠t l·∫°i tr·∫°ng th√°i
	active_duels[room_id] = game_state
	
	# Ki·ªÉm tra ƒëi·ªÅu ki·ªán chi·∫øn th·∫Øng
	var win_check = _check_win_condition(game_state)
	if win_check.winner:
		game_state["winner"] = win_check.winner
		game_state["win_reason"] = win_check.reason
		game_state["status"] = "finished"
		result["events"].append({
			"type": "WIN",
			"winner": win_check.winner,
			"reason": win_check.reason
		})
	elif result["success"] and game_state["chain"].empty():
		_update_phase_if_needed(game_state)
	
	# G√°n danh s√°ch h√†nh ƒë·ªông kh·∫£ d·ª•ng
	result["available_actions"] = _get_available_actions(game_state, player_id)
	result["game_state"] = game_state.duplicate(true)
	
	return result


# ===========================================================================
# get_game_state(room_id, player_id)
# Tr·∫£ v·ªÅ tr·∫°ng th√°i tr·∫≠n, ·∫©n b√†i tr√™n tay ƒë·ªëi th·ªß
# ===========================================================================
func get_game_state(room_id, player_id):
	if not active_duels.has(room_id):
		return {}
	
	var game_state = active_duels[room_id].duplicate(true)
	var opponent_id = _get_opponent_id(game_state, player_id)
	
	if game_state["players"].has(opponent_id):
		var opponent = game_state["players"][opponent_id]
		opponent["hand"] = []  # ·∫®n b√†i
		opponent["hand_count"] = len(opponent["hand"])  # Gi·ªØ s·ªë l∆∞·ª£ng
	
	return game_state


# ===========================================================================
# get_available_actions(room_id, player_id)
# Tr·∫£ v·ªÅ danh s√°ch h√†nh ƒë·ªông h·ª£p l·ªá (d√πng cho bot)
# ===========================================================================
func get_available_actions(room_id, player_id):
	if not active_duels.has(room_id):
		return []
	var game_state = active_duels[room_id]
	return _get_available_actions(game_state, player_id)


# ===========================================================================
# end_duel(room_id, winner, reason)
# K·∫øt th√∫c tr·∫≠n ƒë·∫•u (d√πng cho test, l·ªói, v.v.)
# ===========================================================================
func end_duel(room_id, winner, reason = WIN_REASON_FORFEIT):
	if not active_duels.has(room_id):
		return
	var game_state = active_duels[room_id]
	game_state["winner"] = winner
	game_state["win_reason"] = reason
	game_state["status"] = "finished"
	print("üèÅ Tr·∫≠n '%s' k·∫øt th√∫c. Ng∆∞·ªùi th·∫Øng: %s | L√Ω do: %s" % [room_id, winner, reason])


# ===========================================================================
# H√ÄM X·ª¨ L√ù H√ÄNH ƒê·ªòNG
# ===========================================================================
func _process_action(game_state, action):
	var player_id = action["player_id"]
	var result = {
		"success": false,
		"events": [],
		"errors": []
	}
	
	match action["type"]:
		"DRAW_CARD":
			result = _action_draw_card(game_state, player_id)
		"PLAY_MONSTER":
			result = _action_play_monster(game_state, player_id, action["payload"])
		"SET_MONSTER":
			result = _action_set_monster(game_state, player_id, action["payload"])
		"PLAY_SPELL", "SET_SPELL":
			result = _action_play_spell(game_state, player_id, action["payload"], action["type"] == "SET_SPELL")
		"PLAY_TRAP", "SET_TRAP":
			result = _action_play_trap(game_state, player_id, action["payload"], action["type"] == "SET_TRAP")
		"END_TURN":
			result = _action_end_turn(game_state, player_id)
		"SURRENDER":
			result = _action_surrender(game_state, player_id)
		"CHANGE_POSITION":
			result = _action_change_position(game_state, player_id, action["payload"])
		"ACTIVATE_EFFECT":
			result = _action_activate_effect(game_state, player_id, action["payload"])
		"DECLARE_ATTACK":
			result = _action_declare_attack(game_state, player_id, action["payload"])
		"END_PHASE":
			result = _action_end_phase(game_state, player_id)
		_:
			result["errors"].append("UNKNOWN_ACTION")
	
	if result["success"]:
		print("‚úÖ Action: %s | Player: %s" % [action["type"], player_id])
	else:
		var error_msg = result["errors"][0] if len(result["errors"]) > 0 else "Unknown"
		print("‚ùå Action failed: %s | Error: %s" % [action["type"], error_msg])
	
	return result


# ===========================================================================
# C√ÅC H√ÄM H√ÄNH ƒê·ªòNG CHI TI·∫æT
# ===========================================================================
func _action_draw_card(game_state, player_id):
	var player = game_state["players"][player_id]
	if game_state["phase"] != "draw":
		return _error(ERR_NOT_IN_DRAW_PHASE)
	if game_state["is_first_turn"] and player_id == game_state["first_player"]:
		return _error(ERR_NO_DRAW_FIRST_TURN)
	if player["deck"].empty():
		return _error(ERR_DECK_EMPTY)
	
	var card = player["deck"].pop_front()
	player["hand"].append(card)
	
	return {
		"success": true,
		"events": [
			{ "type": "DRAW_CARD", "card_id": card, "player": player_id }
		]
	}

func _action_play_monster(game_state, player_id, payload):
	var player = game_state["players"][player_id]
	var card_id = payload["card_id"]
	var to_zone = payload["to_zone"]
	var position = payload.get("position", "face_up_attack")

	if not player["hand"].has(card_id):
		return _error(ERR_CARD_NOT_IN_HAND)
	if to_zone < 0 or to_zone >= 5 or player["monster_zones"][to_zone] != null:
		return _error(ERR_ZONE_OCCUPIED)
	if not game_state["phase"] in ["main1", "main2"]:
		return _error(ERR_NOT_IN_MAIN_PHASE)
	if CardDatabase.get(card_id).get("type") != "monster":
		return _error(ERR_NOT_MONSTER_CARD)

	player["hand"].erase(card_id)
	player["monster_zones"][to_zone] = {
		"card_id": card_id,
		"position": position,
		"status": "summoned_this_turn",
		"attacked_this_turn": false
	}

	return {
		"success": true,
		"events": [
			{ "type": "SUMMON", "card_id": card_id, "player": player_id, "zone": to_zone }
		]
	}

func _action_set_monster(game_state, player_id, payload):
	var player = game_state["players"][player_id]
	var card_id = payload["card_id"]
	var to_zone = payload["to_zone"]

	if not player["hand"].has(card_id):
		return _error(ERR_CARD_NOT_IN_HAND)
	if to_zone < 0 or to_zone >= 5 or player["monster_zones"][to_zone] != null:
		return _error(ERR_ZONE_OCCUPIED)
	if not game_state["phase"] in ["main1", "main2"]:
		return _error(ERR_NOT_IN_MAIN_PHASE)
	if CardDatabase.get(card_id).get("type") != "monster":
		return _error(ERR_NOT_MONSTER_CARD)

	player["hand"].erase(card_id)
	player["monster_zones"][to_zone] = {
		"card_id": card_id,
		"position": "face_down_defense",
		"status": "set_this_turn",
		"attacked_this_turn": false
	}

	return {
		"success": true,
		"events": [
			{ "type": "SET_MONSTER", "card_id": card_id, "player": player_id, "zone": to_zone }
		]
	}

func _action_play_spell(game_state, player_id, payload, is_set):
	var player = game_state["players"][player_id]
	var card_id = payload["card_id"]
	var to_zone = payload["to_zone"]

	if not player["hand"].has(card_id):
		return _error(ERR_CARD_NOT_IN_HAND)
	if to_zone < 0 or to_zone >= 5 or player["spell_trap_zones"][to_zone] != null:
		return _error(ERR_SPELL_ZONE_OCCUPIED)
	if not game_state["phase"] in ["main1", "main2"]:
		return _error(ERR_NOT_IN_MAIN_PHASE)
	if CardDatabase.get(card_id).get("type") != "spell":
		return _error(ERR_NOT_SPELL_CARD)

	player["hand"].erase(card_id)
	var status = "face_down" if is_set else "face_up"
	player["spell_trap_zones"][to_zone] = {
		"card_id": card_id,
		"status": status
	}

	var event_type = "SET_SPELL" if is_set else "PLAY_SPELL"

	return {
		"success": true,
		"events": [
			{ "type": event_type, "card_id": card_id, "player": player_id, "zone": to_zone }
		]
	}

func _action_play_trap(game_state, player_id, payload, is_set):
	var player = game_state["players"][player_id]
	var card_id = payload["card_id"]
	var to_zone = payload["to_zone"]

	if not player["hand"].has(card_id):
		return _error(ERR_CARD_NOT_IN_HAND)
	if to_zone < 0 or to_zone >= 5 or player["spell_trap_zones"][to_zone] != null:
		return _error(ERR_TRAP_ZONE_OCCUPIED)
	if CardDatabase.get(card_id).get("type") != "trap":
		return _error(ERR_NOT_TRAP_CARD)

	player["hand"].erase(card_id)
	var status = "face_down" if is_set else "face_up"
	player["spell_trap_zones"][to_zone] = {
		"card_id": card_id,
		"status": status
	}

	var event_type = "SET_TRAP" if is_set else "ACTIVATE_TRAP"

	return {
		"success": true,
		"events": [
			{ "type": event_type, "card_id": card_id, "player": player_id, "zone": to_zone }
		]
	}

func _action_end_turn(game_state, player_id):
	if game_state["turn"] != player_id:
		return _error(ERR_NOT_YOUR_TURN)
	
	_reset_turn_flags(game_state["players"][player_id])
	game_state["turn"] = _get_opponent_id(game_state, player_id)
	game_state["phase"] = "draw"
	game_state["current_turn_count"] += 1
	game_state["is_first_turn"] = false
	game_state["chain"] = []
	game_state["chain_trigger"] = null

	return {
		"success": true,
		"events": [
			{ "type": "TURN_CHANGED", "next_player": game_state["turn"] }
		]
	}

func _action_surrender(game_state, player_id):
	var opponent_id = _get_opponent_id(game_state, player_id)
	game_state["winner"] = opponent_id
	game_state["win_reason"] = WIN_REASON_SURRENDER
	game_state["status"] = "finished"

	return {
		"success": true,
		"events": [
			{ "type": "WIN", "winner": opponent_id, "reason": WIN_REASON_SURRENDER }
		]
	}

func _action_change_position(game_state, player_id, payload):
	var player = game_state["players"][player_id]
	var zone_idx = payload["zone"]
	var to_position = payload["to_position"]  # e.g., "face_up_attack", "face_up_defense", "face_down_defense"

	if zone_idx < 0 or zone_idx >= 5 or player["monster_zones"][zone_idx] == null:
		return _error(ERR_INVALID_ZONE)
	var card_obj = player["monster_zones"][zone_idx]
	if card_obj.get("status") in ["summoned_this_turn", "set_this_turn"]:
		return _error(ERR_CANNOT_CHANGE_POS_THIS_TURN)
	if card_obj["position"] == to_position:
		return _error(ERR_SAME_POSITION)

	# Validate position
	if not to_position in ["face_up_attack", "face_up_defense", "face_down_defense"]:
		return _error("INVALID_POSITION")
	
	card_obj["position"] = to_position
	if to_position == "face_up_defense" and card_obj["position"] == "face_down_defense":
		# Flip summon
		return {
			"success": true,
			"events": [
				{ "type": "FLIP_SUMMON", "card_id": card_obj["card_id"], "zone": zone_idx, "player": player_id }
			]
		}

	return {
		"success": true,
		"events": [
			{ "type": "CHANGE_POSITION", "zone": zone_idx, "to_position": to_position, "player": player_id }
		]
	}

# ===========================================================================
# _action_activate_effect(game_state, player_id, payload)
# K√≠ch ho·∫°t hi·ªáu ·ª©ng c·ªßa qu√°i, spell, trap ‚Üí th√™m v√†o chain
# ===========================================================================
func _action_activate_effect(game_state, player_id, payload):
	var card_id = payload["card_id"]
	var zone_type = payload.get("zone_type", "spell_trap")
	var player = game_state["players"][player_id]
	
	# T√¨m v·ªã tr√≠
	var zone_idx = -1
	var zones = player["spell_trap_zones"] if zone_type == "spell_trap" else player["monster_zones"]
	for i in range(5):
		if zones[i] and zones[i].card_id == card_id:
			zone_idx = i
			break
	if zone_idx == -1:
		return _error(ERR_CARD_NOT_ON_FIELD)

	# Ki·ªÉm tra ƒëi·ªÅu ki·ªán
	if zone_type == "spell_trap" and zones[zone_idx].status != "face_up":
		return _error("CARD_NOT_ACTIVATABLE")
	if zone_type == "monster":
		var card_data = CardDatabase.get(card_id)
		if not card_data.has("effect") or card_data["effect"] == "":
			return _error(ERR_NO_EFFECT)
		# ‚úÖ Ki·ªÉm tra: SUIJIN ch·ªâ k√≠ch ho·∫°t khi c√≥ t·∫•n c√¥ng
		if card_id == "SUIJIN" and (not game_state["chain_trigger"] or game_state["chain_trigger"].get("type") != "ATTACK_DECLARED"):
			return _error("EFFECT_CANNOT_ACTIVATE_NOW")

	# Th√™m v√†o chain
	game_state["chain"].append({
		"card_id": card_id,
		"player_id": player_id,
		"zone_type": zone_type,
		"zone_idx": zone_idx
	})

	return {
		"success": true,
		"events": [
			{"type": "ACTIVATE_EFFECT", "card_id": card_id, "player": player_id}
		]
	}


func _action_declare_attack(game_state, player_id, payload):
	var player = game_state["players"][player_id]
	var opponent_id = _get_opponent_id(game_state, player_id)
	var opponent = game_state["players"][opponent_id]
	var atk_zone = payload["atk_zone"]
	var target_zone = payload.get("target_zone", -1)

	if game_state["phase"] != "battle":
		return _error(ERR_NOT_IN_BATTLE_PHASE)
	if atk_zone < 0 or atk_zone >= 5 or player["monster_zones"][atk_zone] == null:
		return _error(ERR_INVALID_ATTACKER)
	var attacker = player["monster_zones"][atk_zone]
	if attacker.position != "face_up_attack":
		return _error(ERR_NOT_IN_ATTACK_POSITION)
	if attacker.get("attacked_this_turn", false):
		return _error(ERR_ALREADY_ATTACKED)
	if attacker.get("status") == "summoned_this_turn":
		return _error(ERR_CANNOT_ATTACK_SUMMON_TURN)

	var events = []
	var atk = CardDatabase.get(attacker.card_id).get("atk", 0)

	# K√≠ch ho·∫°t chain cho attack
	game_state["chain_trigger"] = {"type": "ATTACK_DECLARED", "attacker_zone": atk_zone, "player_id": player_id}
	events.append({"type": "ATTACK_DECLARED", "attacker": attacker.card_id, "zone": atk_zone})

	if target_zone == -1:
		# Direct attack
		var has_monster = false
		for zone in opponent["monster_zones"]:
			if zone != null:
				has_monster = true
				break
		if has_monster:
			return _error(ERR_CANNOT_DIRECT_ATTACK)
		opponent["life_points"] = max(0, opponent["life_points"] - atk)
		events.append({"type": "DIRECT_ATTACK", "attacker": attacker.card_id, "damage": atk})
	else:
		if target_zone < 0 or target_zone >= 5 or opponent["monster_zones"][target_zone] == null:
			return _error(ERR_INVALID_TARGET)
		var target = opponent["monster_zones"][target_zone]
		var target_pos = target.position
		# ‚úÖ S·ª¨A: D√πng find() thay v√¨ contains()
		var is_defense = target_pos.find("defense") != -1
		var target_val = CardDatabase.get(target.card_id).get("def", 0) if is_defense else CardDatabase.get(target.card_id).get("atk", 0)

		# Flip if face down
		if target_pos == "face_down_defense":
			target.position = "face_up_defense"
			events.append({"type": "FLIP", "card_id": target.card_id})

		if atk > target_val:
			var damage = atk - target_val
			if is_defense:
				damage = 0
			else:
				opponent["life_points"] = max(0, opponent["life_points"] - damage)
			opponent["monster_zones"][target_zone] = null
			opponent["graveyard"].append(target.card_id)
			events.append({"type": "DESTROY_TARGET", "damage": damage})
		elif atk == target_val:
			if not is_defense:
				player["monster_zones"][atk_zone] = null
				player["graveyard"].append(attacker.card_id)
			opponent["monster_zones"][target_zone] = null
			opponent["graveyard"].append(target.card_id)
			events.append({"type": "DESTROY_BOTH"})
		else:
			var damage = target_val - atk
			player["life_points"] = max(0, player["life_points"] - damage)
			if not is_defense:
				player["monster_zones"][atk_zone] = null
				player["graveyard"].append(attacker.card_id)
			events.append({"type": "REBOUND", "damage": damage})

	attacker.attacked_this_turn = true
	return {"success": true, "events": events}

func _action_end_phase(game_state, player_id):
	if game_state["turn"] != player_id:
		return _error(ERR_NOT_YOUR_TURN)
	var idx = TURN_PHASES.find(game_state["phase"])
	if idx == -1 or idx >= len(TURN_PHASES) - 1:
		return _error(ERR_INVALID_PHASE)
	game_state["phase"] = TURN_PHASES[idx + 1]
	var events = [{"type": "PHASE_CHANGED", "new_phase": game_state["phase"]}]
	
	if game_state["phase"] == "end":
		var player = game_state["players"][player_id]
		if len(player["hand"]) > game_state["rules"].max_hand_size:
			var discard_count = len(player["hand"]) - game_state["rules"].max_hand_size
			for i in range(discard_count):
				var card = player["hand"].pop_back()
				player["graveyard"].append(card)
			events.append({"type": "DISCARD_HAND", "count": discard_count})
	
	return {"success": true, "events": events}


# ===========================================================================
# H√ÄM H·ªñ TR·ª¢
# ===========================================================================
func _create_player_state(player_id, deck, hand, lp):
	return {
		"player_id": player_id,
		"life_points": lp,
		"deck": deck,
		"hand": hand,
		"graveyard": [],
		"banished": [],
		"extra_deck": [],
		"monster_zones": [null, null, null, null, null],
		"spell_trap_zones": [null, null, null, null, null],
		"field_zone": null,
		"pendulum_zones": [null, null]
	}

func _shuffle(array):
	var n = len(array)
	for i in range(n - 1, 0, -1):
		var j = randi() % (i + 1)
		var temp = array[i]
		array[i] = array[j]
		array[j] = temp
	return array

func _draw_cards(deck, count):
	var cards = []
	for i in range(min(count, len(deck))):
		cards.append(deck.pop_front())
	return cards

func _can_activate_effect_out_of_turn(game_state, action):
	if action["type"] != "ACTIVATE_EFFECT":
		return false
	var card_id = action["payload"]["card_id"]
	var card_data = CardDatabase.get(card_id)
	return card_data.get("type") == "trap" or card_data.get("effect") in ["quick_effect"]  # M·ªü r·ªông sau

func _get_opponent_id(game_state, player_id):
	for pid in game_state["players"]:
		if pid != player_id:
			return pid
	return null

func _update_phase_if_needed(game_state):
	if game_state["phase"] == "draw" and game_state["chain"].empty():
		if not (game_state["is_first_turn"] and game_state["turn"] == game_state["first_player"]):
			var player = game_state["players"][game_state["turn"]]
			if not player["deck"].empty():
				var card = player["deck"].pop_front()
				player["hand"].append(card)
				print("Auto draw: %s" % card)
		game_state["phase"] = "standby"

func _get_available_actions(game_state, player_id):
	var actions = []
	var phase = game_state["phase"]
	var player = game_state["players"][player_id]
	var opponent_id = _get_opponent_id(game_state, player_id)
	
	var action_details = []
	if game_state["turn"] == player_id:
		action_details += [
			{"type": "END_PHASE"},
			{"type": "END_TURN"},
			{"type": "SURRENDER"}
		]
	
	if phase == "draw" and game_state["turn"] == player_id:
		if not (game_state["is_first_turn"] and player_id == game_state["first_player"]):
			action_details.append({"type": "DRAW_CARD"})
	
	if phase in ["main1", "main2"] and game_state["turn"] == player_id:
		for card_id in player["hand"]:
			var card_data = CardDatabase.get(card_id)
			var card_type = card_data.get("type", "")
			for i in range(5):
				if card_type == "monster" and player["monster_zones"][i] == null:
					action_details.append({
						"type": "PLAY_MONSTER",
						"payload": {"card_id": card_id, "to_zone": i, "position": "face_up_attack"}
					})
					action_details.append({
						"type": "SET_MONSTER",
						"payload": {"card_id": card_id, "to_zone": i}
					})
				elif card_type == "spell" and player["spell_trap_zones"][i] == null:
					action_details.append({
						"type": "PLAY_SPELL",
						"payload": {"card_id": card_id, "to_zone": i}
					})
					action_details.append({
						"type": "SET_SPELL",
						"payload": {"card_id": card_id, "to_zone": i}
					})
				elif card_type == "trap" and player["spell_trap_zones"][i] == null:
					action_details.append({
						"type": "PLAY_TRAP",
						"payload": {"card_id": card_id, "to_zone": i}
					})
					action_details.append({
						"type": "SET_TRAP",
						"payload": {"card_id": card_id, "to_zone": i}
					})
		for i in range(5):
			if player["monster_zones"][i] and not player["monster_zones"][i].get("status") in ["summoned_this_turn", "set_this_turn"]:
				for pos in ["face_up_attack", "face_up_defense", "face_down_defense"]:
					if pos != player["monster_zones"][i].position:
						action_details.append({
							"type": "CHANGE_POSITION",
							"payload": {"zone": i, "to_position": pos}
						})
			if player["monster_zones"][i] and CardDatabase.get(player["monster_zones"][i].card_id).get("effect") != "":
				action_details.append({
					"type": "ACTIVATE_EFFECT",
					"payload": {"card_id": player["monster_zones"][i].card_id, "zone_type": "monster"}
				})
			if player["spell_trap_zones"][i] and player["spell_trap_zones"][i].status == "face_up" and CardDatabase.get(player["spell_trap_zones"][i].card_id).get("effect") != "":
				action_details.append({
					"type": "ACTIVATE_EFFECT",
					"payload": {"card_id": player["spell_trap_zones"][i].card_id, "zone_type": "spell_trap"}
				})
	
	if phase == "battle" and game_state["turn"] == player_id:
		for i in range(5):
			if player["monster_zones"][i] and player["monster_zones"][i].position == "face_up_attack" and not player["monster_zones"][i].get("attacked_this_turn", false) and not player["monster_zones"][i].get("status") == "summoned_this_turn":
				var has_monster = false
				for j in range(5):
					if game_state["players"][opponent_id].monster_zones[j]:
						has_monster = true
						action_details.append({
							"type": "DECLARE_ATTACK",
							"payload": {"atk_zone": i, "target_zone": j}
						})
				if not has_monster:
					action_details.append({
						"type": "DECLARE_ATTACK",
						"payload": {"atk_zone": i}
					})
	
	# Th√™m h√†nh ƒë·ªông cho chain
	if not game_state["chain"].empty() and game_state["turn"] != player_id:
		for i in range(5):
			var card = player["spell_trap_zones"][i]
			if card and card["status"] == "face_down" and CardDatabase.get(card["card_id"]).get("type") == "trap":
				action_details.append({
					"type": "ACTIVATE_EFFECT",
					"payload": {"card_id": card["card_id"], "zone_type": "spell_trap"}
				})
	
	# Ch·ªâ l·∫•y type ƒë·ªÉ tr√°nh payload ascendedpayload d√†i
	for action in action_details:
		if not action["type"] in actions:
			actions.append(action["type"])
	
	return {"types": actions, "details": action_details}

func _resolve_chain(game_state, action):
	if game_state["chain"].empty():
		return
	
	# Resolve chain theo th·ª© t·ª± ng∆∞·ª£c
	var events = []
	for chain_link in game_state["chain"]:
		var card_id = chain_link["card_id"]
		var player_id = chain_link["player_id"]
		var zone_type = chain_link["zone_type"]
		var zone_idx = chain_link["zone_idx"]
		var player = game_state["players"][player_id]
		var opponent_id = _get_opponent_id(game_state, player_id)
		var opponent = game_state["players"][opponent_id]
		
		var resolve_result = _resolve_effect(game_state, card_id, player, opponent, zone_type, zone_idx)
		events += resolve_result.events
		if not resolve_result.success:
			return resolve_result
	
	game_state["chain"] = []
	game_state["chain_trigger"] = null
	return {"success": true, "events": events}

func _resolve_effect(game_state, card_id, player, opponent, zone_type, zone_idx):
	var effect = CardDatabase.get(card_id).get("effect", "")
	var events = []
	
	match effect:
		"draw_2":
			var drawn = _draw_cards(player["deck"], 2)
			player["hand"] += drawn
			events.append({"type": "DRAW_EFFECT", "cards": drawn, "player": player["player_id"]})
		"special_summon_graveyard":
			if player["graveyard"].empty():
				return _error("NO_CARDS_IN_GRAVEYARD")
			var summon_card = player["graveyard"].pop_back()
			var free_zone = -1
			for i in range(5):
				if player["monster_zones"][i] == null:
					free_zone = i
					break
			if free_zone == -1:
				return _error(ERR_ZONE_OCCUPIED)
			player["monster_zones"][free_zone] = {
				"card_id": summon_card,
				"position": "face_up_attack",
				"status": "summoned_this_turn",
				"attacked_this_turn": false
			}
			events.append({"type": "SPECIAL_SUMMON", "card_id": summon_card, "zone": free_zone})
		"destroy_all_monsters":
			for i in range(5):
				if player["monster_zones"][i]:
					player["graveyard"].append(player["monster_zones"][i].card_id)
					player["monster_zones"][i] = null
				if opponent["monster_zones"][i]:
					opponent["graveyard"].append(opponent["monster_zones"][i].card_id)
					opponent["monster_zones"][i] = null
			events.append({"type": "DESTROY_ALL_MONSTERS"})
		"destroy_all_attackers":
			for i in range(5):
				var zone = opponent["monster_zones"][i]
				if zone and zone.position.find("attack") != -1:
					opponent["graveyard"].append(zone.card_id)
					opponent["monster_zones"][i] = null
			events.append({"type": "DESTROY_MONSTERS", "player": opponent["player_id"]})
		"destroy_summoned_monster":
			var summoned = false
			for i in range(5):
				if opponent["monster_zones"][i] and opponent["monster_zones"][i].get("status") == "summoned_this_turn":
					opponent["graveyard"].append(opponent["monster_zones"][i].card_id)
					opponent["monster_zones"][i] = null
					summoned = true
					break
			if not summoned:
				return _error("NO_SUMMONED_MONSTER")
			events.append({"type": "DESTROY_MONSTER", "player": opponent["player_id"]})
		"reduce_atk_0":
			if game_state["chain_trigger"] and game_state["chain_trigger"].type == "ATTACK_DECLARED":
				var atk_zone = game_state["chain_trigger"].attacker_zone
				var atk_player = game_state["players"][game_state["chain_trigger"].player_id]
				if atk_player.monster_zones[atk_zone]:
					atk_player.monster_zones[atk_zone].atk_modifier = 0
					events.append({"type": "ATK_MODIFIED", "card_id": atk_player.monster_zones[atk_zone].card_id, "new_atk": 0})
		_:
			return _error(ERR_NO_EFFECT)
	
	# X√≥a card spell/trap sau khi activate (tr·ª´ continuous)
	if zone_type == "spell_trap" and not effect in ["continuous_effect"]:
		player["spell_trap_zones"][zone_idx] = null
		player["graveyard"].append(card_id)
	
	return {"success": true, "events": events}

func _check_win_condition(game_state):
	for pid in game_state["players"]:
		var p = game_state["players"][pid]
		if p.life_points <= 0:
			return {"winner": _get_opponent_id(game_state, pid), "reason": WIN_REASON_LP_ZERO}
		if len(p.deck) == 0 and game_state["phase"] == "draw":
			return {"winner": _get_opponent_id(game_state, pid), "reason": WIN_REASON_DECK_OUT}
		var exodia_pieces = ["EXODIA_HEAD", "LEFT_ARM", "RIGHT_ARM", "LEFT_LEG", "RIGHT_LEG"]
		var has_all_exodia = true
		for piece in exodia_pieces:
			if not piece in p.hand:
				has_all_exodia = false
				break
		if has_all_exodia:
			return {"winner": pid, "reason": WIN_REASON_EXODIA}
	return {"winner": null, "reason": null}

func _reset_turn_flags(player):
	for i in range(5):
		if player["monster_zones"][i]:
			player["monster_zones"][i].erase("status")
			player["monster_zones"][i].erase("attacked_this_turn")
			player["monster_zones"][i].erase("atk_modifier")

func _error(reason):
	return {
		"success": false,
		"errors": [reason],
		"events": [],
		"available_actions": []
	}




================================================================================

--- FILE: autoload\CardDatabase.gd ---
# ===========================================================================
# CardDatabase.gd - N·∫°p v√† qu·∫£n l√Ω to√†n b·ªô d·ªØ li·ªáu b√†i Yu-Gi-Oh!
# Autoload Singleton - D√πng ƒë·ªÉ truy v·∫•n th√¥ng tin b√†i
# ===========================================================================

extends Node

# L∆∞u to√†n b·ªô d·ªØ li·ªáu b√†i: card_id ‚Üí card_data
var cards = {}

# Signal ƒë·ªÉ th√¥ng b√°o l·ªói cho bot ho·∫∑c debug
signal card_database_error(error_code, message)

# Error codes
const ERR_FILE_NOT_FOUND = "FILE_NOT_FOUND"
const ERR_JSON_INVALID = "JSON_INVALID"
const ERR_CARD_INVALID = "CARD_INVALID"
const ERR_CARD_NOT_FOUND = "CARD_NOT_FOUND"
const PATH_CARDS = "res://data/cards.json"

# ===========================================================================
# _ready()
# T·ª± ƒë·ªông n·∫°p file JSON khi game kh·ªüi ƒë·ªông
# ===========================================================================
func _ready():
	randomize()  # C·∫ßn cho randi()
	var error = _load_cards(PATH_CARDS)
	if error:
		emit_signal("card_database_error", error[0], error[1])
		push_error("‚ùå CardDatabase: Kh√¥ng th·ªÉ n·∫°p cards.json - %s" % error[1])
	else:
		print("‚úÖ CardDatabase: ƒê√£ n·∫°p %d l√° b√†i." % cards.size())


# ===========================================================================
# _load_cards(path)
# N·∫°p file JSON v√† l∆∞u v√†o b·ªô nh·ªõ
# Tr·∫£ v·ªÅ [error_code, message] n·∫øu c√≥ l·ªói, null n·∫øu th√†nh c√¥ng
# ===========================================================================
func _load_cards(path):
	if not File.new().file_exists(path):
		return [ERR_FILE_NOT_FOUND, "File kh√¥ng t·ªìn t·∫°i: %s" % path]

	var file = File.new()
	var err = file.open(path, File.READ)
	if err != OK:
		return [ERR_FILE_NOT_FOUND, "Kh√¥ng th·ªÉ m·ªü file: %s (m√£ l·ªói: %d)" % [path, err]]

	var json_data = file.get_as_text()
	file.close()

	if json_data.empty():
		return [ERR_JSON_INVALID, "File JSON r·ªóng: %s" % path]

	var parse_result = JSON.parse(json_data)
	if parse_result.error != OK:
		return [ERR_JSON_INVALID, "L·ªói parse JSON t·∫°i d√≤ng %d: %s" % [parse_result.error_line, parse_result.error_string]]

	var data = parse_result.result
	if typeof(data) != TYPE_DICTIONARY:
		return [ERR_JSON_INVALID, "JSON kh√¥ng ph·∫£i object: %s" % path]

	# Validate v√† g√°n
	cards = {}
	for card_id in data:
		var card = data[card_id]
		var error = _validate_card(card_id, card)
		if error:
			print("card ko hop le: %s | %s"% [card_id, error])
			emit_signal("card_database_error", ERR_CARD_INVALID, "Card %s kh√¥ng h·ª£p l·ªá: %s" % [card_id, error])
			continue
		cards[card_id] = card

	return null


# ===========================================================================
# _validate_card(card_id, card)
# Ki·ªÉm tra d·ªØ li·ªáu l√° b√†i h·ª£p l·ªá
# Tr·∫£ v·ªÅ null n·∫øu ok, ho·∫∑c string m√¥ t·∫£ l·ªói
# ===========================================================================

#json parse tr·∫£ v·ªÅ type_real ko ph·∫£i type INT
func _validate_card(card_id, card):
	if not card is Dictionary:
		return "Kh√¥ng ph·∫£i dictionary"

	# T·ª± ƒë·ªông ƒëi·ªÅn ID n·∫øu thi·∫øu
	if not card.has("id") or card["id"] != card_id:
		card["id"] = card_id  # T·ª± s·ª≠a

	if not card.has("name"):
		push_warning("Card %s thi·∫øu 'name'" % card_id)
		card["name"] = card_id

	if not card.has("type") or not card["type"]  in ["monster", "spell", "trap"]:
		return "Thi·∫øu ho·∫∑c type kh√¥ng h·ª£p l·ªá: %s" % card.get("type", "missing")

	if card["type"] == "monster":
		# Ki·ªÉm tra atk
		if not card.has("atk"):
			return "Monster thi·∫øu atk"
		var atk = card["atk"]
		if typeof(atk) != TYPE_INT and typeof(atk) != TYPE_REAL:
			return "atk ph·∫£i l√† s·ªë (hi·ªán t·∫°i: %s, ki·ªÉu: %s)" % [str(atk), typeof(atk)]
		if int(atk) < 0:
			return "atk kh√¥ng ƒë∆∞·ª£c √¢m"
		card["atk"] = int(atk)

		# Ki·ªÉm tra def
		if not card.has("def"):
			return "Monster thi·∫øu def"
		var def_val = card["def"]
		if typeof(def_val) != TYPE_INT and typeof(def_val) != TYPE_REAL:
			return "def ph·∫£i l√† s·ªë"
		if int(def_val) < 0:
			return "def kh√¥ng ƒë∆∞·ª£c √¢m"
		card["def"] = int(def_val)

	if card["type"] in ["spell", "trap"]:
		if not card.has("effect"):
			push_warning("Card %s thi·∫øu 'effect'" % card_id)
			card["effect"] = ""

	return null


# ===========================================================================
# get(card_id) ‚Üí Dictionary
# L·∫•y d·ªØ li·ªáu l√° b√†i theo ID
# Tr·∫£ v·ªÅ {} n·∫øu kh√¥ng t√¨m th·∫•y
# ===========================================================================
func get(card_id):
	if cards.has(card_id):
		return cards[card_id].duplicate()  # Tr·∫£ b·∫£n sao
	else:
		emit_signal("card_database_error", ERR_CARD_NOT_FOUND, "Kh√¥ng t√¨m th·∫•y b√†i v·ªõi ID '%s'" % card_id)
		return {}


# ===========================================================================
# exists(card_id) ‚Üí bool
# Ki·ªÉm tra b√†i c√≥ t·ªìn t·∫°i kh√¥ng
# ===========================================================================
func exists(card_id):
	return cards.has(card_id)


# ===========================================================================
# find_by_name(name) ‚Üí Array[card]
# T√¨m b√†i theo t√™n (ph·∫ßn trƒÉm tr√πng kh·ªõp - ƒë∆°n gi·∫£n)
# ===========================================================================
func find_by_name(name):
	name = name.to_lower()
	var results = []
	for card_id in cards:
		var card = cards[card_id]
		if str(card.get("name", "")).to_lower().find(name) != -1:
			results.append(card.duplicate())
	return results


# ===========================================================================
# get_cards_by_type(type) ‚Üí Array[card]
# L·∫•y t·∫•t c·∫£ b√†i theo type (monster, spell, trap)
# ===========================================================================
func get_cards_by_type(type):
	var results = []
	for card_id in cards:
		if cards[card_id].get("type") == type:
			results.append(cards[card_id].duplicate())
	return results


# ===========================================================================
# get_random_card(type=null) ‚Üí Dictionary
# L·∫•y ng·∫´u nhi√™n m·ªôt l√° b√†i, t√πy ch·ªçn l·ªçc theo type
# ===========================================================================
func get_random_card(type=null):
	var valid_cards = cards.keys()
	if type:
		var filtered_cards = []
		for id in valid_cards:
			if cards[id].get("type") == type:
				filtered_cards.append(id)
		valid_cards = filtered_cards
	if valid_cards.empty():
		return {}
	var card_id = valid_cards[randi() % valid_cards.size()]
	return cards[card_id].duplicate()


# ===========================================================================
# get_all() ‚Üí Dictionary
# Tr·∫£ v·ªÅ to√†n b·ªô c∆° s·ªü d·ªØ li·ªáu (d√πng cho debug)
# ===========================================================================
func get_all():
	return cards.duplicate(true)




================================================================================

--- FILE: autoload\DatabaseManager.gd ---
# ===========================================================================
# DatabaseManager.gd - Qu·∫£n l√Ω d·ªØ li·ªáu ng∆∞·ªùi ch∆°i (Godot 3.6)
# Autoload Singleton
# Ch·ª©c nƒÉng:
#   - ƒêƒÉng k√Ω / ƒëƒÉng nh·∫≠p ng∆∞·ªùi ch∆°i
#   - L∆∞u deck, stats, l·ªãch s·ª≠
#   - D√πng JSON ƒë·ªÉ l∆∞u tr·ªØ ƒë∆°n gi·∫£n
# ===========================================================================
extends Node

const SAVE_PATH = "user://players.json"
var players_data = {}

# ===========================================================================
# _ready()
# N·∫°p d·ªØ li·ªáu ng∆∞·ªùi ch∆°i t·ª´ file
# ===========================================================================
func _ready():
	_load_players()
	randomize()  # ƒê·∫£m b·∫£o randi() ho·∫°t ƒë·ªông

# ===========================================================================
# _load_players()
# ƒê·ªçc file JSON, n·∫øu kh√¥ng c√≥ th√¨ t·∫°o m·ªõi
# ===========================================================================
func _load_players():
	if not File.new().file_exists(SAVE_PATH):
		players_data = {}
		print("üÜï T·∫°o file d·ªØ li·ªáu ng∆∞·ªùi ch∆°i m·ªõi.")
		return

	var file = File.new()
	if file.open(SAVE_PATH, File.READ) != OK:
		push_error("‚ùå Kh√¥ng th·ªÉ m·ªü file: %s" % SAVE_PATH)
		players_data = {}
		return

	var json_str = file.get_as_text()
	file.close()

	var parse = JSON.parse(json_str)
	if parse.error != OK:
		push_error("‚ùå L·ªói parse JSON: %s" % parse.error_string)
		players_data = {}
		return

	players_data = parse.result if typeof(parse.result) == TYPE_DICTIONARY else {}
	print("‚úÖ ƒê√£ n·∫°p d·ªØ li·ªáu %d ng∆∞·ªùi ch∆°i." % players_data.size())

# ===========================================================================
# _save_players()
# L∆∞u d·ªØ li·ªáu ng∆∞·ªùi ch∆°i xu·ªëng file
# ===========================================================================
func _save_players():
	var file = File.new()
	if file.open(SAVE_PATH, File.WRITE) != OK:
		push_error("‚ùå Kh√¥ng th·ªÉ ghi file: %s" % SAVE_PATH)
		return

	file.store_string(JSON.print(players_data))
	file.close()
	print("üíæ ƒê√£ l∆∞u d·ªØ li·ªáu ng∆∞·ªùi ch∆°i.")

# ===========================================================================
# register(username, password) ‚Üí Dict
# ƒêƒÉng k√Ω ng∆∞·ªùi ch∆°i m·ªõi
# ===========================================================================
func register(username, password):
	if players_data.has(username):
		return { "success": false, "error": "USERNAME_EXISTS" }

	players_data[username] = {
		"username": username,
		"password_hash": _hash_password(password),
		"created_at": OS.get_unix_time(),
		"last_login": 0,
		"lp": 8000,
		"deck": [
			"BLUE_EYES_WHITE_DRAGON", "DARK_MAGICIAN",
			"POT_OF_GREED", "MONSTER_REBORN", "MIRROR_FORCE",
			"GYOUKI", "SUMMONED_SKULL"
		],
		"stats": {
			"win": 0,
			"loss": 0,
			"draw": 0
		},
		"match_history": []
	}
	_save_players()
	return { "success": true, "player": players_data[username].duplicate() }

# ===========================================================================
# login(username, password) ‚Üí Dict
# X√°c th·ª±c ƒëƒÉng nh·∫≠p
# ===========================================================================
func login(username, password):
	if not players_data.has(username):
		return { "success": false, "error": "USER_NOT_FOUND" }

	var data = players_data[username]
	if data["password_hash"] != _hash_password(password):
		return { "success": false, "error": "INVALID_PASSWORD" }

	data["last_login"] = OS.get_unix_time()
	_save_players()

	return { "success": true, "player": data.duplicate() }

# ===========================================================================
# get_player(username) ‚Üí Dict
# L·∫•y th√¥ng tin ng∆∞·ªùi ch∆°i (kh√¥ng bao g·ªìm password)
# ===========================================================================
func get_player(username):
	if not players_data.has(username):
		return {}
	var p = players_data[username].duplicate()
	p.erase("password_hash")
	return p

# ===========================================================================
# update_stats(username, win, loss, draw)
# C·∫≠p nh·∫≠t th·ªëng k√™ sau tr·∫≠n ƒë·∫•u
# ===========================================================================
func update_stats(username, win=0, loss=0, draw=0):
	if not players_data.has(username):
		return
	players_data[username]["stats"]["win"] += win
	players_data[username]["stats"]["loss"] += loss
	players_data[username]["stats"]["draw"] += draw
	_save_players()

# ===========================================================================
# add_match_history(username, opponent, result, room_id)
# Th√™m l·ªãch s·ª≠ tr·∫≠n ƒë·∫•u
# ===========================================================================
func add_match_history(username, opponent, result, room_id):
	if not players_data.has(username):
		return
	players_data[username]["match_history"].append({
		"opponent": opponent,
		"result": result,  # "win", "loss", "draw"
		"room_id": room_id,
		"timestamp": OS.get_unix_time()
	})
	_save_players()

# ===========================================================================
# get_deck(username) ‚Üí Array
# L·∫•y b·ªô b√†i c·ªßa ng∆∞·ªùi ch∆°i
# ===========================================================================
func get_deck(username):
	return players_data.get(username, {}).get("deck", [
		"BLUE_EYES_WHITE_DRAGON", "DARK_MAGICIAN",
		"POT_OF_GREED", "MONSTER_REBORN", "MIRROR_FORCE"
	])

# ===========================================================================
# _hash_password(password) ‚Üí String
# Hash ƒë∆°n gi·∫£n (kh√¥ng d√πng MD5 th·∫≠t, ch·ªâ m√¥ ph·ªèng)
# ===========================================================================
func _hash_password(password):
	var hash_ = 5381
	for c in password.to_ascii():
		hash_ = (hash_ * 33) + c
	return str(hash_)

# ===========================================================================
# create_guest() ‚Üí Dict
# T·∫°o ng∆∞·ªùi ch∆°i t·∫°m (guest)
# ===========================================================================
func create_guest():
	var guest_id = "guest_%d" % (OS.get_unix_time() % 10000)
	var deck = [
		"GYOUKI", "SUMMONED_SKULL", "POT_OF_GREED",
		"TRAP_HOLE", "SUIJIN", "DARK_MAGICIAN"
	]
	players_data[guest_id] = {
		"username": guest_id,
		"password_hash": "",
		"created_at": OS.get_unix_time(),
		"last_login": OS.get_unix_time(),
		"lp": 8000,
		"deck": deck,
		"stats": { "win": 0, "loss": 0, "draw": 0 },
		"match_history": [],
		"is_guest": true
	}
	_save_players()
	return { "success": true, "player": players_data[guest_id].duplicate() }

================================================================================

--- FILE: autoload\GameManager.gd ---
# ===========================================================================
# GameManager.gd - Qu·∫£n l√Ω v√≤ng ƒë·ªùi tr·∫≠n ƒë·∫•u
# Kh√¥ng x·ª≠ l√Ω m·∫°ng, ch·ªâ d√πng BattleCore v√† DatabaseManager
# ===========================================================================
extends Node

# Danh s√°ch tr·∫≠n ƒë·∫•u: room_id ‚Üí { player_a, player_b, status, ... }
var active_games = {}

# Tham chi·∫øu
onready var database_manager = DatabaseManager
onready var battle_core = BattleCore

# Signal
signal game_started(room_id, player_a, player_b)
signal game_finished(room_id, winner, reason)
signal game_event(room_id, events)  # ‚úÖ Th√¥ng b√°o event t·ª´ bot ho·∫∑c h√†nh ƒë·ªông

# ===========================================================================
# create_duel(player_a_id, player_b_id)
# T·∫°o tr·∫≠n ƒë·∫•u m·ªõi (PvP 1v1)
# ===========================================================================
func create_duel(player_a_id, player_b_id):
	var deck_a = database_manager.get_deck(player_a_id)
	var deck_b = database_manager.get_deck(player_b_id)
	var rules = { "start_lp": 8000, "max_hand_size": 6 }

	var room_id = battle_core.start_duel(player_a_id, player_b_id, deck_a, deck_b, rules)
	if typeof(room_id) != TYPE_STRING:
		return { "success": false, "error": "FAILED_TO_CREATE_DUEL" }

	active_games[room_id] = {
		"player_a": player_a_id,
		"player_b": player_b_id,
		"room_id": room_id,
		"status": "started",
		"start_time": OS.get_unix_time(),
		"mode": "pvp_1v1"
	}

	emit_signal("game_started", room_id, player_a_id, player_b_id)
	print("üéÆ GameManager: Tr·∫≠n PvP '%s' ƒë√£ t·∫°o gi·ªØa %s v√† %s" % [room_id, player_a_id, player_b_id])
	return { "success": true, "room_id": room_id }

# ===========================================================================
# submit_action(room_id, action)
# G·ª≠i h√†nh ƒë·ªông ƒë·∫øn BattleCore
# ===========================================================================
func submit_action(room_id, action):
	if not active_games.has(room_id):
		return { "success": false, "error": "GAME_NOT_FOUND" }
	
	var result = battle_core.submit_action(room_id, action)
	# Ph√°t t√≠n hi·ªáu ƒë·ªÉ ServerManager broadcast
	emit_signal("game_event", room_id, result.events)
	return result

# ===========================================================================
# get_game_state(room_id, player_id = null)
# L·∫•y tr·∫°ng th√°i tr·∫≠n (·∫©n b√†i ƒë·ªëi th·ªß n·∫øu ch·ªâ ƒë·ªãnh player_id)
# ===========================================================================
func get_game_state(room_id, player_id = null):
	if not active_games.has(room_id):
		return null
	return battle_core.get_game_state(room_id, player_id)

# ===========================================================================
# end_game(room_id, winner, reason)
# K·∫øt th√∫c tr·∫≠n, c·∫≠p nh·∫≠t stats
# ===========================================================================
func end_game(room_id, winner, reason):
	if not active_games.has(room_id):
		return

	var game = active_games[room_id]
	var player_a = game["player_a"]
	var player_b = game["player_b"]

	# C·∫≠p nh·∫≠t stats
	if winner == player_a:
		database_manager.update_stats(player_a, 1, 0, 0)
		database_manager.update_stats(player_b, 0, 1, 0)
		database_manager.add_match_history(player_a, player_b, "win", room_id)
		database_manager.add_match_history(player_b, player_a, "loss", room_id)
	elif winner == player_b:
		database_manager.update_stats(player_b, 1, 0, 0)
		database_manager.update_stats(player_a, 0, 1, 0)
		database_manager.add_match_history(player_b, player_a, "win", room_id)
		database_manager.add_match_history(player_a, player_b, "loss", room_id)

	# Ph√°t t√≠n hi·ªáu ƒë·ªÉ ServerManager x·ª≠ l√Ω
	emit_signal("game_event", room_id, [{"type": "WIN", "winner": winner, "reason": reason}])
	
	# D·ªçn d·∫πp
	active_games.erase(room_id)
	emit_signal("game_finished", room_id, winner, reason)
	print("üèÅ GameManager: Tr·∫≠n '%s' k·∫øt th√∫c. Ng∆∞·ªùi th·∫Øng: %s" % [room_id, winner])

# ===========================================================================
# create_duel_vs_bot(player_id)
# T·∫°o tr·∫≠n ƒë·∫•u gi·ªØa ng∆∞·ªùi ch∆°i v√† bot (AI)
# ===========================================================================
func create_duel_vs_bot(player_id):
	var bot_id = "bot_ai"
	var player_deck = database_manager.get_deck(player_id)
	var bot_deck = _get_bot_deck()

	var rules = { "start_lp": 8000, "max_hand_size": 6 }
	var room_id = battle_core.start_duel(player_id, bot_id, player_deck, bot_deck, rules)

	if typeof(room_id) != TYPE_STRING:
		return { "success": false, "error": "FAILED_TO_CREATE_DUEL" }

	# L∆∞u v√†o danh s√°ch tr·∫≠n
	active_games[room_id] = {
		"player_a": player_id,
		"player_b": bot_id,
		"room_id": room_id,
		"status": "started",
		"start_time": OS.get_unix_time(),
		"mode": "pve"
	}

	# Th√¥ng b√°o tr·∫≠n b·∫Øt ƒë·∫ßu
	emit_signal("game_started", room_id, player_id, bot_id)
	print("üéÆ GameManager: Tr·∫≠n PvE '%s' ƒë√£ t·∫°o gi·ªØa %s v√† %s" % [room_id, player_id, bot_id])

	# B·∫Øt ƒë·∫ßu v√≤ng l·∫∑p bot
	_schedule_bot_turn(room_id)

	return { "success": true, "room_id": room_id }

# ===========================================================================
# _get_bot_deck() ‚Üí Array
# Tr·∫£ v·ªÅ b·ªô b√†i m·∫´u cho bot
# ===========================================================================
func _get_bot_deck() -> Array:
	return [
		"BLUE_EYES_WHITE_DRAGON", "BLUE_EYES_WHITE_DRAGON", "SUMMONED_SKULL",
		"DARK_MAGICIAN", "GYOUKI", "SUIJIN", "KURIBOH", "MAN_EATER_BUTTERFLY",
		"DARK_HOLE", "MIRROR_FORCE", "TRAP_HOLE", "POT_OF_GREED", "CARD_OF_DESTRUCTION",
		"MONSTER_REBORN", "FACE_UP", "SACRIFICE", "OFFERING", "DRAGON", "WARRIOR", "SPELL"
	]

# ===========================================================================
# _schedule_bot_turn(room_id)
# L·∫≠p l·ªãch ƒë·ªÉ bot ch∆°i l∆∞·ª£t (d√πng deferred ƒë·ªÉ tr√°nh l·ªói tree)
# ===========================================================================
func _schedule_bot_turn(room_id):
	get_tree().create_timer(1.5).connect("timeout", self, "_run_bot_turn", [room_id])

# ===========================================================================
# _run_bot_turn(room_id)
# X·ª≠ l√Ω l∆∞·ª£t c·ªßa bot
# ===========================================================================
func _run_bot_turn(room_id):
	# Ki·ªÉm tra tr·∫≠n c√≤n t·ªìn t·∫°i
	if not active_games.has(room_id):
		return

	var game = active_games[room_id]
	var bot_id = game["player_b"]
	if bot_id != "bot_ai":
		return

	var state = battle_core.get_game_state(room_id)
	if not state or state.status != "active":
		return

	# N·∫øu ƒë·∫øn l∆∞·ª£t bot
	if state.turn == bot_id:
		var available_actions = battle_core.get_available_actions(room_id, bot_id)
		if available_actions.empty():
			return

		# Bot ch·ªçn h√†nh ƒë·ªông
		var action = YugiBot.choose_action(state, bot_id, available_actions)
		if action:
			action.player_id = bot_id
			var result = battle_core.submit_action(room_id, action)

			# H·ªçc t·ª´ k·∫øt qu·∫£ n·∫øu b·∫≠t learning
			if Agent.learning_mode:
				Agent.learn_from_result(state, action, result)

			# Ph√°t t√≠n hi·ªáu ƒë·ªÉ ServerManager broadcast
			emit_signal("game_event", room_id, result.events)

	# N·∫øu ch∆∞a ph·∫£i l∆∞·ª£t bot, ti·∫øp t·ª•c schedule
	if state.turn != bot_id and state.status == "active":
		_schedule_bot_turn(room_id)

================================================================================

--- FILE: autoload\NetworkManager.gd ---
# ===========================================================================
# NetworkManager.gd - Server ENet for Godot 3.6
# ===========================================================================
extends Node

const DEFAULT_PORT = 8080
const SERVER_PEER_ID = 1

var is_server = false
var peer_to_player = {}

signal client_connected(player_id, peer_id)
signal client_disconnected(peer_id)
signal message_received(player_id, message)

func _ready():
	var enet = NetworkedMultiplayerENet.new()
	var err = enet.create_server(DEFAULT_PORT, 32)
	if err != OK:
		push_error("Cannot create ENet server")
		return
	get_tree().network_peer = enet
	is_server = true
	get_tree().connect("network_peer_connected", self, "_on_peer_connected")
	get_tree().connect("network_peer_disconnected", self, "_on_peer_disconnected")

func _process(_d):
	if not is_server or not multiplayer.network_peer:
		return
	multiplayer.poll()

func _on_peer_connected(peer_id):
	var temp_player = "player_%d" % peer_id
	peer_to_player[peer_id] = temp_player
	emit_signal("client_connected", temp_player, peer_id)
	var welcome = {
		"type": "AUTH_REQUEST",
		"message": "Send AUTH_LOGIN to authenticate"
	}
	rpc_id(peer_id, "receive_message", welcome)

func _on_peer_disconnected(peer_id):
	peer_to_player.erase(peer_id)
	emit_signal("client_disconnected", peer_id)

remote func receive_message(message):
	var peer_id = multiplayer.get_rpc_sender_id()
	var player_id = peer_to_player.get(peer_id, "unknown")
	if typeof(message) != TYPE_DICTIONARY or not message.has("type"):
		_send_error(peer_id, "MALFORMED")
		return
	emit_signal("message_received", player_id, message)

func send_message_to_player(player_id: String, data: Dictionary):
	var pid = _get_peer_from_player(player_id)
	if pid == 0:
		return
	rpc_id(pid, "receive_message", data)

func broadcast_message(data: Dictionary, exclude_player := ""):
	for pid in peer_to_player.keys():
		if exclude_player != "" and peer_to_player[pid] == exclude_player:
			continue
		rpc_id(pid, "receive_message", data)

func _get_peer_from_player(player_id):
	for pid in peer_to_player:
		if peer_to_player[pid] == player_id:
			return pid
	return 0

func _send_error(peer_id, code, msg := ""):
	var e = { "type": "ERROR", "code": code, "message": msg }
	rpc_id(peer_id, "receive_message", e)

================================================================================

--- FILE: autoload\PvEManager.gd ---
# res://autoload/PvEManager.gd
extends Node

# Tham chi·∫øu
onready var battle_core = BattleCore
onready var network_manager = NetworkManager
onready var card_db = CardDatabase

# ID bot ·∫£o
const BOT_ID = "bot_ai_1"
const BOT_DECK = ["BLUE_EYES_WHITE_DRAGON", "BLUE_EYES_WHITE_DRAGON", "BLUE_EYES_WHITE_DRAGON", "SUIJIN", "POT_OF_GREED", "MIRROR_FORCE", "DARK_HOLE", "TRAP_HOLE", "MONSTER_REBORN", "KURIBOH"] # V√≠ d·ª•

func start_pve_game(player_id, deck_player):
	# T·∫°o deck cho bot (c√≥ th·ªÉ random sau)
	var deck_bot = BOT_DECK.duplicate()
	
	# D√πng BattleCore c√≥ s·∫µn ƒë·ªÉ t·∫°o tr·∫≠n
	var room_id = battle_core.start_duel(player_id, BOT_ID, deck_player, deck_bot, {})
	
	if not room_id:
		return false

	# G·ª≠i th√¥ng b√°o cho client
	network_manager.send_message_to_player(player_id, {
		"type": "GAME_STARTED",
		"room_id": room_id,
		"side": "player", # ho·∫∑c random
		"mode": "pve"
	})

	# B·∫Øt ƒë·∫ßu v√≤ng l·∫∑p bot
	_schedule_bot_turn(room_id)

	return true

# H√†m l·∫≠p l·ªãch l∆∞·ª£t bot
func _schedule_bot_turn(room_id):
	# D√πng timer ƒë·ªÉ ch·∫°y sau khi frame hi·ªán t·∫°i xong
	get_tree().call_deferred("_run_bot_turn", room_id)

func _run_bot_turn(room_id):
	if not battle_core.active_duels.has(room_id):
		return
	
	var game_state = battle_core.get_game_state(room_id)
	if not game_state:
		return

	# Ki·ªÉm tra xem c√≥ ph·∫£i l∆∞·ª£t bot kh√¥ng
	if game_state.turn == BOT_ID and game_state.status == "active":
		# L·∫•y c√°c h√†nh ƒë·ªông kh·∫£ d·ª•ng
		var available_actions = battle_core.get_available_actions(room_id, BOT_ID)
		
		# Bot ch·ªçn h√†nh ƒë·ªông (d√πng YugiBot hi·ªán c√≥)
		var action = YugiBot.choose_action(game_state, BOT_ID, available_actions)
		
		if action:
			# G·ª≠i h√†nh ƒë·ªông v√†o core
			var result = battle_core.submit_action(room_id, action)
			
			# G·ª≠i k·∫øt qu·∫£ v·ªÅ cho ng∆∞·ªùi ch∆°i (ƒë·ªÉ update UI)
			for player in [game_state.players.keys()[0]]: # ch·ªâ player th·∫≠t
				if player != BOT_ID:
					network_manager.send_message_to_player(player, {
						"type": "ACTION_RESULT",
						"result": result
					})
	
	# Lu√¥n schedule l·∫°i ƒë·ªÉ ki·ªÉm tra ti·∫øp
	get_tree().create_timer(1.5).connect("timeout", self, "_schedule_bot_turn", [room_id])

================================================================================

--- FILE: autoload\ServerManager.gd ---
# ===========================================================================
# ServerManager.gd - Message router for gameplay (Godot 3.6)
# Depends on GameManager + BattleCore existing in autoloads.
# ===========================================================================
extends Node

var rooms = {}
var player_to_room = {}

onready var network_manager = NetworkManager
onready var auth_manager = AuthManager
onready var game_manager = GameManager

func _ready():
	print("[S-SERVER] Ready")
	auth_manager.connect("player_authenticated", self, "_on_player_authenticated")
	network_manager.connect("message_received", self, "_on_message_received")
	game_manager.connect("game_started", self, "_on_game_started")
	game_manager.connect("game_finished", self, "_on_game_finished")
	game_manager.connect("game_event", self, "_on_game_event")

func _on_player_authenticated(player_id, token, peer_id):
	pass  # AUTH_SUCCESS already sent by AuthManager

func _on_message_received(player_id, message):
	var t = str(message.get("type", ""))
	match t:
		"LIST_ROOMS":
			_send_room_list(player_id)
		"CREATE_ROOM":
			_handle_create_room(player_id, message)
		"JOIN_ROOM":
			_handle_join_room(player_id, message)
		"GET_STATE":
			_handle_get_state(player_id, message)
		"SUBMIT_ACTION":
			_handle_submit_action(player_id, message)
		_:
			pass

func _handle_create_room(player_id, message):
	var mode = str(message.get("mode", "pvp_1v1"))
	if mode == "pve":
		# Start PvE via GameManager
		var result = game_manager.create_duel_vs_bot(player_id)
		if not result.success:
			network_manager.send_message_to_player(player_id, { "type": "ERROR", "code": result.error, "message": "" })
			return
		var room_id = result.room_id
		rooms[room_id] = { "player_a": player_id, "player_b": "bot_ai", "status": "playing", "duel_id": room_id }
		player_to_room[player_id] = room_id
		network_manager.send_message_to_player(player_id, { "type": "ROOM_CREATED", "room_id": room_id })
		return
	
	# PvP room waiting for opponent
	var room_id = "room_%d" % (OS.get_unix_time() % 100000)
	rooms[room_id] = { "player_a": player_id, "player_b": "", "status": "waiting" }
	player_to_room[player_id] = room_id
	network_manager.send_message_to_player(player_id, { "type": "ROOM_CREATED", "room_id": room_id })

func _handle_join_room(player_id, message):
	var room_id = str(message.get("room_id", ""))
	if room_id == "" or not rooms.has(room_id):
		network_manager.send_message_to_player(player_id, { "type": "ERROR", "code": "ROOM_NOT_FOUND", "message": "" })
		return
	if rooms[room_id]["player_b"] == "" and rooms[room_id]["player_a"] != player_id:
		rooms[room_id]["player_b"] = player_id
		player_to_room[player_id] = room_id
		# Start duel via GameManager
		var ra = rooms[room_id]["player_a"]
		var rb = rooms[room_id]["player_b"]
		var result = game_manager.create_duel(ra, rb)
		if not result.success:
			network_manager.send_message_to_player(player_id, { "type": "ERROR", "code": result.error, "message": "" })
			return
		rooms[room_id]["duel_id"] = result.room_id
		rooms[room_id]["status"] = "playing"
	else:
		network_manager.send_message_to_player(player_id, { "type": "ERROR", "code": "ROOM_FULL", "message": "" })

func _handle_get_state(player_id, message):
	var room_id = str(message.get("room_id", ""))
	if room_id == "" or not rooms.has(room_id):
		network_manager.send_message_to_player(player_id, { "type": "ERROR", "code": "ROOM_NOT_FOUND", "message": "" })
		return
	var duel_id = rooms[room_id].get("duel_id", "")
	var state = game_manager.get_game_state(duel_id, player_id)
	network_manager.send_message_to_player(player_id, { "type": "GAME_STATE", "state": state })

func _handle_submit_action(player_id, message):
	var room_id = str(message.get("room_id", ""))
	var action = message.get("action", {})
	if room_id == "" or not rooms.has(room_id):
		network_manager.send_message_to_player(player_id, { "type": "ERROR", "code": "ROOM_NOT_FOUND", "message": "" })
		return
	var duel_id = rooms[room_id].get("duel_id", "")
	if typeof(action) != TYPE_DICTIONARY:
		network_manager.send_message_to_player(player_id, { "type": "ERROR", "code": "INVALID_ACTION", "message": "" })
		return
	action["player_id"] = player_id
	var result = game_manager.submit_action(duel_id, action)
	# Broadcast result v√† state
	_broadcast_to_room(room_id, { "type": "ACTION_RESULT", "result": result })
	var state = game_manager.get_game_state(duel_id)
	_broadcast_to_room(room_id, { "type": "GAME_STATE", "state": state })

func _send_room_list(player_id):
	var list = []
	for k in rooms.keys():
		list.append({ "room_id": k, "status": rooms[k]["status"] })
	network_manager.send_message_to_player(player_id, { "type": "ROOM_LIST", "rooms": list })

func _on_game_started(room_id, player_a, player_b):
	# Broadcast GAME_STARTED v√† initial state
	_broadcast_to_room(room_id, { "type": "GAME_STARTED", "room_id": room_id })
	var state = game_manager.get_game_state(room_id)
	_broadcast_to_room(room_id, { "type": "GAME_STATE", "state": state })

func _on_game_finished(room_id, winner, reason):
	# Broadcast GAME_OVER
	_broadcast_to_room(room_id, { "type": "GAME_OVER", "winner": winner, "reason": reason })
	# Cleanup room
	if rooms.has(room_id):
		var room = rooms[room_id]
		for pid in [room.get("player_a", ""), room.get("player_b", "")]:
			if pid != "" and pid != "bot_ai":
				player_to_room.erase(pid)
		rooms.erase(room_id)

func _on_game_event(room_id, events):
	# Broadcast events v√† updated state
	_broadcast_to_room(room_id, { "type": "GAME_EVENT", "events": events })
	var duel_id = rooms[room_id].get("duel_id", "") if rooms.has(room_id) else ""
	if duel_id != "":
		var state = game_manager.get_game_state(duel_id)
		_broadcast_to_room(room_id, { "type": "GAME_STATE", "state": state })

# Helper to broadcast message to all players in room
func _broadcast_to_room(room_id: String, message: Dictionary):
	if not rooms.has(room_id):
		return
	var room = rooms[room_id]
	for pid in [room.get("player_a", ""), room.get("player_b", "")]:
		if pid != "" and pid != "bot_ai":  # B·ªè qua bot
			network_manager.send_message_to_player(pid, message)

================================================================================

--- FILE: autoload\YugiBot.gd ---
# ===========================================================================
# YugiBot.gd - Bot ch∆°i Yu-Gi-Oh! th·ªß c√¥ng (Godot 3.6)
# Autoload Singleton - T·ª± ƒë·ªông ch·ªçn v√† th·ª±c hi·ªán h√†nh ƒë·ªông d·ª±a tr√™n heuristic
# Kh√¥ng c·∫ßn UI, kh√¥ng c·∫ßn m·∫°ng, t√≠ch h·ª£p v·ªõi BattleCore v√† CardDatabase
# ===========================================================================
extends Node

# ===========================================================================
# play_turn(room_id, player_id)
# Bot th·ª±c hi·ªán to√†n b·ªô l∆∞·ª£t c·ªßa player_id trong room_id
# Tr·∫£ v·ªÅ: { success: bool, action_taken: Dictionary, result: Dictionary }
# ===========================================================================
func play_turn(room_id, player_id):
	var state = BattleCore.get_game_state(room_id, player_id)
	if state.empty():
		return {"success": false, "action_taken": {}, "result": {"errors": ["ROOM_NOT_FOUND"]}}
	if state["status"] != "active" or state["turn"] != player_id:
		return {"success": false, "action_taken": {}, "result": {"errors": ["NOT_YOUR_TURN"]}}
	var actions = BattleCore.get_available_actions(room_id, player_id)
	var action = _choose_action(state, player_id, actions)
	if action["type"] == "":
		return {"success": false, "action_taken": {}, "result": {"errors": ["NO_ACTION_CHOSEN"]}}
	var result = BattleCore.submit_action(room_id, action)
	return {"success": result["success"], "action_taken": action, "result": result}

# ===========================================================================
# _choose_action(state, player_id, actions)
# Ch·ªçn h√†nh ƒë·ªông t·ªëi ∆∞u d·ª±a tr√™n heuristic
# ‚úÖ ƒê√É S·ª¨A: ∆Øu ti√™n END_TURN khi ·ªü phase "end"
# ===========================================================================
func _choose_action(state, player_id, actions):
	var phase = state["phase"]
	var action_details = actions.details

	# X·ª≠ l√Ω chain tr∆∞·ªõc (n·∫øu c√≥)
	if not state["chain"].empty():
		var trap_action = _choose_trap_action(state, player_id, action_details)
		if trap_action.type != "":
			trap_action["player_id"] = player_id
			return trap_action

	# X·ª≠ l√Ω theo phase
	if phase == "draw" and "DRAW_CARD" in actions.types:
		return {"type": "DRAW_CARD", "player_id": player_id, "payload": {}}

	if phase in ["main1", "main2"]:
		var main_action = _choose_main_phase_action(state, player_id, action_details)
		if main_action.type != "":
			main_action["player_id"] = player_id
			return main_action

	if phase == "battle":
		var attack_action = _choose_attack_action(state, player_id, action_details)
		if attack_action.type != "":
			attack_action["player_id"] = player_id
			return attack_action

	# üü¢ ∆Øu ti√™n END_TURN n·∫øu ƒëang ·ªü phase "end"
	if phase == "end":
		if "END_TURN" in actions.types:
			return {"type": "END_TURN", "player_id": player_id, "payload": {}}
		elif "END_PHASE" in actions.types:
			return {"type": "END_PHASE", "player_id": player_id, "payload": {}}
		else:
			return {"type": "END_TURN", "player_id": player_id, "payload": {}}

	# N·∫øu kh√¥ng ph·∫£i end phase, th√¨ END_PHASE
	if "END_PHASE" in actions.types:
		return {"type": "END_PHASE", "player_id": player_id, "payload": {}}
	if "END_TURN" in actions.types:
		return {"type": "END_TURN", "player_id": player_id, "payload": {}}

	return {"type": "", "player_id": player_id, "payload": {}}

# ===========================================================================
# _choose_main_phase_action(state, player_id, action_details)
# Ch·ªçn h√†nh ƒë·ªông trong main phase (summon, spell, trap)
# ===========================================================================
func _choose_main_phase_action(state, player_id, action_details):
	# ∆Øu ti√™n 1: Activate spell c√≥ effect m·∫°nh (Pot of Greed, Monster Reborn, Dark Hole)
	for act in action_details:
		if act.type == "PLAY_SPELL":
			var card_id = act.payload["card_id"]
			var effect = CardDatabase.get(card_id).get("effect", "")
			if effect in ["draw_2", "special_summon_graveyard", "destroy_all_monsters"]:
				var action = act.duplicate()
				action["player_id"] = player_id
				return action

	# ∆Øu ti√™n 2: Summon qu√°i c√≥ ATK cao nh·∫•t
	var best_atk = -1
	var best_action = null
	for act in action_details:
		if act.type == "PLAY_MONSTER":
			var card_id = act.payload["card_id"]
			var atk = CardDatabase.get(card_id).get("atk", 0)
			if atk > best_atk:
				best_atk = atk
				best_action = act
	if best_action:
		var action = best_action.duplicate()
		action["player_id"] = player_id
		return action

	# ∆Øu ti√™n 3: Set trap
	for act in action_details:
		if act.type == "SET_TRAP":
			var action = act.duplicate()
			action["player_id"] = player_id
			return action

	# ∆Øu ti√™n 4: Set spell
	for act in action_details:
		if act.type == "SET_SPELL":
			var action = act.duplicate()
			action["player_id"] = player_id
			return action

	# ∆Øu ti√™n 5: Set monster n·∫øu kh√¥ng summon ƒë∆∞·ª£c
	for act in action_details:
		if act.type == "SET_MONSTER":
			var action = act.duplicate()
			action["player_id"] = player_id
			return action

	# # ∆Øu ti√™n 6: Activate effect tr√™n s√¢n
	# for act in action_details:
	# 	if act.type == "ACTIVATE_EFFECT":
	# 		var card_id = act.payload["card_id"]
	# 		var effect = CardDatabase.get(card_id).get("effect", "")
	# 		if effect != "":
	# 			var action = act.duplicate()
	# 			action["player_id"] = player_id
	# 			return action

	return {"type": "", "player_id": player_id, "payload": {}}

# ===========================================================================
# _choose_attack_action(state, player_id, action_details)
# Ch·ªçn h√†nh ƒë·ªông t·∫•n c√¥ng (∆∞u ti√™n qu√°i y·∫øu nh·∫•t c·ªßa ƒë·ªëi th·ªß)
# ===========================================================================
func _choose_attack_action(state, player_id, action_details):
	var player = state["players"][player_id]
	var opponent_id = _get_opponent_id(state)
	var opponent = state["players"][opponent_id]

	# T√¨m qu√°i m·∫°nh nh·∫•t c·ªßa m√¨nh ch∆∞a t·∫•n c√¥ng
	var best_atk = -1
	var best_atk_zone = -1
	for i in range(5):
		var monster_obj = player["monster_zones"][i]
		if monster_obj and monster_obj.position == "face_up_attack" and not monster_obj.get("attacked_this_turn", false):
			var atk = CardDatabase.get(monster_obj.card_id).get("atk", 0)
			if atk > best_atk:
				best_atk = atk
				best_atk_zone = i
	if best_atk_zone == -1:
		return {"type": "", "player_id": player_id, "payload": {}}

	# Ki·ªÉm tra direct attack
	var has_monster = false
	for zone in opponent["monster_zones"]:
		if zone != null:
			has_monster = true
			break
	if not has_monster:
		for act in action_details:
			if act.type == "DECLARE_ATTACK" and act.payload["atk_zone"] == best_atk_zone and not act.payload.has("target_zone"):
				var action = act.duplicate()
				action["player_id"] = player_id
				return action

	# T·∫•n c√¥ng qu√°i y·∫øu nh·∫•t
	var weakest_atk = 999999
	var weakest_zone = -1
	for i in range(5):
		if opponent["monster_zones"][i]:
			var atk = CardDatabase.get(opponent["monster_zones"][i].card_id).get("atk", 0)
			if atk < weakest_atk:
				weakest_atk = atk
				weakest_zone = i
	if weakest_zone != -1:
		for act in action_details:
			if act.type == "DECLARE_ATTACK" and act.payload["atk_zone"] == best_atk_zone and act.payload["target_zone"] == weakest_zone:
				var action = act.duplicate()
				action["player_id"] = player_id
				return action

	return {"type": "", "player_id": player_id, "payload": {}}

# ===========================================================================
# _choose_trap_action(state, player_id, action_details)
# Ch·ªçn trap ƒë·ªÉ k√≠ch ho·∫°t trong chain
# ===========================================================================
func _choose_trap_action(state, player_id, action_details):
	if state["chain_trigger"]:
		var trigger_type = state["chain_trigger"].get("type", "")
		if trigger_type == "ATTACK_DECLARED":
			for act in action_details:
				if act.type == "ACTIVATE_EFFECT":
					var card_id = act.payload["card_id"]
					var effect = CardDatabase.get(card_id).get("effect", "")
					if effect in ["destroy_all_attackers", "destroy_summoned_monster", "reduce_atk_0"]:
						var action = act.duplicate()
						action["player_id"] = player_id
						return action

		elif trigger_type == "SUMMON":
			for act in action_details:
				if act.type == "ACTIVATE_EFFECT":
					var card_id = act.payload["card_id"]
					var effect = CardDatabase.get(card_id).get("effect", "")
					if effect == "destroy_summoned_monster":
						var action = act.duplicate()
						action["player_id"] = player_id
						return action

	return {"type": "", "player_id": player_id, "payload": {}}

# ===========================================================================
# _get_opponent_id(state)
# L·∫•y ID c·ªßa ƒë·ªëi th·ªß
# ===========================================================================
func _get_opponent_id(state):
	for pid in state["players"]:
		if pid != state["turn"]:
			return pid
	return null

================================================================================

--- FILE: core\main.gd ---
# ===========================================================================
# Main.gd - Scene ch√≠nh ƒë·ªÉ test h·ªá th·ªëng Yu-Gi-Oh! (Godot 3.6)
# Kh·ªüi t·∫°o tr·∫≠n ƒë·∫•u, ƒë·ªÉ YugiBot ch∆°i t·ª± ƒë·ªông v√† gi·∫£ l·∫≠p ng∆∞·ªùi ch∆°i
# Kh√¥ng d√πng UI, ch·ªâ in k·∫øt qu·∫£ qua console
# ===========================================================================

extends Node

var room_id = ""
var human_player = "player_a"
var bot_player = "player_b"

# ===========================================================================
# _ready()
# Kh·ªüi t·∫°o tr·∫≠n ƒë·∫•u khi scene ch·∫°y
# ===========================================================================
func _ready():
	# ƒê·∫£m b·∫£o CardDatabase ƒë√£ n·∫°p
	if CardDatabase.get_all().empty():
		print("‚ùå L·ªói: CardDatabase ch∆∞a n·∫°p d·ªØ li·ªáu!")
		return
	
	# T·∫°o deck m·∫´u
	var deck_a = [
		"BLUE_EYES_WHITE_DRAGON", "BLUE_EYES_WHITE_DRAGON",
		"POT_OF_GREED", "MONSTER_REBORN", "DARK_HOLE",
		"SUMMONED_SKULL", "GYOUKI"
	]
	var deck_b = [
		"DARK_MAGICIAN", "DARK_MAGICIAN",
		"MIRROR_FORCE", "TRAP_HOLE", "SUIJIN",
		"GYOUKI", "SUMMONED_SKULL"
	]
	
	# Kh·ªüi t·∫°o tr·∫≠n ƒë·∫•u
	room_id = BattleCore.start_duel(human_player, bot_player, deck_a, deck_b, {
		"start_lp": 8000,
		"max_hand_size": 6,
		"forbidden_cards": []
	})
	print("this is room", room_id)
	if room_id == "":
		print("‚ùå L·ªói: Kh√¥ng th·ªÉ t·∫°o tr·∫≠n ƒë·∫•u!")
		return
	
	print("üéÆ Tr·∫≠n ƒë·∫•u b·∫Øt ƒë·∫ßu: %s" % room_id)
	_play_next_turn()


# ===========================================================================
# _play_next_turn()
# X·ª≠ l√Ω l∆∞·ª£t ti·∫øp theo, g·ªçi bot ho·∫∑c gi·∫£ l·∫≠p ng∆∞·ªùi ch∆°i
# ===========================================================================
# ===========================================================================
# _play_next_turn()
# ‚úÖ ƒê√É S·ª¨A: Th√™m v√≤ng l·∫∑p cho bot ƒë·ªÉ th·ª±c hi·ªán nhi·ªÅu h√†nh ƒë·ªông trong 1 l∆∞·ª£t
# ===========================================================================
func _play_next_turn():
	var state = BattleCore.get_game_state(room_id, human_player)
	if state.empty() or state["status"] != "active":
		print("üèÅ K·∫øt th√∫c tr·∫≠n.")
		return

	_print_game_state(state)

	if state["turn"] == bot_player:
		# üîÅ V√íNG L·∫∂P: Cho ph√©p bot th·ª±c hi·ªán nhi·ªÅu h√†nh ƒë·ªông
		while true:
			# L·∫•y tr·∫°ng th√°i m·ªõi nh·∫•t
			var current_state = BattleCore.get_game_state(room_id, bot_player)
			if current_state.empty() or current_state["status"] != "active" or current_state["turn"] != bot_player:
				break

			var bot_result = YugiBot.play_turn(room_id, bot_player)
			if bot_result.success:
				print("ü§ñ Bot action: %s" % bot_result.action_taken)
				print("üìà K·∫øt qu·∫£: %s", bot_result.result["events"])
			else:
				print("‚ùå Bot th·∫•t b·∫°i: %s" % bot_result.result["errors"])
				break

			# ‚úÖ TH√äM D√íNG N√ÄY: D·ª´ng 0.1s ƒë·ªÉ tr√°nh treo
			yield(get_tree().create_timer(0.1), "timeout")
	else:
		# üë§ Ng∆∞·ªùi ch∆°i (gi·∫£ l·∫≠p)
		var actions = BattleCore.get_available_actions(room_id, human_player)
		var action = _simulate_human_action(state, human_player, actions)
		var result = BattleCore.submit_action(room_id, action)
		if result["success"]:
			print("üë§ Human action: %s" % action)
			print("üìà K·∫øt qu·∫£: %s" , result["events"])
		else:
			print("‚ùå Human th·∫•t b·∫°i: %s" % result["errors"])

	# Ch·ªù 1 gi√¢y r·ªìi ti·∫øp t·ª•c
	yield(get_tree().create_timer(1.0), "timeout")
	_play_next_turn()

# ===========================================================================
# _simulate_human_action(state, player_id, actions)
# Gi·∫£ l·∫≠p h√†nh ƒë·ªông cho ng∆∞·ªùi ch∆°i (d·ª±a tr√™n heuristic ƒë∆°n gi·∫£n)
# ===========================================================================
func _simulate_human_action(state, player_id, actions):
	# ∆Øu ti√™n: Activate spell m·∫°nh
	for act in actions.details:
		if act.type == "PLAY_SPELL":
			var effect = CardDatabase.get(act.payload["card_id"]).get("effect", "")
			if effect in ["draw_2", "special_summon_graveyard", "destroy_all_monsters"]:
				return _with_player(act, player_id)  # ‚úÖ ƒê√£ c√≥ player_id
	# ∆Øu ti√™n 2: Summon qu√°i c√≥ ATK cao nh·∫•t
	var best_atk = -1
	var best_action = null
	for act in actions.details:
		if act.type == "PLAY_MONSTER":
			var atk = CardDatabase.get(act.payload["card_id"]).get("atk", 0)
			if atk > best_atk:
				best_atk = atk
				best_action = act
	if best_action:
		return _with_player(best_action, player_id)  # ‚úÖ
	# ∆Øu ti√™n 3: Attack qu√°i y·∫øu nh·∫•t
	if state["phase"] == "battle":
		var opponent_id = _get_opponent_id(state)
		var opponent = state["players"][opponent_id]
		var weakest_atk = 999999
		var weakest_zone = -1
		for i in range(5):
			if opponent["monster_zones"][i]:
				var atk = CardDatabase.get(opponent["monster_zones"][i].card_id).get("atk", 0)
				if atk < weakest_atk:
					weakest_atk = atk
					weakest_zone = i
		if weakest_zone != -1:
			for act in actions.details:
				if act.type == "DECLARE_ATTACK" and act.payload["target_zone"] == weakest_zone:
					return _with_player(act, player_id)  # ‚úÖ
		# Direct attack
		for act in actions.details:
			if act.type == "DECLARE_ATTACK" and not act.payload.has("target_zone"):
				return _with_player(act, player_id)  # ‚úÖ
	# ∆Øu ti√™n 4: Set trap/spell
	for act in actions.details:
		if act.type in ["SET_TRAP", "SET_SPELL"]:
			return _with_player(act, player_id)  # ‚úÖ
	# ∆Øu ti√™n 5: Set monster
	for act in actions.details:
		if act.type == "SET_MONSTER":
			return _with_player(act, player_id)  # ‚úÖ
	# ∆Øu ti√™n 6: END_PHASE ho·∫∑c END_TURN
	if state["phase"] == "end":
		for act in actions.details:
			if act.type == "END_TURN":
				return _with_player(act, player_id)  # ‚úÖ
		return _with_player({"type": "END_TURN", "payload": {}}, player_id)  # ‚úÖ
	for act in actions.details:
		if act.type == "END_PHASE":
			return _with_player(act, player_id)  # ‚úÖ
		if act.type == "END_TURN":
			return _with_player(act, player_id)  # ‚úÖ
	# Fallback
	return _with_player({"type": "END_TURN", "payload": {}}, player_id)  # ‚úÖ

func _with_player(action, player_id):
	var new_action = action.duplicate()
	new_action["player_id"] = player_id
	return new_action

# ===========================================================================
# _print_game_state(state)
# In tr·∫°ng th√°i tr·∫≠n ƒë·∫•u ƒë·ªÉ debug
# ===========================================================================
func _print_game_state(state):
	var player = state["players"][human_player]
	var opponent_id = _get_opponent_id(state)
	var opponent = state["players"][opponent_id]
	
	print("=== Tr·∫°ng th√°i tr·∫≠n ƒë·∫•u ===")
	print("L∆∞·ª£t: %s | Phase: %s | Turn count: %d" % [state["turn"], state["phase"], state["current_turn_count"]])
	print("Ng∆∞·ªùi ch∆°i %s: LP=%d, Hand=%d, Deck=%d" % [human_player, player["life_points"], len(player["hand"]), len(player["deck"])])
	for i in range(5):
		if player["monster_zones"][i]:
			var card = CardDatabase.get(player["monster_zones"][i].card_id)
			print("  Monster zone %d: %s (%s, ATK=%d, DEF=%d)" % [i, card["name"], player["monster_zones"][i].position, card["atk"], card["def"]])
		if player["spell_trap_zones"][i]:
			var card = CardDatabase.get(player["spell_trap_zones"][i].card_id)
			print("  Spell/Trap zone %d: %s (%s)" % [i, card["name"], player["spell_trap_zones"][i].status])
	print("ƒê·ªëi th·ªß %s: LP=%d, Hand=%d, Deck=%d" % [opponent_id, opponent["life_points"], len(opponent["hand"]), len(opponent["deck"])])
	for i in range(5):
		if opponent["monster_zones"][i]:
			var card = CardDatabase.get(opponent["monster_zones"][i].card_id)
			print("  Opponent Monster zone %d: %s (%s, ATK=%d, DEF=%d)" % [i, card["name"], opponent["monster_zones"][i].position, card["atk"], card["def"]])
		if opponent["spell_trap_zones"][i]:
			var card = CardDatabase.get(opponent["spell_trap_zones"][i].card_id)
			print("  Opponent Spell/Trap zone %d: %s (%s)" % [i, card["name"], opponent["spell_trap_zones"][i].status])
	if not state["chain"].empty():
		print("Chain: %s" % state["chain"])
	if state["winner"]:
		print("Ng∆∞·ªùi th·∫Øng: %s | L√Ω do: %s" % [state["winner"], state["win_reason"]])
	print("==========================")


# ===========================================================================
# _get_opponent_id(state)
# L·∫•y ID c·ªßa ƒë·ªëi th·ªß
# ===========================================================================
func _get_opponent_id(state):
	for pid in state["players"]:
		if pid != state["turn"]:
			return pid
	return null




================================================================================

--- FILE: core\TrainBot.gd ---
# ===========================================================================
# train_agent.gd - Hu·∫•n luy·ªán Agent h·ªçc t·ª´ tr·∫≠n ƒë·∫•u Yu-Gi-Oh!
# D√πng Agent.gd (hybrid: Q-Learning + Rule-based response)
# ===========================================================================

extends Node

# S·ªë tr·∫≠n ƒë·ªÉ hu·∫•n luy·ªán
const TRAINING_GAMES = 100

# B·ªô b√†i m·∫´u
var deck = [
	"BLUE_EYES_WHITE_DRAGON",
	"DARK_MAGICIAN",
	"MIRROR_FORCE",
	"GYOUKI",
	"SACK",
	"EFFECT_VEILER",
	"BOOK_OF_MOON",
	"CARD_001",
	"CARD_002",
	"CARD_003"
]

# ===========================================================================
# _ready()
# B·∫Øt ƒë·∫ßu hu·∫•n luy·ªán
# ===========================================================================
func _ready():
	print("üöÄ B·∫Øt ƒë·∫ßu hu·∫•n luy·ªán Agent cho %d tr·∫≠n..." % TRAINING_GAMES)
	
	for i in range(TRAINING_GAMES):
		print("üéÆ Tr·∫≠n #%d" % (i + 1))
		_train_one_game(deck, deck)
	
	# L∆∞u model sau khi h·ªçc xong
	Agent.save_q_table()
	print("üéâ Ho√†n th√†nh hu·∫•n luy·ªán %d tr·∫≠n! Model ƒë√£ ƒë∆∞·ª£c l∆∞u." % TRAINING_GAMES)


# ===========================================================================
# _train_one_game(deck_a, deck_b)
# Ch·∫°y m·ªôt tr·∫≠n ƒë·∫•u gi·ªØa Agent v√† Bot (random)
# ===========================================================================
func _train_one_game(deck_a, deck_b):
	# Kh·ªüi t·∫°o tr·∫≠n ƒë·∫•u
	var room_id = BattleCore.start_duel("agent", "bot", deck_a, deck_b)
	if not room_id:
		print("‚ùå Kh√¥ng th·ªÉ kh·ªüi t·∫°o tr·∫≠n ƒë·∫•u")
		return
	
	var game_over = false
	var current_state = BattleCore.get_game_state(room_id, "agent")
	
	# V√≤ng l·∫∑p tr·∫≠n ƒë·∫•u
	while not game_over:
		var game_data = BattleCore.active_duels[room_id]
		if not game_data:
			break
		
		var current_player = game_data.turn
		
		if current_player == "agent":
			# L∆∞·ª£t c·ªßa Agent
			var available_actions = BattleCore.get_available_actions(room_id, "agent")
			if available_actions.empty():
				game_over = true
				continue
			
			# 1. Agent ch·ªçn h√†nh ƒë·ªông ch√≠nh
			var action_type = Agent.get_action(current_state, "agent", available_actions)
			var action = {
				"player_id": "agent",
				"type": action_type
			}
			
			# 2. ƒêi·ªÅn payload (c√≥ th·ªÉ m·ªü r·ªông sau)
			action.payload = _build_payload(action_type, current_state, "agent")
			
			# 3. G·ª≠i h√†nh ƒë·ªông
			var result = BattleCore.submit_action(room_id, action)
			
			# 4. H·ªçc t·ª´ k·∫øt qu·∫£
			Agent.learn_from_result(current_state, action, result)
			
			# 5. C·∫≠p nh·∫≠t tr·∫°ng th√°i
			var new_state = BattleCore.get_game_state(room_id, "agent")
			current_state = new_state
			
			# 6. X·ª≠ l√Ω s·ª± ki·ªán: c√≥ c·∫ßn ph·∫£n ·ª©ng kh√¥ng?
			var response = Agent.on_event(new_state, result.events, "agent")
			if response:
				var response_result = BattleCore.submit_action(room_id, response)
				# C√≥ th·ªÉ h·ªçc th√™m t·ª´ ph·∫£n ·ª©ng
				Agent.learn_from_result(new_state, response, response_result)
				current_state = BattleCore.get_game_state(room_id, "agent")
			
			# 7. Ki·ªÉm tra k·∫øt th√∫c
			if result.events.find({"type": "WIN"}) or new_state.status == "finished":
				game_over = true
				
		else:
			# L∆∞·ª£t c·ªßa bot ƒë·ªëi th·ªß (random)
			var available = BattleCore.get_available_actions(room_id, "bot")
			if available.empty():
				game_over = true
				continue
			
			var action_type = available[randi() % available.size()]
			var action = {
				"player_id": "bot",
				"type": action_type
			}
			
			# T·∫°o payload ƒë∆°n gi·∫£n
			action.payload = _build_payload(action_type, BattleCore.get_game_state(room_id, "bot"), "bot")
			
			BattleCore.submit_action(room_id, action)
		
		# Ki·ªÉm tra tr·∫°ng th√°i tr·∫≠n
		var duel = BattleCore.active_duels.get(room_id)
		if not duel or duel.status == "finished":
			game_over = true
	
	print("‚úÖ Tr·∫≠n ƒë·∫•u k·∫øt th√∫c.")


# ===========================================================================
# _build_payload(action_type, game_state, player_id)
# T·∫°o payload h·ª£p l·ªá cho h√†nh ƒë·ªông
# (C√≥ th·ªÉ m·ªü r·ªông th√†nh logic ch·ªçn b√†i th√¥ng minh)
# ===========================================================================
func _build_payload(action_type, game_state, player_id):
	var payload = {}
	var player = game_state.players[player_id]
	
	match action_type:
		"PLAY_MONSTER":
			# Ch·ªçn qu√°i ƒë·∫ßu ti√™n tr√™n tay
			for card_id in player.hand:
				if CardDatabase.exists(card_id):
					var card = CardDatabase.get(card_id)
					if card.type == "Monster":
						payload.card_id = card_id
						payload.from_zone = "hand"
						payload.to_zone = _find_empty_zone(player.monster_zones)
						payload.position = "face_up_attack"
						return payload
			return null  # Kh√¥ng c√≥ qu√°i
			
		"SET_MONSTER", "SET_SPELL", "SET_TRAP":
			payload.to_zone = _find_empty_zone(
				player.spell_trap_zones if "SPELL" in action_type or "TRAP" in action_type 
				else player.monster_zones
			)
			# T√¨m b√†i ph√π h·ª£p
			for card_id in player.hand:
				if CardDatabase.exists(card_id):
					var card = CardDatabase.get(card_id)
					if ("SPELL" in action_type and card.type == "Spell") or \
					   ("TRAP" in action_type and card.type == "Trap") or \
					   ("MONSTER" in action_type and card.type == "Monster"):
						payload.card_id = card_id
						return payload
			return null
			
		"PLAY_SPELL", "PLAY_TRAP":
			payload.to_zone = _find_empty_zone(player.spell_trap_zones)
			# T∆∞∆°ng t·ª± nh∆∞ tr√™n
			for card_id in player.hand:
				if CardDatabase.exists(card_id):
					var card = CardDatabase.get(card_id)
					if ("SPELL" in action_type and card.type == "Spell") or \
					   ("TRAP" in action_type and card.type == "Trap"):
						payload.card_id = card_id
						return payload
			return null
			
		"DECLARE_ATTACK":
			# T√¨m qu√°i t·∫•n c√¥ng
			for i in range(5):
				var card = player.monster_zones[i]
				if card and card.position == "face_up_attack" and not card.has("attacked_this_turn"):
					var opp = game_state.players[_get_opponent_id(game_state, player_id)]
					# T√¨m m·ª•c ti√™u
					for j in range(5):
						if opp.monster_zones[j]:
							payload.attacker = card.card_id
							payload.target = opp.monster_zones[j].card_id
							return payload
					# N·∫øu kh√¥ng c√≥ qu√°i ‚Üí t·∫•n c√¥ng tr·ª±c ti·∫øp
					payload.attacker = card.card_id
					payload.target = null
					return payload
			return null
			
		"CHANGE_POSITION":
			for i in range(5):
				var card = player.monster_zones[i]
				if card and card.position == "face_up_attack":
					payload.card_id = card.card_id
					payload.to_position = "defense"
					payload.face = "up"
					return payload
			return null
			
		"ACTIVATE_EFFECT":
			# T√¨m b√†i c√≥ th·ªÉ k√≠ch ho·∫°t
			for zone in player.monster_zones:
				if zone:
					payload.card_id = zone.card_id
					return payload
			for zone in player.spell_trap_zones:
				if zone and zone.status == "face_up":
					payload.card_id = zone.card_id
					return payload
			return null
			
		"END_TURN", "END_PHASE", "DRAW_CARD", "SURRENDER":
			# Kh√¥ng c·∫ßn payload
			pass
	
	return payload


# ===========================================================================
# H√†m h·ªó tr·ª£
# ===========================================================================
func _find_empty_zone(zones):
	for i in range(zones.size()):
		if zones[i] == null:
			return i
	return 0  # M·∫∑c ƒë·ªãnh

func _get_opponent_id(game_state, player_id):
	for pid in game_state.players.keys():
		if pid != player_id:
			return pid
	return null

================================================================================

--- FILE: core\types\GameState.gd ---
# res://types/GameState.gd
class_name GameState

var room_id: String
var turn: String
var phase: String  # "draw", "standby", "main1", "battle", "main2", "end"
var players: Dictionary  # player_id ‚Üí PlayerState
var chain: Array = []    # Danh s√°ch hi·ªáu ·ª©ng ƒëang x·ª≠ l√Ω
var status: String = "active"
================================================================================

--- FILE: core\types\PlayerState.gd ---
# res://types/PlayerState.gd
class_name PlayerState

var life_points: int = 8000
var deck: Array
var hand: Array
var graveyard: Array
var monster_zones: Array  # 5 √¥
var spell_trap_zones: Array  # 5 √¥
var extra_deck: Array
var field_zone  = null
================================================================================

--- FILE: data\cards.json ---
{
  "BLUE_EYES_WHITE_DRAGON": {
    "id": "BLUE_EYES_WHITE_DRAGON",
    "name": "Blue-Eyes White Dragon",
    "type": "monster",
    "atk": 3000,
    "def": 2500,
    "level": 8,
    "attribute": "light",
    "effect": ""
  },
  "DARK_MAGICIAN": {
    "id": "DARK_MAGICIAN",
    "name": "Dark Magician",
    "type": "monster",
    "atk": 2500,
    "def": 2100,
    "level": 7,
    "attribute": "dark",
    "effect": ""
  },
  "SUMMONED_SKULL": {
    "id": "SUMMONED_SKULL",
    "name": "Summoned Skull",
    "type": "monster",
    "atk": 2500,
    "def": 1200,
    "level": 6,
    "attribute": "dark",
    "effect": ""
  },
  "GYOUKI": {
    "id": "GYOUKI",
    "name": "Gyouki",
    "type": "monster",
    "atk": 1500,
    "def": 1000,
    "level": 4,
    "attribute": "dark",
    "effect": ""
  },
  "POT_OF_GREED": {
    "id": "POT_OF_GREED",
    "name": "Pot of Greed",
    "type": "spell",
    "effect": "draw_2"
  },
  "MONSTER_REBORN": {
    "id": "MONSTER_REBORN",
    "name": "Monster Reborn",
    "type": "spell",
    "effect": "special_summon_graveyard"
  },
  "DARK_HOLE": {
    "id": "DARK_HOLE",
    "name": "Dark Hole",
    "type": "spell",
    "effect": "destroy_all_monsters"
  },
  "MIRROR_FORCE": {
    "id": "MIRROR_FORCE",
    "name": "Mirror Force",
    "type": "trap",
    "effect": "destroy_all_attackers"
  },
  "TRAP_HOLE": {
    "id": "TRAP_HOLE",
    "name": "Trap Hole",
    "type": "trap",
    "effect": "destroy_summoned_monster"
  },
  "SUIJIN": {
    "id": "SUIJIN",
    "name": "Suijin",
    "type": "monster",
    "atk": 2500,
    "def": 2400,
    "level": 7,
    "attribute": "water",
    "effect": "reduce_atk_0"
  }
}



================================================================================

