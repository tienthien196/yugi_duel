=== DUMP CODE T·ª™: E:\GODOT\yugi_duel\client_yugi_duel ===
Ch·ªâ dump c√°c file: .afinn, .c, .cfg, .conf, .cpp, .css, .gd, .go, .h, .hpp, .html, .ini, .java, .js, .json, .lark, .py, .rs, .toml, .ts, .yaml, .yml
================================================================================

--- FILE: autoload\Authentication.gd ---
# ===========================================================================
# Authentication.gd - Client-side auth manager (Godot 3.6) + Console Debug
# ===========================================================================
extends Node

var is_authenticated = false
var player_id = ""
var session_token = ""
var is_guest = false

var auto_login_on_request = true
var saved_username = ""

onready var network_client = NetworkManager

signal login_success(player_id, is_guest)
signal login_failed(error_code)
signal logged_out()

func _ready():
	print("[AUTH] Ready. Subscribing to NetworkClient signals")
	network_client.connect("auth_success", self, "_on_auth_success")
	network_client.connect("auth_failed", self, "_on_auth_failed")
	network_client.connect("auth_request", self, "_on_auth_request")

func login(username: String, password := ""):
	username = username.strip_edges()
	if username == "":
		print("[AUTH] ‚ùå login() username empty")
		emit_signal("login_failed", "USERNAME_EMPTY")
		return false
	print("[AUTH] ‚ñ∂Ô∏è Sending login for user='%s'" % username)
	network_client.send_auth_login(username, password)
	return true

func create_guest():
	var guest_name = "guest_%d" % (OS.get_unix_time() % 100000)
	print("[AUTH] ‚ñ∂Ô∏è Creating guest login username='%s'" % guest_name)
	network_client.send_auth_login(guest_name, "")

func _on_auth_request(data):
	print("[AUTH] üîê Server requested authentication. auto_login_on_request=%s saved_username='%s'" % [str(auto_login_on_request), saved_username])
	if not auto_login_on_request:
		return
	if saved_username != "":
		login(saved_username)
	else:
		create_guest()

func _on_auth_success(data: Dictionary):
	var pid = str(data.get("player_id",""))
	var token = str(data.get("token",""))
	print("[AUTH] ‚úÖ AUTH_SUCCESS player_id='%s' token_len=%d" % [pid, token.length()])
	if pid == "" or token == "":
		print("[AUTH] ‚ùå Invalid auth response from server: %s" % str(data))
		emit_signal("login_failed", "INVALID_AUTH_RESPONSE")
		return
	player_id = pid
	session_token = token
	is_authenticated = true
	is_guest = pid.begins_with("guest_")
	emit_signal("login_success", pid, is_guest)

func _on_auth_failed(error_code):
	print("[AUTH] ‚ùå AUTH_FAILED code=%s" % str(error_code))
	_clear_session()
	emit_signal("login_failed", error_code)

func logout():
	if not is_authenticated:
		print("[AUTH] logout() called while not authenticated ‚Üí ignore")
		return
	print("[AUTH] ‚ñ∂Ô∏è Sending LOGOUT for player_id='%s'" % player_id)
	network_client.send_message({
		"type": "LOGOUT",
		"token": session_token
	})
	_clear_session()
	emit_signal("logged_out")
	print("[AUTH] üö™ Logged out")

func _clear_session():
	is_authenticated = false
	player_id = ""
	session_token = ""
	is_guest = false

================================================================================

--- FILE: autoload\BotClient.gd ---
# ===========================================================================
# BotClient.gd - Simple automated client bot (Godot 3.6) + Console Debug
# Usage: Add as an Autoload "BotClient". It will connect & play automatically.
# ===========================================================================
extends Node

export(String) var server_ip := "127.0.0.1"
export(int) var server_port := 8080
export(bool) var auto_create_room_if_empty := true
export(float) var action_delay_sec := 0.5

onready var net := NetworkManager
onready var auth := Authentication
onready var game := GameClientController

var _my_id := ""
var _started := false

func _ready():
	print("[BOT] Starting...")
	net.connect("server_disconnected", self, "_on_disconnected")
	auth.connect("login_success", self, "_on_login_success")
	auth.connect("login_failed", self, "_on_login_failed")
	game.connect("room_list_received", self, "_on_room_list_received")
	game.connect("joined_room", self, "_on_joined_room")
	game.connect("game_started", self, "_on_game_started")
	game.connect("game_state_updated", self, "_on_game_state_updated")
	if net.connect_to_server(server_ip, server_port):
		print("[BOT] Connected to server, waiting for AUTH_REQUEST...")

func _on_disconnected():
	print("[BOT] Disconnected from server")

func _on_login_success(pid, is_guest):
	_my_id = pid
	print("[BOT] Logged in as %s (guest=%s)" % [pid, str(is_guest)])
	game.request_room_list()

func _on_login_failed(code):
	print("[BOT] Login failed: %s" % str(code))

func _on_room_list_received(rooms):
	print("[BOT] Room list received: %s" % str(rooms))
	if rooms.size() == 0 and auto_create_room_if_empty:
		print("[BOT] No rooms ‚Üí creating one")
		game.create_room()
	else:
		# Try join the first room
		for r in rooms:
			if r.has("room_id"):
				print("[BOT] Joining room %s" % r["room_id"])
				game.join_room(r["room_id"])
				return
		print("[BOT] No joinable rooms ‚Üí creating one")
		game.create_room()

func _on_joined_room(room_id):
	print("[BOT] Joined room %s, waiting start..." % room_id)

func _on_game_started(room_id):
	print("[BOT] Game started in %s" % room_id)
	_started = true

func _on_game_state_updated(state):
	if not _started:
		return
	# Extremely simple strategy: if it's my turn -> end turn after a short delay
	if typeof(state) == TYPE_DICTIONARY and state.get("turn","") == _my_id:
		print("[BOT] My turn -> END_TURN (after delay %.2fs)" % action_delay_sec)
		yield(get_tree().create_timer(action_delay_sec), "timeout")
		game.end_turn()

================================================================================

--- FILE: autoload\GameClientController.gd ---
# ===========================================================================
# GameClientController.gd - Client duel flow (Godot 3.6) + Console Debug
# ===========================================================================
extends Node

var current_room_id = ""
var current_player_id = ""
var current_game_state = null

onready var network_client = NetworkManager
onready var authentication = Authentication

signal game_state_updated(state)
signal game_event_received(events)
signal player_turn_changed(next_player)
signal phase_changed(new_phase)
signal game_over(winner, reason)
signal joined_room(room_id)
signal error_received(code, message)
signal game_started(room_id)
signal room_list_received(rooms)

func _ready():
	print("[GAME] Ready and wiring signals")
	authentication.connect("login_success", self, "_on_login_success")
	authentication.connect("logged_out", self, "_on_logged_out")

	network_client.connect("game_state_received", self, "_on_game_state_received")
	network_client.connect("game_event_received", self, "_on_game_event_received")
	network_client.connect("room_created", self, "_on_room_created")
	network_client.connect("error_received", self, "_on_error_received")
	network_client.connect("room_list_received", self, "_on_room_list_received")
	network_client.connect("game_started", self, "_on_game_started")

func _on_login_success(pid, _is_guest):
	current_player_id = pid
	print("[GAME] Logged in as '%s'" % pid)

func _on_logged_out():
	print("[GAME] Logged out ‚Üí clearing local state")
	current_player_id = ""
	current_room_id = ""
	current_game_state = null

# ---------------- Outgoing ----------------
func request_room_list():
	print("[GAME] ‚ñ∂Ô∏è Requesting room list")
	network_client.send_list_rooms()

func create_room(mode := "pvp_1v1"):
	if mode == "":
		mode = "pvp_1v1"
	print("[GAME] ‚ñ∂Ô∏è Creating room mode=%s" % mode)
	network_client.send_create_room(mode)

func join_room(room_id: String):
	var token = authentication.session_token
	print("[GAME] ‚ñ∂Ô∏è Joining room '%s'" % room_id)
	network_client.send_message({
		"type": "JOIN_ROOM",
		"room_id": room_id,
		"token": token
	})

func get_game_state(room_id: String):
	var token = authentication.session_token
	print("[GAME] ‚ñ∂Ô∏è Requesting state for room '%s'" % room_id)
	network_client.send_message({
		"type": "GET_STATE",
		"room_id": room_id,
		"token": token
	})

# Unified submit_action API
func submit_action(action_type: String, payload: Dictionary):
	if current_room_id == "" or not authentication.is_authenticated:
		print("[GAME] ‚ùå submit_action refused (room empty or not authenticated). action=%s" % action_type)
		return false
	var token = authentication.session_token
	var action = payload.duplicate()
	action["type"] = action_type
	print("[GAME] ‚ñ∂Ô∏è SUBMIT_ACTION type=%s payload=%s" % [action_type, str(payload)])
	network_client.send_message({
		"type": "SUBMIT_ACTION",
		"room_id": current_room_id,
		"token": token,
		"action": action
	})
	return true

# Convenience wrappers
func play_monster(card_id: String, to_zone := -1, position := "attack"):
	return submit_action("PLAY_MONSTER", {
		"card_id": card_id,
		"to_zone": to_zone,
		"position": position
	})

func set_spell_trap(card_id: String, to_zone := -1):
	return submit_action("SET_SPELL_TRAP", {
		"card_id": card_id,
		"to_zone": to_zone
	})

func activate_effect(card_id: String, zone_type := "spell_trap"):
	return submit_action("ACTIVATE_EFFECT", {
		"card_id": card_id,
		"zone_type": zone_type
	})

func declare_attack(attacker_zone: int, target_zone := -1):
	return submit_action("DECLARE_ATTACK", {
		"atk_zone": attacker_zone,
		"target_zone": target_zone
	})

func change_position(zone: int, to_position: String):
	return submit_action("CHANGE_POSITION", {
		"zone": zone,
		"to_position": to_position
	})

func end_phase():
	return submit_action("END_PHASE", {})

func end_turn():
	return submit_action("END_TURN", {})

func surrender():
	return submit_action("SURRENDER", {})

# ---------------- Incoming ----------------
func _on_room_created(room_id):
	current_room_id = room_id
	print("[GAME] üÜï Room created: %s" % room_id)
	emit_signal("joined_room", room_id)

func _on_room_list_received(rooms):
	print("[GAME] üìã Room list received (%d): %s" % [rooms.size(), str(rooms)])
	emit_signal("room_list_received", rooms)

func _on_game_started(room_id):
	current_room_id = room_id
	print("[GAME] üéÆ Game started in room: %s" % room_id)
	emit_signal("game_started", room_id)

func _on_game_state_received(state: Dictionary):
	current_game_state = state
	if state.has("turn"):
		emit_signal("player_turn_changed", state["turn"])
	if state.has("phase"):
		emit_signal("phase_changed", state["phase"])
	if state.get("status","") == "finished":
		emit_signal("game_over", state.get("winner",""), state.get("reason",""))
	print("[GAME] üîÑ State update: turn=%s phase=%s status=%s" % [str(state.get("turn","?")), str(state.get("phase","?")), str(state.get("status","active"))])
	emit_signal("game_state_updated", state)

func _on_game_event_received(events):
	print("[GAME] üì£ Events: %s" % str(events))
	emit_signal("game_event_received", events)

func _on_error_received(code, message):
	print("[GAME] ‚ùå Error from server: %s | %s" % [str(code), str(message)])
	emit_signal("error_received", code, message)

func get_current_player_id():
	return current_player_id

================================================================================

--- FILE: autoload\NetworkClient.gd ---
# ===========================================================================
# NetworkClient.gd - Client ENet for Godot 3.6 + Console Debug
# - Sends/receives plain dictionaries via RPC "receive_message"
# - Unified protocol with server
# ===========================================================================
extends Node

var server_ip   = "127.0.0.1"
var server_port = 8080

var peer = null
var connected = false

# Signals
signal connected_to_server
signal connection_failed
signal server_disconnected

signal auth_request(data)
signal auth_success(data)            # { "player_id": "", "token": "" }
signal auth_failed(error_code)

signal game_started(room_id)
signal game_state_received(state)
signal game_event_received(events)
signal action_result_received(result)

signal room_list_received(rooms)
signal room_list_update(rooms)
signal room_created(room_id)

signal error_received(code, message)

func _ready():
	print("[NET] NetworkClient ready")

func connect_to_server(ip := "", port := 0):
	if connected:
		print("[NET] Already connected to %s:%d" % [server_ip, server_port])
		return true
	if ip != "":
		server_ip = ip
	if port != 0:
		server_port = port
	peer = NetworkedMultiplayerENet.new()
	var err = peer.create_client(server_ip, server_port)
	if err != OK:
		print("[NET] ‚ùå create_client failed err=%d to %s:%d" % [err, server_ip, server_port])
		emit_signal("connection_failed")
		return false
	get_tree().network_peer = peer
	connected = true
	print("[NET] üåê Connecting to %s:%d ..." % [server_ip, server_port])
	get_tree().connect("connection_failed", self, "_on_connection_failed")
	get_tree().connect("server_disconnected", self, "_on_server_disconnected")
	return true

func _on_connection_failed():
	print("[NET] ‚ùå Connection failed")
	emit_signal("connection_failed")

func _on_server_disconnected():
	print("[NET] üîå Disconnected from server")
	connected = false
	emit_signal("server_disconnected")

# ---------------- Sending ----------------
func send_message(msg: Dictionary):
	if not connected or not get_tree().network_peer:
		push_error("Not connected")
		print("[NET] ‚ùå send_message while not connected: %s" % str(msg))
		return
	print("[NET] üì§ -> %s" % str(msg))
	rpc_id(1, "receive_message", msg) # server peer_id is 1

func send_auth_login(username: String, password: String):
	send_message({
		"type": "AUTH_LOGIN",
		"username": username,
		"password": password
	})

func send_create_room(mode := "pvp_1v1"):
	send_message({ "type": "CREATE_ROOM", "mode": mode })

func send_list_rooms():
	send_message({ "type": "LIST_ROOMS" })

# ---------------- Receiving (from server) ----------------
remote func receive_message(message):
	if typeof(message) != TYPE_DICTIONARY:
		print("[NET] ‚ö†Ô∏è Received non-dictionary message: %s" % str(message))
		return
	print("[NET] üì• <- %s" % str(message))
	var t = str(message.get("type",""))
	match t:
		"AUTH_REQUEST":
			emit_signal("auth_request", message)
		"AUTH_SUCCESS":
			emit_signal("auth_success", { "player_id": message.get("player_id",""), "token": message.get("token","") })
		"AUTH_ERROR":
			emit_signal("auth_failed", message.get("code","ERROR"))
		"ROOM_LIST":
			emit_signal("room_list_received", message.get("rooms", []))
		"ROOM_LIST_UPDATE":
			emit_signal("room_list_update", message.get("rooms", []))
		"ROOM_CREATED":
			emit_signal("room_created", message.get("room_id",""))
		"GAME_STARTED":
			emit_signal("game_started", message.get("room_id",""))
		"GAME_STATE":
			emit_signal("game_state_received", message.get("state", {}))
		"GAME_EVENT":
			emit_signal("game_event_received", message.get("events", []))
		"ACTION_RESULT":
			emit_signal("action_result_received", message.get("result", {}))
		"ERROR":
			emit_signal("error_received", message.get("code",""), message.get("message",""))
		_:
			print("[NET] üü° Unhandled message: %s" % str(message))

func _disconnect():
	if connected:
		print("[NET] Closing connection")
		get_tree().network_peer = null
		connected = false

================================================================================

--- FILE: core\BotTestClient.gd ---
# ===========================================================================
# BotTestClient.gd - Client test t·ª± ƒë·ªông (phi√™n b·∫£n ƒë·ªôc l·∫≠p)
# ‚úÖ ƒê√£ s·ª≠a: ch·ªâ g·ª≠i login khi server y√™u c·∫ßu, tr√°nh m·∫•t g√≥i
# ===========================================================================
extends Node

const SERVER_IP = "127.0.0.1"
const SERVER_PORT = 8080
var TEST_USERNAME = "bot_%d" % (randi() % 1000)  # ‚Üí bot_123 (5-7 k√Ω t·ª±)

var room_id = ""
var player_id = ""
var has_sent_login = false

export var is_host = true

onready var network_client = NetworkManager
onready var authentication = Authentication
onready var game_controller = GameClientController


func _ready():
	authentication.auto_login_on_request = false

	network_client.connect("connected_to_server", self, "_on_connected_to_server")
	network_client.connect("auth_request", self, "_on_auth_request")  # ‚Üê B·∫ÆT BU·ªòC
	network_client.connect("room_list_update", self, "_on_room_list_update")
	authentication.connect("login_success", self, "_on_login_success")
	authentication.connect("login_failed", self, "_on_login_failed")
	game_controller.connect("joined_room", self, "_on_joined_room")
	game_controller.connect("game_state_updated", self, "_on_game_state_updated")
	game_controller.connect("game_event_received", self, "_on_game_event_received")
	game_controller.connect("error_received", self, "_on_error_received")
	game_controller.connect("game_started", self, "_on_game_started")

	_connect_to_server()


func _connect_to_server():
	if network_client.connect_to_server(SERVER_IP, SERVER_PORT):
		print("‚úÖ [BOT] ƒê√£ g·ª≠i y√™u c·∫ßu k·∫øt n·ªëi ƒë·∫øn %s:%d" % [SERVER_IP, SERVER_PORT])
	else:
		print("üî¥ [BOT] K·∫øt n·ªëi th·∫•t b·∫°i!")
		_finish_test(false)


func _on_connected_to_server():
	print("üü¢ [BOT] K·∫øt n·ªëi th√†nh c√¥ng. ƒêang ch·ªù server y√™u c·∫ßu x√°c th·ª±c...")


func _on_auth_request(data):
	if has_sent_login:
		return
	print("üîê [BOT] Server y√™u c·∫ßu x√°c th·ª±c ‚Üí g·ª≠i ƒëƒÉng nh·∫≠p...")
	if authentication.login(TEST_USERNAME):
		has_sent_login = true
		print("üì§ [BOT] ƒê√£ g·ª≠i ƒëƒÉng nh·∫≠p: %s" % TEST_USERNAME)
	else:
		print("‚ùå [BOT] G·ª≠i ƒëƒÉng nh·∫≠p th·∫•t b·∫°i!")
		_finish_test(false)


func _on_login_success(pid, is_guest):
	self.player_id = pid
	print("üü¢ [BOT] ‚úÖ X√°c th·ª±c th√†nh c√¥ng: %s (guest=%s)" % [pid, is_guest])

	if is_host:
		print("üéÆ [BOT] T·∫°o ph√≤ng m·ªõi...")
		game_controller.create_room("pvp_1v1")
	else:
		print("üîç [BOT] Y√™u c·∫ßu danh s√°ch ph√≤ng...")
		game_controller.request_room_list()


func _on_login_failed(error_code):
	match error_code:
		"INVALID_USERNAME":
			print("‚ùå T√™n qu√° d√†i ho·∫∑c qu√° ng·∫Øn!")
		"USERNAME_EMPTY":
			print("‚ùå T√™n tr·ªëng!")
		"AUTH_REQUIRED":
			print("‚ùå C·∫ßn ƒëƒÉng nh·∫≠p!")
		_:
			print("‚ùå L·ªói: %s" % error_code)
	_finish_test(false)


func _on_joined_room(rid):
	room_id = rid
	print("‚úÖ [BOT] ƒê√£ v√†o ph√≤ng: %s" % room_id)


func _on_room_list_update(rooms):
	if is_host:
		return
	for room in rooms:
		if room.status == "waiting" and room.player_count == 1:
			print("üëâ [BOT] V√†o ph√≤ng: %s" % room.room_id)
			game_controller.join_room(room.room_id)
			return


func _on_game_started(rid):
	print("üéÆ [BOT] ‚öîÔ∏è Tr·∫≠n ƒë·∫•u b·∫Øt ƒë·∫ßu: %s" % rid)


func _on_game_state_updated(state):
	print("üîÑ [BOT] Nh·∫≠n tr·∫°ng th√°i: L∆∞·ª£t=%s, Phase=%s" % [state.turn, state.phase])
	_send_test_actions(state)


func _send_test_actions(state):
	var my_id = game_controller.get_current_player_id()
	if state.turn != my_id:
		return
	if state.phase in ["main1", "main2"]:
		var hand = state.players[my_id].hand
		var zones = state.players[my_id].field.monster_zones
		for i in range(zones.size()):
			if zones[i] == null and hand.size() > 0:
				game_controller.play_monster(hand[0], i)
				return
		game_controller.end_turn()


func _on_game_event_received(events):
	for event in events:
		if event.type == "WIN":
			print("üèÜ [BOT] Tr·∫≠n k·∫øt th√∫c! Ng∆∞·ªùi th·∫Øng: %s" % event.winner)
			_finish_test(event.winner == player_id)


func _on_error_received(code, message):
	print("‚ùå [BOT] L·ªói: %s | %s" % [code, message])
	_finish_test(false)


func _finish_test(success):
	var status = "‚úÖ [BOT] TEST TH√ÄNH C√îNG!" if success else "‚ùå [BOT] TEST TH·∫§T B·∫†I!"
	print("==================================")
	print(status)
	print("==================================")
	network_client._disconnect()
	queue_free()

================================================================================

