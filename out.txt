=== DUMP CODE T·ª™: E:\GODOT\yugi_duel ===
Ch·ªâ dump c√°c file: .afinn, .c, .cfg, .conf, .cpp, .css, .gd, .go, .h, .hpp, .html, .ini, .java, .js, .json, .lark, .py, .rs, .toml, .ts, .yaml, .yml
================================================================================

--- FILE: main.py ---
# dump_code.py
import os

# C·∫•u h√¨nh
# ROOT_DIR = r"E:\GODOT\yugi_duel\client_yugi_duel"
ROOT_DIR = r"E:\GODOT\yugi_duel"

OUTPUT_FILE = r"E:\GODOT\yugi_duel\out.txt"

# C√°c ƒëu√¥i file c·∫ßn dump (c√≥ th·ªÉ m·ªü r·ªông)
EXTENSIONS = {
    '.py', '.lark', '.afinn', 
    '.json', '.yaml', '.yml', '.toml',
    '.ini', '.cfg', '.conf',
    '.html', '.css', '.js', '.ts',
    '.c', '.cpp', '.h', '.hpp', '.go', '.java', '.rs', '.gd'
}

# C√°c th∆∞ m·ª•c n√™n b·ªè qua
SKIP_DIRS = {
    '__pycache__', '.git', 'node_modules', '.vscode', '.idea', 'venv', 'env', 'v3.1', 'tool'
}

def should_include_file(filepath):
    """Ki·ªÉm tra file c√≥ n√™n ƒë∆∞·ª£c dump kh√¥ng"""
    _, ext = os.path.splitext(filepath)
    return ext.lower() in EXTENSIONS

def is_binary(filepath):
    """Ki·ªÉm tra file c√≥ ph·∫£i binary kh√¥ng"""
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            f.read(1024)
        return False
    except UnicodeDecodeError:
        return True
    except Exception:
        return True  # n·∫øu l·ªói, b·ªè qua

def dump_code():
    with open(OUTPUT_FILE, 'w', encoding='utf-8') as out:
        out.write(f"=== DUMP CODE T·ª™: {ROOT_DIR} ===\n")
        out.write(f"Ch·ªâ dump c√°c file: {', '.join(sorted(EXTENSIONS))}\n")
        out.write("=" * 80 + "\n\n")

        for root, dirs, files in os.walk(ROOT_DIR):
            # L·ªçc c√°c th∆∞ m·ª•c c·∫ßn b·ªè qua
            dirs[:] = [d for d in dirs if d not in SKIP_DIRS]

            for file in files:
                filepath = os.path.join(root, file)
                relpath = os.path.relpath(filepath, ROOT_DIR)

                if should_include_file(filepath):
                    if is_binary(filepath):
                        print(f"[SKIP] Binary file: {relpath}")
                        continue

                    try:
                        with open(filepath, 'r', encoding='utf-8') as f:
                            content = f.read()
                        out.write(f"--- FILE: {relpath} ---\n")
                        out.write(content)
                        out.write("\n" + "="*80 + "\n\n")
                        print(f"[OK] Dumped: {relpath}")
                    except Exception as e:
                        print(f"[ERROR] ƒê·ªçc file {relpath} th·∫•t b·∫°i: {e}")
                        out.write(f"[ERROR] Kh√¥ng th·ªÉ ƒë·ªçc file: {relpath}\n\n")

    print(f"\n‚úÖ ƒê√£ xu·∫•t to√†n b·ªô code v√†o: {OUTPUT_FILE}")

if __name__ == "__main__":
    dump_code()
================================================================================

--- FILE: client_yugi_duel\autoload\Authentication.gd ---
# ===========================================================================
# Authentication.gd - Qu·∫£n l√Ω ƒëƒÉng nh·∫≠p & tr·∫°ng th√°i ng∆∞·ªùi ch∆°i (Client)
# Autoload Singleton
# Ch·ª©c nƒÉng:
#   - ƒêƒÉng nh·∫≠p, t·∫°o t√†i kho·∫£n, ch∆°i t·∫°m (guest)
#   - T∆∞∆°ng t√°c v·ªõi NetworkClient
#   - L∆∞u th√¥ng tin ng∆∞·ªùi ch∆°i
#   - T∆∞∆°ng th√≠ch v·ªõi BotTestClient v√† server AuthManager
# ===========================================================================
extends Node

# --- Tr·∫°ng th√°i x√°c th·ª±c ---
var is_authenticated = false
var player_id = ""
var session_token = ""
var is_guest = false

# --- C·∫•u h√¨nh ---
# T·∫Øt ƒë·ªÉ Bot ho·∫∑c UI t·ª± ki·ªÉm so√°t vi·ªác g·ª≠i login
var auto_login_on_request = true

# T√™n ng∆∞·ªùi ch∆°i ƒë√£ l∆∞u (t√πy ch·ªçn)
var saved_username = ""

# --- Tham chi·∫øu ---
onready var network_client = NetworkManager

# --- Signal ---
signal login_success(player_id, is_guest)  # G·ª≠i khi x√°c th·ª±c th√†nh c√¥ng
signal login_failed(error_code)           # G·ª≠i khi th·∫•t b·∫°i
signal logged_out()                       # G·ª≠i khi ƒëƒÉng xu·∫•t


# ===========================================================================
# _ready()
# K·∫øt n·ªëi v·ªõi NetworkClient ƒë·ªÉ l·∫Øng nghe ph·∫£n h·ªìi t·ª´ server
# ===========================================================================
func _ready():
	# L·∫Øng nghe k·∫øt qu·∫£ t·ª´ NetworkClient
	network_client.connect("auth_success", self, "_on_auth_success")
	network_client.connect("auth_failed", self, "_on_auth_failed")
	network_client.connect("auth_request", self, "_on_auth_request")

	# (T√πy ch·ªçn) Kh·ªüi t·∫°o random seed n·∫øu d√πng randi()
	randomize()


# ===========================================================================
# login(username, password = "")
# ƒêƒÉng nh·∫≠p ng∆∞·ªùi ch∆°i
# N·∫øu kh√¥ng c√≥ password ‚Üí coi nh∆∞ guest
# ===========================================================================
func login(username, password = ""):
	username = username.strip_edges()
	if username == "":
		emit_signal("login_failed", "USERNAME_EMPTY")
		return false

	# G·ª≠i y√™u c·∫ßu ƒëƒÉng nh·∫≠p ƒë·∫øn server
	network_client.send_auth_login(username, password)
	print("üì§ [AUTH] G·ª≠i y√™u c·∫ßu ƒëƒÉng nh·∫≠p: %s" % username)
	return true


# ===========================================================================
# create_guest()
# T·∫°o ng∆∞·ªùi ch∆°i t·∫°m (guest) v·ªõi t√™n duy nh·∫•t
# ===========================================================================
func create_guest():
	var guest_name = "guest_%d_%d" % [OS.get_unix_time(), randi() % 10000]
	return login(guest_name)  # Kh√¥ng c·∫ßn password


# ===========================================================================
# set_saved_username(username)
# L∆∞u t√™n ng∆∞·ªùi ch∆°i ƒë·ªÉ d√πng l·∫°i l·∫ßn sau
# ===========================================================================
func set_saved_username(username):
	saved_username = username.strip_edges()


# ===========================================================================
# _on_auth_request(data)
# Server y√™u c·∫ßu x√°c th·ª±c ‚Üí t·ª± ƒë·ªông ƒëƒÉng nh·∫≠p (n·∫øu b·∫≠t auto_login)
# ===========================================================================
func _on_auth_request(data):
	print("üîê [AUTH] Server y√™u c·∫ßu x√°c th·ª±c: %s" % data.get("message", "Vui l√≤ng g·ª≠i AUTH_LOGIN ƒë·ªÉ x√°c th·ª±c."))

	# N·∫øu t·∫Øt t·ª± ƒë·ªông ‚Üí kh√¥ng l√†m g√¨
	if not auto_login_on_request:
		return

	# ∆Øu ti√™n d√πng t√™n ƒë√£ l∆∞u
	if saved_username != "":
		login(saved_username)
	else:
		create_guest()


# ===========================================================================
# _on_auth_success(data)
# Nh·∫≠n k·∫øt qu·∫£ x√°c th·ª±c th√†nh c√¥ng t·ª´ NetworkClient
# D·ªØ li·ªáu: { "player_id": "...", "token": "..." }
# ===========================================================================
func _on_auth_success(data):
	var pid = data.get("player_id", "")
	var token = data.get("token", "")
	
	if pid == "" or token == "":
		var reason = "INVALID_PLAYER_ID" if pid == "" else "MISSING_TOKEN"
		emit_signal("login_failed", reason)
		return

	self.player_id = pid
	self.session_token = token
	self.is_authenticated = true
	self.is_guest = pid.begins_with("guest_")

	print("‚úÖ X√°c th·ª±c th√†nh c√¥ng: %s (guest=%s)" % [pid, str(is_guest)])
	emit_signal("login_success", pid, is_guest)


# ===========================================================================
# _on_auth_failed(error_code)
# X·ª≠ l√Ω x√°c th·ª±c th·∫•t b·∫°i
# ===========================================================================
func _on_auth_failed(error_code):
	print("‚ùå [AUTH] X√°c th·ª±c th·∫•t b·∫°i: %s" % error_code)
	match error_code:
		"INVALID_USERNAME":
			print("üìù [AUTH] T√™n ng∆∞·ªùi d√πng ph·∫£i t·ª´ 3-20 k√Ω t·ª±")
		"USERNAME_EMPTY":
			print("üìù [AUTH] T√™n ng∆∞·ªùi d√πng kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng")
		"INVALID_PLAYER_ID":
			print("üìù [AUTH] Server tr·∫£ v·ªÅ player_id kh√¥ng h·ª£p l·ªá")
	_clear_session()
	emit_signal("login_failed", error_code)

# ===========================================================================
# logout()
# ƒêƒÉng xu·∫•t kh·ªèi server
# ===========================================================================
func logout():
	if not is_authenticated:
		return

	# G·ª≠i y√™u c·∫ßu ƒëƒÉng xu·∫•t
	network_client.send_message({
		"type": "LOGOUT",
		"token": session_token
	})

	_clear_session()
	emit_signal("logged_out")
	print("üëã [AUTH] ƒê√£ ƒëƒÉng xu·∫•t: %s" % player_id)


# ===========================================================================
# _clear_session()
# D·ªçn d·∫πp th√¥ng tin ƒëƒÉng nh·∫≠p
# ===========================================================================
func _clear_session():
	is_authenticated = false
	player_id = ""
	session_token = ""
	is_guest = false


# ===========================================================================
# Getter
# ===========================================================================
func get_player_id():
	return player_id

func is_logged_in():
	return is_authenticated

func is_current_guest():
	return is_guest

func get_session_token():
	return session_token

================================================================================

--- FILE: client_yugi_duel\autoload\GameClientController.gd ---
# ===========================================================================
# GameClientController.gd - ƒêi·ªÅu khi·ªÉn v√≤ng ƒë·ªùi tr·∫≠n ƒë·∫•u (Client)
# Autoload Singleton
# Ch·ª©c nƒÉng:
#   - Nh·∫≠n tr·∫°ng th√°i tr·∫≠n t·ª´ server
#   - G·ª≠i h√†nh ƒë·ªông c·ªßa ng∆∞·ªùi ch∆°i
#   - Qu·∫£n l√Ω flow: v√†o ph√≤ng, b·∫Øt ƒë·∫ßu, k·∫øt th√∫c
#   - Ph√°t t√≠n hi·ªáu cho UI c·∫≠p nh·∫≠t
# ===========================================================================
extends Node

# Tr·∫°ng th√°i hi·ªán t·∫°i
var current_room_id = ""
var current_player_id = ""
var current_game_state = null

# Tham chi·∫øu
onready var network_client = NetworkManager
onready var authentication = Authentication

# Signal cho UI
signal game_state_updated(state)        # G·ª≠i to√†n b·ªô tr·∫°ng th√°i
signal game_event_received(events)      # G·ª≠i c√°c s·ª± ki·ªán (hi·ªáu ·ª©ng, t·∫•n c√¥ng)
signal player_turn_changed(next_player) # L∆∞·ª£t ƒë·ªïi
signal phase_changed(new_phase)         # Phase ƒë·ªïi
signal game_over(winner, reason)        # Tr·∫≠n k·∫øt th√∫c
signal joined_room(room_id)             # ƒê√£ v√†o ph√≤ng
signal error_received(code, message)    # L·ªói t·ª´ server
signal game_started(room_id)            # ‚úÖ Th√™m: khi tr·∫≠n ƒë·∫•u b·∫Øt ƒë·∫ßu
signal room_list_received(rooms)        # ‚úÖ Th√™m: khi nh·∫≠n danh s√°ch ph√≤ng

# ===========================================================================
# _ready()
# K·∫øt n·ªëi v·ªõi c√°c Autoload ƒë·ªÉ l·∫Øng nghe s·ª± ki·ªán
# ===========================================================================
func _ready():
	# L·∫Øng nghe t·ª´ Authentication
	authentication.connect("login_success", self, "_on_login_success")
	authentication.connect("logged_out", self, "_on_logged_out")

	# L·∫Øng nghe t·ª´ NetworkClient
	network_client.connect("game_state_received", self, "_on_game_state_received")
	network_client.connect("game_event_received", self, "_on_game_event_received")
	network_client.connect("room_created", self, "_on_room_created")
	network_client.connect("error_received", self, "_on_error_received")
	network_client.connect("room_list_received", self, "_on_room_list_received")  # ‚úÖ Th√™m
	network_client.connect("game_started", self, "_on_game_started")              # ‚úÖ Th√™m

	# N·∫øu ƒë√£ ƒëƒÉng nh·∫≠p r·ªìi (v√≠ d·ª•: reload scene)
	if authentication.is_logged_in():
		_on_login_success(authentication.get_player_id(), authentication.is_current_guest())

# ===========================================================================
# _on_login_success(player_id, is_guest)
# Khi ƒëƒÉng nh·∫≠p th√†nh c√¥ng ‚Üí c√≥ th·ªÉ ch∆°i
# ===========================================================================
func _on_login_success(player_id, is_guest):
	current_player_id = player_id
	print("üéÆ GameClientController: Ng∆∞·ªùi ch∆°i ƒë√£ s·∫µn s√†ng: %s" % player_id)

	# ‚úÖ Ki·ªÉm tra xem c√≥ th·ªÉ l·∫•y l·∫°i tr·∫°ng th√°i kh√¥ng?
	# C√≥ th·ªÉ l∆∞u room_id t·∫°m trong ProjectSettings ho·∫∑c UserConfig
	var last_room = ProjectSettings.get_setting("last_room_id")
	if last_room != "":
		current_room_id = last_room
		network_client.send_get_state(last_room)  # Y√™u c·∫ßu tr·∫°ng th√°i

func _on_logged_out():
	current_player_id = ""
	current_room_id = ""
	current_game_state = null
	print("üëã GameClientController: Ng∆∞·ªùi ch∆°i ƒë√£ ƒëƒÉng xu·∫•t")

# ===========================================================================
# _on_game_state_received(state)
# Nh·∫≠n tr·∫°ng th√°i tr·∫≠n ƒë·∫•u t·ª´ server
# ===========================================================================
func _on_game_state_received(state):
	if not state.has("room_id"):
		print("‚ö†Ô∏è GameClientController: State kh√¥ng c√≥ room_id")
		return

	current_game_state = state.duplicate(true)
	current_room_id = state.room_id

	# Ph√°t t√≠n hi·ªáu cho UI
	emit_signal("game_state_updated", current_game_state)

	# Ph√°t t√≠n hi·ªáu n·∫øu c√≥ thay ƒë·ªïi l∆∞·ª£t/phase
	if current_game_state.turn != current_player_id:
		emit_signal("player_turn_changed", current_game_state.turn)
	if current_game_state.status == "finished":
		emit_signal("game_over", current_game_state.winner, current_game_state.win_reason)

# ===========================================================================
# _on_game_event_received(events)
# Nh·∫≠n danh s√°ch s·ª± ki·ªán t·ª´ server
# ===========================================================================
func _on_game_event_received(events):
	if not events or events.empty():
		return

	emit_signal("game_event_received", events)

	for event in events:
		match event.get("type", ""):
			"TURN_CHANGED":
				emit_signal("player_turn_changed", event.get("next_player", ""))
			"PHASE_CHANGED":
				emit_signal("phase_changed", event.get("new_phase", ""))
			"WIN":
				emit_signal("game_over", event.get("winner", ""), event.get("reason", ""))

# ===========================================================================
# _on_room_created(room_id)
# Khi t·∫°o ph√≤ng th√†nh c√¥ng
# ===========================================================================
func _on_room_created(room_id):
	if room_id == "":
		return
	current_room_id = room_id
	emit_signal("joined_room", room_id)
	print("‚úÖ GameClientController: ƒê√£ t·∫°o ph√≤ng %s" % room_id)

# ===========================================================================
# _on_game_started(room_id)
# Khi server th√¥ng b√°o tr·∫≠n ƒë·∫•u b·∫Øt ƒë·∫ßu
# ===========================================================================
func _on_game_started(room_id):
	if room_id == "":
		return
	current_room_id = room_id
	emit_signal("game_started", room_id)
	print("üéÆ GameClientController: Tr·∫≠n ƒë·∫•u b·∫Øt ƒë·∫ßu - room_id: %s" % room_id)

# ===========================================================================
# _on_room_list_received(rooms)
# Khi nh·∫≠n danh s√°ch ph√≤ng t·ª´ server
# ===========================================================================
func _on_room_list_received(rooms):
	emit_signal("room_list_received", rooms)
	print("üìã GameClientController: Nh·∫≠n danh s√°ch ph√≤ng - %d ph√≤ng" % rooms.size())

# ===========================================================================
# _on_error_received(code, message)
# Nh·∫≠n l·ªói t·ª´ server
# ===========================================================================
func _on_error_received(code, message):
	emit_signal("error_received", code, message)
	print("‚ùå GameClientController: L·ªói t·ª´ server: %s | %s" % [code, message])

# ===========================================================================
# G·ª≠i h√†nh ƒë·ªông c·ªßa ng∆∞·ªùi ch∆°i l√™n server
# ===========================================================================
func submit_action(room_id, action):
	var token = authentication.session_token
	network_client.send_message({
		"type": "SUBMIT_ACTION",
		"room_id": room_id,
		"action": action,
		"token": token
	})

# ===========================================================================
# C√°c h√†m ti·ªán √≠ch g·ª≠i h√†nh ƒë·ªông
# ===========================================================================
func play_monster(card_id, to_zone, position = "face_up_attack"):
	return submit_action("PLAY_MONSTER", {
		"card_id": card_id,
		"to_zone": to_zone,
		"position": position
	})

func set_monster(card_id, to_zone):
	return submit_action("SET_MONSTER", {
		"card_id": card_id,
		"to_zone": to_zone
	})

func play_spell(card_id, to_zone):
	return submit_action("PLAY_SPELL", {
		"card_id": card_id,
		"to_zone": to_zone
	})

func set_spell(card_id, to_zone):
	return submit_action("SET_SPELL", {
		"card_id": card_id,
		"to_zone": to_zone
	})

func play_trap(card_id, to_zone):
	return submit_action("PLAY_TRAP", {
		"card_id": card_id,
		"to_zone": to_zone
	})

func set_trap(card_id, to_zone):
	return submit_action("SET_TRAP", {
		"card_id": card_id,
		"to_zone": to_zone
	})

func activate_effect(card_id, zone_type = "spell_trap"):
	return submit_action("ACTIVATE_EFFECT", {
		"card_id": card_id,
		"zone_type": zone_type
	})

func declare_attack(attacker_zone, target_zone = -1):
	return submit_action("DECLARE_ATTACK", {
		"atk_zone": attacker_zone,
		"target_zone": target_zone
	})

func change_position(zone, to_position):
	return submit_action("CHANGE_POSITION", {
		"zone": zone,
		"to_position": to_position
	})

func end_phase():
	return submit_action("END_PHASE", {})

func end_turn():
	return submit_action("END_TURN", {})

func surrender():
	return submit_action("SURRENDER", {})

# ===========================================================================
# Getter
# ===========================================================================
func is_in_room():
	return current_room_id != ""

func get_current_room_id():
	return current_room_id

func get_current_player_id():
	return current_player_id

# Trong GameClientController.gd, s·ª≠a:
func get_game_state(room_id):
	var token = authentication.session_token
	network_client.send_message({
		"type": "GET_STATE",
		"room_id": room_id,
		"token": token
	})

func is_my_turn():
	return current_game_state and current_game_state.turn == current_player_id

func get_opponent_id():
	if not current_game_state or not current_game_state.players:
		return ""
	for pid in current_game_state.players.keys():
		if pid != current_player_id:
			return pid
	return ""

# ===========================================================================
# Tham gia ph√≤ng
# ===========================================================================
func join_room(room_id):
	var token = authentication.session_token
	network_client.send_message({
		"type": "JOIN_ROOM",
		"room_id": room_id,
		"token": token
	})

# ===========================================================================
# T·∫°o ph√≤ng m·ªõi (h·ªó tr·ª£ mode: "pvp_1v1", "pve")
# ===========================================================================
func create_room(mode = "pvp_1v1"):
	if mode == "":
		mode = "pvp_1v1"
	network_client.send_create_room(mode)

# ===========================================================================
# L·∫•y danh s√°ch ph√≤ng
# ===========================================================================
func request_room_list():
	network_client.send_list_rooms()

================================================================================

--- FILE: client_yugi_duel\autoload\NetworkClient.gd ---
# ===========================================================================
# NetworkClient.gd - Client k·∫øt n·ªëi server multiplayer (Godot 3.6)
# Autoload Singleton
# ‚úÖ ƒê√£ fix: x·ª≠ l√Ω ROOM_LIST_UPDATE, t·ª± ƒë·ªông auth, t∆∞∆°ng th√≠ch v·ªõi server
# ===========================================================================
extends Node

# C·∫•u h√¨nh k·∫øt n·ªëi
var server_ip = "127.0.0.1"
var server_port = 8080

# K·∫øt n·ªëi ENet
var peer = null
var connected = false



# T√™n ƒëƒÉng nh·∫≠p t·ª± ƒë·ªông (d√πng ƒë·ªÉ test)
var auto_login_username = "player_%d" % (OS.get_unix_time() % 10000)

# Signal - D√πng ƒë·ªÉ th√¥ng b√°o cho c√°c manager kh√°c
signal connected_to_server
signal connection_failed
signal server_disconnected

signal auth_request(data)           # Server y√™u c·∫ßu ƒëƒÉng nh·∫≠p
signal auth_success(player_id, token) # ƒêƒÉng nh·∫≠p th√†nh c√¥ng
signal auth_failed(error_code)      # ƒêƒÉng nh·∫≠p th·∫•t b·∫°i

signal game_started(room_id)
signal game_state_received(state)   # Nh·∫≠n tr·∫°ng th√°i tr·∫≠n
signal game_event_received(events)  # Nh·∫≠n danh s√°ch s·ª± ki·ªán (t·∫•n c√¥ng, hi·ªáu ·ª©ng)
signal action_result_received(result) # K·∫øt qu·∫£ h√†nh ƒë·ªông

signal room_list_received(rooms)    # Nh·∫≠n danh s√°ch ph√≤ng
signal room_list_update(rooms)      # C·∫≠p nh·∫≠t danh s√°ch ph√≤ng
signal room_created(room_id)        # T·∫°o ph√≤ng th√†nh c√¥ng

signal error_received(code, message) # L·ªói t·ª´ server

# ===========================================================================
# connect_to_server(ip, port)
# Kh·ªüi t·∫°o k·∫øt n·ªëi ƒë·∫øn server qua ENet
# ===========================================================================
func connect_to_server(ip = "", port = 0):
	if connected:
		print("üü° NetworkClient: ƒê√£ k·∫øt n·ªëi r·ªìi!")
		return true

	if ip != "": server_ip = ip
	if port != 0: server_port = port

	# T·∫°o ENet client
	peer = NetworkedMultiplayerENet.new()
	var err = peer.create_client(server_ip, server_port)
	if err != OK:
		push_error("‚ùå Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn %s:%d (l·ªói: %d)" % [server_ip, server_port, err])
		emit_signal("connection_failed")
		return false

	# G√°n peer v√†o tree ‚Üí t·ª± ƒë·ªông poll
	get_tree().network_peer = peer
	connected = true

	print("üåê NetworkClient: ƒêang k·∫øt n·ªëi ƒë·∫øn %s:%d" % [server_ip, server_port])
	emit_signal("connected_to_server")
	return true

# ===========================================================================
# disconnect()
# Ng·∫Øt k·∫øt n·ªëi
# ===========================================================================
func _disconnect():
	if not connected or not peer:
		return
	get_tree().network_peer = null
	connected = false
	peer = null


	emit_signal("server_disconnected")
	print("üîå NetworkClient: ƒê√£ ng·∫Øt k·∫øt n·ªëi kh·ªèi server")

# ===========================================================================
# _process(delta)
# Kh√¥ng c·∫ßn g·ªçi multiplayer.poll() - get_tree() t·ª± ƒë·ªông x·ª≠ l√Ω
# ===========================================================================
func _process(delta):
	pass

# ===========================================================================
# send_message(data)
# G·ª≠i tin nh·∫Øn ƒë·∫øn server (qua RPC)
# ===========================================================================
func send_message(data):
	if not connected or not get_tree().network_peer:
		push_warning("‚ùå Kh√¥ng th·ªÉ g·ª≠i tin: ch∆∞a k·∫øt n·ªëi")
		return false

	# G·ª≠i ƒë·∫øn server (peer_id = 1)
	rpc_id(1, "receive_message", data)
	return true

# ===========================================================================
# receive_message(data) ‚Üê remote
# H√†m n√†y ƒë∆∞·ª£c server g·ªçi qua RPC
# ƒê·ªãnh tuy·∫øn tin nh·∫Øn theo type
# ===========================================================================
remote func receive_message(data):
	if typeof(data) != TYPE_DICTIONARY:
		push_warning("‚ö†Ô∏è Nh·∫≠n d·ªØ li·ªáu kh√¥ng ph·∫£i dictionary")
		return
	if not data.has("type"):
		push_warning("‚ö†Ô∏è Tin nh·∫Øn kh√¥ng c√≥ 'type'")
		return

	var msg_type = data.type

	match msg_type:

		"PLAYER_INFO":
			_on_player_info(data)
		"WELCOME":
			_on_welcome(data)
		"AUTH_REQUEST":
			_on_auth_request(data)
		"AUTH_SUCCESS":
			_on_auth_success(data)
		"AUTH_ERROR":
			_on_auth_error(data)
		"GAME_STATE":
			_on_game_state(data)
		"GAME_EVENT":
			_on_game_event(data)
		"ACTION_RESULT":
			_on_action_result(data)
		"ROOM_LIST":
			_on_room_list(data)
		"ROOM_LIST_UPDATE":
			_on_room_list_update(data)
		"ROOM_CREATED":
			_on_room_created(data)
		"ERROR":
			_on_error(data)
		"GAME_STARTED":
			_on_game_started(data)
		"GAME_OVER":
			_on_game_over(data)
		"TURN_CHANGED":
			_on_turn_changed(data)
		"PHASE_CHANGED":
			_on_phase_changed(data)
		_:
			print("üì© NetworkClient: Tin nh·∫Øn kh√¥ng x·ª≠ l√Ω: %s" % msg_type)
			print(data)

# ===========================================================================
# C√°c h√†m x·ª≠ l√Ω tin nh·∫Øn t·ª´ server
# ===========================================================================

func _on_player_info(data):
	var player_data = data.get("player", {})
	print("üìÑ Nh·∫≠n th√¥ng tin ng∆∞·ªùi ch∆°i: %s" % player_data.get("username", "unknown"))
	# C√≥ th·ªÉ l∆∞u v√†o local, nh∆∞ng kh√¥ng ·∫£nh h∆∞·ªüng ƒë·∫øn x√°c th·ª±c

func _on_welcome(data):
	print("üëã Ch√†o m·ª´ng t·ª´ server: ", data.get("message", "Kh√¥ng c√≥ th√¥ng ƒëi·ªáp"))

func _on_auth_request(data):
	print("üîê Server y√™u c·∫ßu x√°c th·ª±c: %s" % data.get("message", ""))
	emit_signal("auth_request", data)
	# C√≥ th·ªÉ t·ª± ƒë·ªông ƒëƒÉng nh·∫≠p (t√πy UI)
	# send_auth_login(auto_login_username)

func _on_auth_success(data):
	var pid = data.get("player_id", "")
	var token = data.get("token", "")
	if pid == "" or token == "":
		var reason = "INVALID_PLAYER_ID" if pid == "" else "MISSING_TOKEN"
		emit_signal("auth_failed", reason)
		return
	# ‚úÖ G·ª≠i to√†n b·ªô data dictionary
	emit_signal("auth_success", data)
	print("‚úÖ X√°c th·ª±c th√†nh c√¥ng: %s" % pid)


func _on_auth_error(data):
	var code = data.get("code", "UNKNOWN")
	emit_signal("auth_failed", code)
	print("‚ùå X√°c th·ª±c th·∫•t b·∫°i: %s" % code)

func _on_game_state(data):
	var state = data.get("state", {})
	if typeof(state) != TYPE_DICTIONARY:
		print("‚ö†Ô∏è GAME_STATE: 'state' kh√¥ng ph·∫£i dictionary")
		return
	emit_signal("game_state_received", state)
	print("üìä Nh·∫≠n tr·∫°ng th√°i tr·∫≠n ƒë·∫•u")

func _on_game_event(data):
	var events = data.get("events", [])
	if typeof(events) != TYPE_ARRAY:
		print("‚ö†Ô∏è GAME_EVENT: 'events' kh√¥ng ph·∫£i array")
		return
	emit_signal("game_event_received", events)
	print("‚ö° Nh·∫≠n %d s·ª± ki·ªán t·ª´ server" % events.size())

func _on_action_result(data):
	var result = data.get("result", {})
	if typeof(result) != TYPE_DICTIONARY:
		print("‚ö†Ô∏è ACTION_RESULT: 'result' kh√¥ng ph·∫£i dictionary")
		return
	emit_signal("action_result_received", result)
	if not result.get("success", false):
		var errors = result.get("errors", [])
		print("‚ùå H√†nh ƒë·ªông th·∫•t b·∫°i: %s" % str(errors))

func _on_room_list(data):
	var rooms = data.get("rooms", [])
	if typeof(rooms) != TYPE_ARRAY:
		print("‚ö†Ô∏è ROOM_LIST: 'rooms' kh√¥ng ph·∫£i array")
		return
	emit_signal("room_list_received", rooms)
	print("üìã Nh·∫≠n danh s√°ch ph√≤ng: %d ph√≤ng" % rooms.size())

func _on_room_list_update(data):
	var rooms = data.get("rooms", [])
	if typeof(rooms) != TYPE_ARRAY:
		print("‚ö†Ô∏è ROOM_LIST_UPDATE: 'rooms' kh√¥ng ph·∫£i array")
		return
	emit_signal("room_list_update", rooms)
	print("üîÑ C·∫≠p nh·∫≠t danh s√°ch ph√≤ng: %d ph√≤ng" % rooms.size())

func _on_room_created(data):
	var room_id = data.get("room_id", "")
	if room_id == "":
		return
	emit_signal("room_created", room_id)
	print("üéâ T·∫°o ph√≤ng th√†nh c√¥ng: %s" % room_id)

func _on_error(data):
	var code = data.get("code", "UNKNOWN")
	var msg = data.get("message", "")
	emit_signal("error_received", code, msg)
	print("‚ùå L·ªói t·ª´ server: %s | %s" % [code, msg])

func _on_game_started(data):
	var room_id = data.get("room_id", "")
	if room_id == "":
		return
	# Ph√°t t√≠n hi·ªáu ƒë·ªÉ GameClientController x·ª≠ l√Ω
	emit_signal("game_started", room_id)
	print("üéÆ Tr·∫≠n ƒë·∫•u b·∫Øt ƒë·∫ßu: %s" % room_id)

func _on_game_over(data):
	var winner = data.get("winner", "")
	var reason = data.get("reason", "unknown")
	# Ph√°t t√≠n hi·ªáu n·∫øu c·∫ßn
	emit_signal("game_over", winner, reason)
	print("üèÅ Tr·∫≠n k·∫øt th√∫c. Ng∆∞·ªùi th·∫Øng: %s (l√Ω do: %s)" % [winner, reason])

func _on_turn_changed(data):
	var next_player = data.get("next_player", "")
	emit_signal("turn_changed", next_player)
	print("üîÑ L∆∞·ª£t ƒë·ªïi sang: %s" % next_player)

func _on_phase_changed(data):
	var new_phase = data.get("new_phase", "")
	emit_signal("phase_changed", new_phase)
	print("üîÅ Phase ƒë·ªïi: %s" % new_phase)

# ===========================================================================
# C√°c h√†m g·ª≠i h√†nh ƒë·ªông ƒë·∫øn server
# ===========================================================================

func send_auth_login(username, password = ""):
	var msg = {
		"type": "AUTH_LOGIN",
		"username": username
	}
	if password != "":
		msg["password"] = password
	send_message(msg)
	print("üì§ G·ª≠i y√™u c·∫ßu ƒëƒÉng nh·∫≠p: %s" % username)

func send_create_room(mode = "pvp_1v1"):
	send_message({
		"type": "CREATE_ROOM",
		"mode": mode
	})
	print("üì§ G·ª≠i y√™u c·∫ßu t·∫°o ph√≤ng (mode: %s)" % mode)

func send_join_room(room_id):
	if room_id == "":
		push_warning("‚ùå Kh√¥ng th·ªÉ v√†o ph√≤ng: room_id r·ªóng")
		return
	send_message({
		"type": "JOIN_ROOM",
		"room_id": room_id
	})
	print("üì§ G·ª≠i y√™u c·∫ßu v√†o ph√≤ng: %s" % room_id)

func send_list_rooms():
	send_message({ "type": "LIST_ROOMS" })
	print("üì§ G·ª≠i y√™u c·∫ßu danh s√°ch ph√≤ng")

func send_submit_action(action_type, payload = {}):
	var action = {
		"type": action_type,
		"payload": payload
	}
	send_message({
		"type": "SUBMIT_ACTION",
		"action": action
	})
	print("üì§ G·ª≠i h√†nh ƒë·ªông: %s" % action_type)

func send_get_state(room_id):
	if room_id == "":
		return
	send_message({
		"type": "GET_STATE",
		"room_id": room_id
	})
	print("üì§ G·ª≠i y√™u c·∫ßu tr·∫°ng th√°i tr·∫≠n: %s" % room_id)

# ===========================================================================
# Getter
# ===========================================================================
func _is_connected():
	return connected

================================================================================

--- FILE: client_yugi_duel\core\BotTestClient.gd ---
# ===========================================================================
# BotTestClient.gd - Client test t·ª± ƒë·ªông (phi√™n b·∫£n ƒë·ªôc l·∫≠p)
# ‚úÖ ƒê√£ s·ª≠a: ch·ªâ g·ª≠i login khi server y√™u c·∫ßu, tr√°nh m·∫•t g√≥i
# ===========================================================================
extends Node

const SERVER_IP = "127.0.0.1"
const SERVER_PORT = 8080
var TEST_USERNAME = "bot_%d" % (randi() % 1000)  # ‚Üí bot_123 (5-7 k√Ω t·ª±)

var room_id = ""
var player_id = ""
var has_sent_login = false

export var is_host = false

onready var network_client = NetworkManager
onready var authentication = Authentication
onready var game_controller = GameClientController


func _ready():
	authentication.auto_login_on_request = false

	network_client.connect("connected_to_server", self, "_on_connected_to_server")
	network_client.connect("auth_request", self, "_on_auth_request")  # ‚Üê B·∫ÆT BU·ªòC
	network_client.connect("room_list_update", self, "_on_room_list_update")
	authentication.connect("login_success", self, "_on_login_success")
	authentication.connect("login_failed", self, "_on_login_failed")
	game_controller.connect("joined_room", self, "_on_joined_room")
	game_controller.connect("game_state_updated", self, "_on_game_state_updated")
	game_controller.connect("game_event_received", self, "_on_game_event_received")
	game_controller.connect("error_received", self, "_on_error_received")
	game_controller.connect("game_started", self, "_on_game_started")

	_connect_to_server()


func _connect_to_server():
	if network_client.connect_to_server(SERVER_IP, SERVER_PORT):
		print("‚úÖ [BOT] ƒê√£ g·ª≠i y√™u c·∫ßu k·∫øt n·ªëi ƒë·∫øn %s:%d" % [SERVER_IP, SERVER_PORT])
	else:
		print("üî¥ [BOT] K·∫øt n·ªëi th·∫•t b·∫°i!")
		_finish_test(false)


func _on_connected_to_server():
	print("üü¢ [BOT] K·∫øt n·ªëi th√†nh c√¥ng. ƒêang ch·ªù server y√™u c·∫ßu x√°c th·ª±c...")


func _on_auth_request(data):
	if has_sent_login:
		return
	print("üîê [BOT] Server y√™u c·∫ßu x√°c th·ª±c ‚Üí g·ª≠i ƒëƒÉng nh·∫≠p...")
	if authentication.login(TEST_USERNAME):
		has_sent_login = true
		print("üì§ [BOT] ƒê√£ g·ª≠i ƒëƒÉng nh·∫≠p: %s" % TEST_USERNAME)
	else:
		print("‚ùå [BOT] G·ª≠i ƒëƒÉng nh·∫≠p th·∫•t b·∫°i!")
		_finish_test(false)


func _on_login_success(pid, is_guest):
	self.player_id = pid
	print("üü¢ [BOT] ‚úÖ X√°c th·ª±c th√†nh c√¥ng: %s (guest=%s)" % [pid, is_guest])

	if is_host:
		print("üéÆ [BOT] T·∫°o ph√≤ng m·ªõi...")
		game_controller.create_room("pvp_1v1")
	else:
		print("üîç [BOT] Y√™u c·∫ßu danh s√°ch ph√≤ng...")
		game_controller.request_room_list()


func _on_login_failed(error_code):
	match error_code:
		"INVALID_USERNAME":
			print("‚ùå T√™n qu√° d√†i ho·∫∑c qu√° ng·∫Øn!")
		"USERNAME_EMPTY":
			print("‚ùå T√™n tr·ªëng!")
		"AUTH_REQUIRED":
			print("‚ùå C·∫ßn ƒëƒÉng nh·∫≠p!")
		_:
			print("‚ùå L·ªói: %s" % error_code)
	_finish_test(false)


func _on_joined_room(rid):
	room_id = rid
	print("‚úÖ [BOT] ƒê√£ v√†o ph√≤ng: %s" % room_id)


func _on_room_list_update(rooms):
	if is_host:
		return
	for room in rooms:
		if room.status == "waiting" and room.player_count == 1:
			print("üëâ [BOT] V√†o ph√≤ng: %s" % room.room_id)
			game_controller.join_room(room.room_id)
			return


func _on_game_started(rid):
	print("üéÆ [BOT] ‚öîÔ∏è Tr·∫≠n ƒë·∫•u b·∫Øt ƒë·∫ßu: %s" % rid)


func _on_game_state_updated(state):
	print("üîÑ [BOT] Nh·∫≠n tr·∫°ng th√°i: L∆∞·ª£t=%s, Phase=%s" % [state.turn, state.phase])
	_send_test_actions(state)


func _send_test_actions(state):
	var my_id = game_controller.get_current_player_id()
	if state.turn != my_id:
		return
	if state.phase in ["main1", "main2"]:
		var hand = state.players[my_id].hand
		var zones = state.players[my_id].field.monster_zones
		for i in range(zones.size()):
			if zones[i] == null and hand.size() > 0:
				game_controller.play_monster(hand[0], i)
				return
		game_controller.end_turn()


func _on_game_event_received(events):
	for event in events:
		if event.type == "WIN":
			print("üèÜ [BOT] Tr·∫≠n k·∫øt th√∫c! Ng∆∞·ªùi th·∫Øng: %s" % event.winner)
			_finish_test(event.winner == player_id)


func _on_error_received(code, message):
	print("‚ùå [BOT] L·ªói: %s | %s" % [code, message])
	_finish_test(false)


func _finish_test(success):
	var status = "‚úÖ [BOT] TEST TH√ÄNH C√îNG!" if success else "‚ùå [BOT] TEST TH·∫§T B·∫†I!"
	print("==================================")
	print(status)
	print("==================================")
	network_client._disconnect()
	queue_free()

================================================================================

--- FILE: server_yugiDuel\autoload\agent.gd ---
# ===========================================================================
# Agent.gd - C·∫¨P NH·∫¨T: H·ªçc t·ª´ EVENTS v√† CHAIN (kh√¥ng ch·ªâ state/action)
# ===========================================================================

extends Node

# --- State ---
var current_game_state
var my_player_id
var learning_mode = true

# --- Q-Table (v·∫´n gi·ªØ ƒë·ªÉ ch·ªçn h√†nh ƒë·ªông ch√≠nh) ---
var q_table = {}
var learning_rate = 0.1
var discount_factor = 0.9
var exploration_rate = 0.3

# --- Rule-based Response Database (m·ªõi) ---
# Khi c√≥ event ‚Üí ph·∫£n ·ª©ng n√†o h·ª£p l√Ω?
var response_rules = {
	"TRIGGER_EFFECT": {
		"Mirror Force": ["ACTIVATE_EFFECT", "card_id", "Effect Veiler"],
		"Solemn Judgment": ["ACTIVATE_EFFECT", "card_id", "Infinite Emperor"]
	},
	"DAMAGE_STEP": {
		"common": ["ACTIVATE_EFFECT", "card_id", "Book of Moon"]
	}
}

# --- Feature Extraction ---
func _extract_state_key(game_state, player_id):
	var p = game_state["players"][player_id]
	var opp = game_state["players"][_get_opponent_id(game_state, player_id)]
	var my_lr = int(p.life_points / 2000)
	var opp_lr = int(opp.life_points / 2000)
	var my_mc = 0
	for m in p.monster_zones:
		if m: my_mc += 1
	var opp_mc = 0
	for m in opp.monster_zones:
		if m: opp_mc += 1
	return "%d_%d_%d_%d_%s" % [my_lr, opp_lr, my_mc, opp_mc, game_state["phase"]]

func _get_q_value(state_key, action):
	return q_table.get(state_key, {}).get(action, 0.0)

# ===========================================================================
# get_action(game_state, player_id, available_actions)
# Tr·∫£ v·ªÅ h√†nh ƒë·ªông ch√≠nh (l∆∞·ª£t c·ªßa t√¥i)
# ===========================================================================
func get_action(game_state, player_id, available_actions):
	my_player_id = player_id
	current_game_state = game_state.duplicate(true)
	
	var state_key = _extract_state_key(game_state, player_id)
	
	# Kh√°m ph√° ho·∫∑c khai th√°c
	if randf() < exploration_rate:
		return available_actions[randi() % available_actions.size()]
	
	var best_action = "END_TURN"
	var best_value = -1e9
	for action in available_actions:
		var q = _get_q_value(state_key, action)
		if q > best_value:
			best_value = q
			best_action = action
	return best_action

# ===========================================================================
# on_event(game_state, event_list)
# üÜï H√†m m·ªõi: Khi c√≥ s·ª± ki·ªán ‚Üí xem c√≥ c·∫ßn ph·∫£n ·ª©ng kh√¥ng?
# D√πng ƒë·ªÉ h·ªçc c√°ch "ƒë√°p l·∫°i hi·ªáu ·ª©ng"
# ===========================================================================
func on_event(game_state, events, player_id):
	my_player_id = player_id
	current_game_state = game_state.duplicate(true)
	
	for event in events:
		match event["type"]:
			"TRIGGER_EFFECT":
				return _handle_trigger_effect(game_state, event)
			"CHAIN_STARTED":
				return _handle_chain_started(game_state, event)
			"DAMAGE_STEP":
				return _handle_damage_step(game_state, event)
			"SUMMON":
				return _handle_summon_reaction(game_state, event)
	return null  # Kh√¥ng ph·∫£n ·ª©ng

# --- X·ª≠ l√Ω c√°c lo·∫°i event ---

func _handle_trigger_effect(game_state, event):
	var card_name = CardDatabase.get(event["card_id"]).name
	if response_rules.TRIGGER_EFFECT.has(card_name):
		var rule = response_rules.TRIGGER_EFFECT[card_name]
		if rule[0] == "ACTIVATE_EFFECT":
			var target_card = rule[2]
			if _has_card_in_hand(game_state, my_player_id, target_card):
				return {
					"type": "ACTIVATE_EFFECT",
					"payload": { "card_id": target_card }
				}
	return null

func _handle_summon_reaction(game_state, event):
	# N·∫øu ƒë·ªëi ph∆∞∆°ng tri·ªáu h·ªìi qu√°i m·∫°nh ‚Üí ch·∫∑n b·∫±ng b·∫´y
	var card_data = CardDatabase.get(event["card_id"])
	if card_data["attack"] >= 2500:
		if _has_card_in_hand(game_state, my_player_id, "MIRROR_FORCE"):
			return {
				"type": "PLAY_TRAP",
				"payload": { "card_id": "MIRROR_FORCE", "to_zone": 0 }
			}
	return null

func _handle_chain_started(game_state, event):
	# ƒêang trong chain ‚Üí c√≥ th·ªÉ ph·∫£n ·ª©ng
	return null  # T·∫°m th·ªùi kh√¥ng l√†m g√¨

func _handle_damage_step(game_state, event):
	return response_rules.get("DAMAGE_STEP", {}).get("common", null)

# --- H·ªó tr·ª£ ---

func _has_card_in_hand(game_state, player_id, card_id):
	return game_state["players"][player_id].hand.has(card_id)

func _get_opponent_id(game_state, player_id):
	for pid in game_state["players"].keys():
		if pid != player_id:
			return pid
	return null

# ===========================================================================
# learn_from_result(old_state, action, result)
# üÜï H·ªçc t·ª´ to√†n b·ªô result, kh√¥ng ch·ªâ reward
# ===========================================================================
func learn_from_result(old_state, action, result):
	if not result["success"]:
		return
	
	var new_state = result["game_state"]
	var events = result["events"]
	var state_key = _extract_state_key(old_state, action["player_id"])
	var next_key = _extract_state_key(new_state, action["player_id"])
	
	# T√≠nh reward t·ª´ events
	var reward = 0.0
	for event in events:
		match event["type"]:
			"DAMAGE":
				if event["target"] == action["player_id"]:
					reward -= event["amount"] / 100.0
				else:
					reward += event["amount"] / 100.0
			"WIN":
				if event["winner"] == action["player_id"]:
					reward += 10.0
				else:
					reward -= 10.0
			"SUMMON":
				var card = CardDatabase.get(event["card_id"])
				if card and card["attack"] > 2500:
					reward += 0.5
			"DESTROYED":
				if event["player"] == action["player_id"]:
					reward -= 1.0
				else:
					reward += 1.0
	
	# C·∫≠p nh·∫≠t Q-value
	var old_q = _get_q_value(state_key, action["type"])
	var future = 0.0
	if new_state["status"] != "finished":
		for a in ["END_TURN", "PLAY_MONSTER", "ACTIVATE_EFFECT"]:
			future = max(future, _get_q_value(next_key, a))
	var new_q = (1 - learning_rate) * old_q + learning_rate * (reward + discount_factor * future)
	
	if not q_table.has(state_key):
		q_table[state_key] = {}
	q_table[state_key][action["type"]] = new_q
	
	# üÜï H·ªçc t·ª´ events ƒë·ªÉ c·∫≠p nh·∫≠t response_rules
	_learn_from_events(events, action["player_id"])

func _learn_from_events(events, player_id):
	for event in events:
		if event["type"] == "TRIGGER_EFFECT" and event["card_id"] == "MIRROR_FORCE":
			# N·∫øu t√¥i kh√¥ng ph·∫£n ·ª©ng ‚Üí b·ªã thi·ªát ‚Üí n√™n h·ªçc d√πng Effect Veiler
			if _recently_lost_battle_due_to(event["card_id"]):
				_add_response_rule("TRIGGER_EFFECT", "Mirror Force", [
					"ACTIVATE_EFFECT", "card_id", "EFFECT_VEILER"
				])

func _add_response_rule(category, trigger, action):
	if not response_rules.has(category):
		response_rules[category] = {}
	response_rules[category][trigger] = action

func _recently_lost_battle_due_to(card_id):
	# C√≥ th·ªÉ l∆∞u log tr·∫≠n thua
	return false  # T·∫°m th·ªùi




================================================================================

--- FILE: server_yugiDuel\autoload\AuthManager.gd ---
# ===========================================================================
# AuthManager.gd - Qu·∫£n l√Ω x√°c th·ª±c & b·∫£o m·∫≠t ng∆∞·ªùi ch∆°i (Godot 3.6)
# Autoload Singleton
# Ch·ª©c nƒÉng:
#   - ƒêƒÉng nh·∫≠p / t·∫°o session
#   - T·∫°o v√† ki·ªÉm tra token
#   - Li√™n k·∫øt player_id v·ªõi peer_id
#   - G·ª≠i t√≠n hi·ªáu khi x√°c th·ª±c th√†nh c√¥ng
# ===========================================================================
extends Node

# Th·ªùi h·∫°n token (gi√¢y) - 1 gi·ªù
const TOKEN_EXPIRE_TIME = 3600

# C·∫•u tr√∫c session: token ‚Üí { player_id, peer_id, created_time }
var sessions = {}

# Signal
signal player_authenticated(player_id, session_token, peer_id)
signal player_logged_out(player_id)
signal auth_failed(peer_id, error_code)

# Tham chi·∫øu ƒë·∫øn NetworkManager
onready var network_manager = NetworkManager

# ===========================================================================
# _ready()
# K·∫øt n·ªëi v·ªõi NetworkManager ƒë·ªÉ l·∫Øng nghe k·∫øt n·ªëi
# ===========================================================================
func _ready():
	# yield(get_tree().create_timer(1), "timeout")
	#if not Engine.has_singleton("NetworkManager"):
	if not network_manager:
		push_error("‚ùå AuthManager: NetworkManager kh√¥ng t·ªìn t·∫°i trong Autoload!")
		return
	# L·∫Øng nghe khi client k·∫øt n·ªëi
	network_manager.connect("client_connected", self, "_on_client_connected")
	network_manager.connect("message_received", self, "_on_message_received")

# ===========================================================================
# _on_client_connected(player_id, peer_id)
# Khi client k·∫øt n·ªëi ‚Üí y√™u c·∫ßu ƒëƒÉng nh·∫≠p
# player_id ·ªü ƒë√¢y ch·ªâ l√† t·∫°m "player_X"
# ===========================================================================
func _on_client_connected(player_id, peer_id):
	print("üîê AuthManager: Client peer=%d c·∫ßn x√°c th·ª±c." % peer_id)
	# G·ª≠i y√™u c·∫ßu ƒëƒÉng nh·∫≠p
	var msg = {
		"type": "AUTH_REQUEST",
		"message": "Vui l√≤ng g·ª≠i AUTH_LOGIN ƒë·ªÉ x√°c th·ª±c."
	}
	network_manager.send_message_to_player(player_id, msg)

# ===========================================================================
# _on_message_received(player_id, message)
# X·ª≠ l√Ω tin nh·∫Øn, ƒë·∫∑c bi·ªát l√† AUTH_LOGIN
# ===========================================================================
func _on_message_received(player_id, message):
	if message.type == "AUTH_LOGIN":
		_handle_auth_login(message, player_id)
	elif message.type == "AUTH_VERIFY":
		_handle_auth_verify(message, player_id)
	elif message.type == "LOGOUT":
		_handle_logout(message, player_id)
	else:
		# N·∫øu ch∆∞a x√°c th·ª±c, ch·∫∑n m·ªçi tin nh·∫Øn kh√¥ng ph·∫£i AUTH
		if not _is_player_authenticated(player_id):
			_send_error(player_id, "AUTH_REQUIRED")
			return

# ===========================================================================
# _handle_auth_login(message, temp_player_id)
# X·ª≠ l√Ω ƒëƒÉng nh·∫≠p: client g·ª≠i username, c√≥ th·ªÉ k√®m guest/token
# ===========================================================================
# Trong _handle_auth_login
func _handle_auth_login(message, temp_player_id):
	var username = message.get("username", "").strip_edges()
	var token = message.get("token", "")
	var peer_id = _get_peer_from_player(temp_player_id)
	
	# ‚úÖ Ki·ªÉm tra peer_id h·ª£p l·ªá
	if peer_id == 0:
		_send_error(temp_player_id, "INVALID_PEER")
		return

	# ‚úÖ N·∫øu username r·ªóng ‚Üí t·∫°o guest
	if username == "":
		username = "guest_%d" % randi()

	# ‚úÖ ƒê·∫£m b·∫£o username h·ª£p l·ªá
	if username.length() < 3 or username.length() > 20:
		_send_error(temp_player_id, "INVALID_USERNAME")
		return

	# ‚úÖ T·∫°o session m·ªõi
	var new_token = _generate_token()
	sessions[new_token] = {
		"username": username,
		"player_id": temp_player_id,
		"peer_id": peer_id,
		"created_time": OS.get_unix_time(),
		"last_active": OS.get_unix_time()
	}

	# ‚úÖ C·∫≠p nh·∫≠t player_id th·∫≠t
	_complete_auth(username, new_token, peer_id)

# ===========================================================================
# _handle_auth_verify(message, temp_player_id)
# Client g·ª≠i token ƒë·ªÉ x√°c minh
# ===========================================================================
func _handle_auth_verify(message, temp_player_id):
	var token = message.get("token", "")
	var peer_id = _get_peer_from_player(temp_player_id)
	if not _is_valid_token(token):
		_send_error(temp_player_id, "INVALID_TOKEN")
		return
	var session = sessions[token]
	if session.peer_id != peer_id:
		_send_error(temp_player_id, "TOKEN_MISMATCH")
		return
	_complete_auth(session.player_id, token, peer_id)

# ===========================================================================
# _handle_logout(message, temp_player_id)
# Ng∆∞·ªùi ch∆°i ƒëƒÉng xu·∫•t
# ===========================================================================
func _handle_logout(message, temp_player_id):
	var token = message.get("token", "")
	if token in sessions:
		var player_id = sessions[token].player_id
		sessions.erase(token)
		emit_signal("player_logged_out", player_id)
		print("üîê AuthManager: '%s' ƒë√£ ƒëƒÉng xu·∫•t." % player_id)
	# G·ª≠i ph·∫£n h·ªìi
	network_manager.send_message_to_player(temp_player_id, {
		"type": "LOGOUT_SUCCESS"
	})

# ===========================================================================
# _complete_auth(player_id, token, peer_id)
# Ho√†n t·∫•t x√°c th·ª±c ‚Üí c·∫≠p nh·∫≠t player_id th·∫≠t, ph√°t t√≠n hi·ªáu
# ===========================================================================
func _complete_auth(player_id, token, peer_id):
	# ‚úÖ C·∫≠p nh·∫≠t √°nh x·∫°: peer_id ‚Üí player_id (th·∫≠t)
	network_manager.peer_to_player[peer_id] = player_id
	# ‚úÖ Ph√°t t√≠n hi·ªáu
	emit_signal("player_authenticated", player_id, token, peer_id)
	# ‚úÖ G·ª≠i ph·∫£n h·ªìi
	var response = {
		"type": "AUTH_SUCCESS",
		"player_id": player_id,   # ‚úÖ ƒê·∫£m b·∫£o g·ª≠i ƒë√∫ng player_id
		"token": token,
		"server_time": OS.get_unix_time()
	}
	network_manager.send_message_to_player(player_id, response)
	print("üü¢ AuthManager: '%s' ƒë√£ x√°c th·ª±c th√†nh c√¥ng (peer=%d)" % [player_id, peer_id])

# ===========================================================================
# _is_player_authenticated(player_id) ‚Üí bool
# Ki·ªÉm tra player_id ƒë√£ x√°c th·ª±c ch∆∞a
# ===========================================================================
func _is_player_authenticated(player_id):
	for token in sessions:
		if sessions[token].player_id == player_id:
			return true
	return false

# ===========================================================================
# is_token_valid(token) ‚Üí bool
# D√πng b√™n ngo√†i ƒë·ªÉ ki·ªÉm tra token (vd: trong ServerManager)
# ===========================================================================
func is_token_valid(token):
	return _is_valid_token(token)

# ===========================================================================
# get_player_id_by_token(token) ‚Üí String
# Tr·∫£ v·ªÅ player_id n·∫øu token h·ª£p l·ªá
# ===========================================================================
func get_player_id_by_token(token):
	if _is_valid_token(token):
		return sessions[token].player_id
	return ""

# ===========================================================================
# get_peer_id_by_player(player_id) ‚Üí int
# Tr·∫£ v·ªÅ peer_id
# ===========================================================================
func get_peer_id_by_player(player_id):
	for token in sessions:
		if sessions[token].player_id == player_id:
			return sessions[token].peer_id
	return 0

# ===========================================================================
# _is_valid_token(token) ‚Üí bool
# Ki·ªÉm tra token t·ªìn t·∫°i v√† ch∆∞a h·∫øt h·∫°n
# ===========================================================================
func _is_valid_token(token):
	if not sessions.has(token):
		return false
	var session = sessions[token]
	var now = OS.get_unix_time()
	if now - session.created_time > TOKEN_EXPIRE_TIME:
		sessions.erase(token)
		return false
	# C·∫≠p nh·∫≠t last_active
	session.last_active = now
	return true

# ===========================================================================
# _renew_session(token)
# L√†m m·ªõi th·ªùi gian session
# ===========================================================================
func _renew_session(token):
	if sessions.has(token):
		sessions[token].created_time = OS.get_unix_time()


# ===========================================================================
# _generate_token() ‚Üí String
# T·∫°o token ng·∫´u nhi√™n 32 k√Ω t·ª± (ch·ªâ d√πng t√≠nh nƒÉng Godot 3.6)
# ===========================================================================
func _generate_token():
	var chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	var len_ = chars.length()
	var rand_str = ""
	for i in range(32):
		var c = chars[randi() % len_]
		rand_str += c
	return rand_str

# ===========================================================================
# _get_peer_from_player(temp_player_id) ‚Üí int
# L·∫•y peer_id t·ª´ NetworkManager
# ===========================================================================
func _get_peer_from_player(player_id):
	return network_manager._get_peer_from_player(player_id)

# ===========================================================================
# _send_error(player_id, error_code)
# G·ª≠i l·ªói x√°c th·ª±c
# ===========================================================================
func _send_error(player_id, error_code):
	var msg = {
		"type": "AUTH_ERROR",
		"code": error_code,
		"message": _get_error_message(error_code)
	}
	network_manager.send_message_to_player(player_id, msg)

# ===========================================================================
# _get_error_message(code) ‚Üí String
# B·∫£n m√¥ t·∫£ l·ªói
# ===========================================================================
func _get_error_message(code):
	match code:
		"AUTH_REQUIRED": return "C·∫ßn ƒëƒÉng nh·∫≠p tr∆∞·ªõc khi th·ª±c hi·ªán h√†nh ƒë·ªông."
		"INVALID_TOKEN": return "Token kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ h·∫øt h·∫°n."
		"TOKEN_MISMATCH": return "Token kh√¥ng kh·ªõp v·ªõi k·∫øt n·ªëi hi·ªán t·∫°i."
		"INVALID_PEER": return "Kh√¥ng t√¨m th·∫•y peer."
		"INVALID_CREDENTIALS": return "T√™n ƒëƒÉng nh·∫≠p ho·∫∑c m·∫≠t kh·∫©u sai."
		_:
			return "L·ªói x√°c th·ª±c kh√¥ng x√°c ƒë·ªãnh."

# ===========================================================================
# cleanup_expired_sessions()
# D·ªçn d·∫πp session h·∫øt h·∫°n (g·ªçi t·ª´ ServerManager._process)
# ===========================================================================
func cleanup_expired_sessions():
	var now = OS.get_unix_time()
	var expired = []
	for token in sessions:
		if now - sessions[token].created_time > TOKEN_EXPIRE_TIME:
			expired.append(token)
	for token in expired:
		var player_id = sessions[token].player_id
		sessions.erase(token)
		print("üßπ AuthManager: Session h·∫øt h·∫°n ƒë√£ x√≥a: %s" % player_id)

================================================================================

--- FILE: server_yugiDuel\autoload\BattleCore.gd ---
# ===========================================================================
# BattleCore.gd - Core x·ª≠ l√Ω tr·∫≠n ƒë·∫•u Yu-Gi-Oh! (Godot 3.6)
# Autoload Singleton - D√πng ƒë·ªÉ qu·∫£n l√Ω to√†n b·ªô logic tr·∫≠n ƒë·∫•u
# Kh√¥ng c·∫ßn UI, kh√¥ng c·∫ßn m·∫°ng - ch·ªâ c·∫ßn ch·∫°y trong Godot
# ===========================================================================

extends Node

# Danh s√°ch c√°c tr·∫≠n ƒëang di·ªÖn ra: room_id ‚Üí game_state
var active_duels = {}

# Th·ª© t·ª± c√°c phase trong m·ªôt l∆∞·ª£t
const TURN_PHASES = ["draw", "standby", "main1", "battle", "main2", "end"]

# C√°c l√Ω do chi·∫øn th·∫Øng
const WIN_REASON_LP_ZERO = "lp_zero"
const WIN_REASON_DECK_OUT = "deck_out"
const WIN_REASON_SURRENDER = "surrender"
const WIN_REASON_EXODIA = "exodia"
const WIN_REASON_FORFEIT = "forfeit"

# Error codes
const ERR_ROOM_NOT_FOUND = "ROOM_NOT_FOUND"
const ERR_DUEL_NOT_ACTIVE = "DUEL_NOT_ACTIVE"
const ERR_INVALID_PLAYER = "INVALID_PLAYER"
const ERR_NOT_YOUR_TURN = "NOT_YOUR_TURN"
const ERR_NOT_IN_DRAW_PHASE = "NOT_IN_DRAW_PHASE"
const ERR_NO_DRAW_FIRST_TURN = "NO_DRAW_FIRST_TURN"
const ERR_DECK_EMPTY = "DECK_EMPTY"
const ERR_CARD_NOT_IN_HAND = "CARD_NOT_IN_HAND"
const ERR_ZONE_OCCUPIED = "ZONE_OCCUPIED"
const ERR_NOT_IN_MAIN_PHASE = "NOT_IN_MAIN_PHASE"
const ERR_NOT_MONSTER_CARD = "NOT_MONSTER_CARD"
const ERR_NOT_SPELL_CARD = "NOT_SPELL_CARD"
const ERR_NOT_TRAP_CARD = "NOT_TRAP_CARD"
const ERR_SPELL_ZONE_OCCUPIED = "SPELL_ZONE_OCCUPIED"
const ERR_TRAP_ZONE_OCCUPIED = "TRAP_ZONE_OCCUPIED"
const ERR_INVALID_ZONE = "INVALID_ZONE"
const ERR_CANNOT_CHANGE_POS_THIS_TURN = "CANNOT_CHANGE_POS_THIS_TURN"
const ERR_SAME_POSITION = "SAME_POSITION"
const ERR_CARD_NOT_ON_FIELD = "CARD_NOT_ON_FIELD"
const ERR_NO_EFFECT = "NO_EFFECT"
const ERR_NOT_IN_BATTLE_PHASE = "NOT_IN_BATTLE_PHASE"
const ERR_INVALID_ATTACKER = "INVALID_ATTACKER"
const ERR_NOT_IN_ATTACK_POSITION = "NOT_IN_ATTACK_POSITION"
const ERR_ALREADY_ATTACKED = "ALREADY_ATTACKED"
const ERR_CANNOT_ATTACK_SUMMON_TURN = "CANNOT_ATTACK_SUMMON_TURN"
const ERR_CANNOT_DIRECT_ATTACK = "CANNOT_DIRECT_ATTACK"
const ERR_INVALID_TARGET = "INVALID_TARGET"
const ERR_INVALID_PHASE = "INVALID_PHASE"
const ERR_INVALID_CARD = "INVALID_CARD"

# ===========================================================================
# start_duel(player_a_id, player_b_id, deck_a, deck_b, rules)
# T·∫°o m·ªôt tr·∫≠n ƒë·∫•u m·ªõi
# ===========================================================================
func start_duel(player_a_id, player_b_id, deck_a, deck_b, rules = {}):
	var room_id: String = "duel_%d_%d" % [OS.get_unix_time(), randi() % 10000]



	
	# Validate deck
	for card_id in deck_a + deck_b:
		if not CardDatabase.exists(card_id):
			return _error(ERR_INVALID_CARD)
		if card_id in rules.get("forbidden_cards", []):
			return _error("FORBIDDEN_CARD_IN_DECK")
	
	# Sao ch√©p v√† x√°o b√†i
	var deck_a_copy = deck_a.duplicate(true)
	var deck_b_copy = deck_b.duplicate(true)
	_shuffle(deck_a_copy)
	_shuffle(deck_b_copy)
	
	# B·ªëc 5 b√†i ƒë·∫ßu
	var hand_a = _draw_cards(deck_a_copy, 5)
	var hand_b = _draw_cards(deck_b_copy, 5)
	
	# Ch·ªçn ai ƒëi tr∆∞·ªõc
	var first_player = [player_a_id, player_b_id][randi() % 2]
	
	# T·∫°o tr·∫°ng th√°i tr·∫≠n ƒë·∫•u
	var start_lp = rules.get("start_lp", 8000)
	var game_state = {
		"room_id": room_id,
		"turn": first_player,
		"phase": "draw",
		"current_turn_count": 1,
		"is_first_turn": true,
		"first_player": first_player,
		"players": {
			player_a_id: _create_player_state(player_a_id, deck_a_copy, hand_a, start_lp),
			player_b_id: _create_player_state(player_b_id, deck_b_copy, hand_b, start_lp)
		},
		"status": "active",
		"winner": null,
		"win_reason": null,
		"chain": [],
		"chain_trigger": null,  # L∆∞u h√†nh ƒë·ªông trigger chain
		"rules": {
			"start_lp": start_lp,
			"max_hand_size": rules.get("max_hand_size", 6),
			"forbidden_cards": rules.get("forbidden_cards", [])
		}
	}
	
	# L∆∞u v√†o h·ªá th·ªëng
	active_duels[room_id] = game_state
	print("‚úÖ BattleCore: Tr·∫≠n '%s' ƒë√£ kh·ªüi t·∫°o. Ng∆∞·ªùi ƒëi tr∆∞·ªõc: %s" % [room_id, first_player])
	var temp: String = room_id
	
	
	return temp


# ===========================================================================
# submit_action(room_id, action)
# X·ª≠ l√Ω h√†nh ƒë·ªông t·ª´ ng∆∞·ªùi ch∆°i ho·∫∑c bot
# Tr·∫£ v·ªÅ: { success, events, available_actions, errors }
# ===========================================================================
func submit_action(room_id, action):
	if not active_duels.has(room_id):
		return _error(ERR_ROOM_NOT_FOUND)
	
	var game_state = active_duels[room_id]
	if game_state["status"] != "active":
		return _error(ERR_DUEL_NOT_ACTIVE)
	
	var player_id = action.get("player_id", "")
	if not game_state["players"].has(player_id):
		return _error(ERR_INVALID_PLAYER)
	
	# Ki·ªÉm tra l∆∞·ª£t ƒëi (tr·ª´ khi chain ho·∫∑c quick effect)
	if game_state["turn"] != player_id and action["type"] != "ACTIVATE_EFFECT":
		if not _can_activate_effect_out_of_turn(game_state, action):
			return _error(ERR_NOT_YOUR_TURN)
	
	# X·ª≠ l√Ω h√†nh ƒë·ªông
	var result = _process_action(game_state, action)
	
	# C·∫≠p nh·∫≠t tr·∫°ng th√°i
	if result["success"] and action["type"] == "ACTIVATE_EFFECT":
		_resolve_chain(game_state, action)
	
	# C·∫≠p nh·∫≠t l·∫°i tr·∫°ng th√°i
	active_duels[room_id] = game_state
	
	# Ki·ªÉm tra ƒëi·ªÅu ki·ªán chi·∫øn th·∫Øng
	var win_check = _check_win_condition(game_state)
	if win_check.winner:
		game_state["winner"] = win_check.winner
		game_state["win_reason"] = win_check.reason
		game_state["status"] = "finished"
		result["events"].append({
			"type": "WIN",
			"winner": win_check.winner,
			"reason": win_check.reason
		})
	elif result["success"] and game_state["chain"].empty():
		_update_phase_if_needed(game_state)
	
	# G√°n danh s√°ch h√†nh ƒë·ªông kh·∫£ d·ª•ng
	result["available_actions"] = _get_available_actions(game_state, player_id)
	result["game_state"] = game_state.duplicate(true)
	
	return result


# ===========================================================================
# get_game_state(room_id, player_id)
# Tr·∫£ v·ªÅ tr·∫°ng th√°i tr·∫≠n, ·∫©n b√†i tr√™n tay ƒë·ªëi th·ªß
# ===========================================================================
func get_game_state(room_id, player_id):
	if not active_duels.has(room_id):
		return {}
	
	var game_state = active_duels[room_id].duplicate(true)
	var opponent_id = _get_opponent_id(game_state, player_id)
	
	if game_state["players"].has(opponent_id):
		var opponent = game_state["players"][opponent_id]
		opponent["hand"] = []  # ·∫®n b√†i
		opponent["hand_count"] = len(opponent["hand"])  # Gi·ªØ s·ªë l∆∞·ª£ng
	
	return game_state


# ===========================================================================
# get_available_actions(room_id, player_id)
# Tr·∫£ v·ªÅ danh s√°ch h√†nh ƒë·ªông h·ª£p l·ªá (d√πng cho bot)
# ===========================================================================
func get_available_actions(room_id, player_id):
	if not active_duels.has(room_id):
		return []
	var game_state = active_duels[room_id]
	return _get_available_actions(game_state, player_id)


# ===========================================================================
# end_duel(room_id, winner, reason)
# K·∫øt th√∫c tr·∫≠n ƒë·∫•u (d√πng cho test, l·ªói, v.v.)
# ===========================================================================
func end_duel(room_id, winner, reason = WIN_REASON_FORFEIT):
	if not active_duels.has(room_id):
		return
	var game_state = active_duels[room_id]
	game_state["winner"] = winner
	game_state["win_reason"] = reason
	game_state["status"] = "finished"
	print("üèÅ Tr·∫≠n '%s' k·∫øt th√∫c. Ng∆∞·ªùi th·∫Øng: %s | L√Ω do: %s" % [room_id, winner, reason])


# ===========================================================================
# H√ÄM X·ª¨ L√ù H√ÄNH ƒê·ªòNG
# ===========================================================================
func _process_action(game_state, action):
	var player_id = action["player_id"]
	var result = {
		"success": false,
		"events": [],
		"errors": []
	}
	
	match action["type"]:
		"DRAW_CARD":
			result = _action_draw_card(game_state, player_id)
		"PLAY_MONSTER":
			result = _action_play_monster(game_state, player_id, action["payload"])
		"SET_MONSTER":
			result = _action_set_monster(game_state, player_id, action["payload"])
		"PLAY_SPELL", "SET_SPELL":
			result = _action_play_spell(game_state, player_id, action["payload"], action["type"] == "SET_SPELL")
		"PLAY_TRAP", "SET_TRAP":
			result = _action_play_trap(game_state, player_id, action["payload"], action["type"] == "SET_TRAP")
		"END_TURN":
			result = _action_end_turn(game_state, player_id)
		"SURRENDER":
			result = _action_surrender(game_state, player_id)
		"CHANGE_POSITION":
			result = _action_change_position(game_state, player_id, action["payload"])
		"ACTIVATE_EFFECT":
			result = _action_activate_effect(game_state, player_id, action["payload"])
		"DECLARE_ATTACK":
			result = _action_declare_attack(game_state, player_id, action["payload"])
		"END_PHASE":
			result = _action_end_phase(game_state, player_id)
		_:
			result["errors"].append("UNKNOWN_ACTION")
	
	if result["success"]:
		print("‚úÖ Action: %s | Player: %s" % [action["type"], player_id])
	else:
		var error_msg = result["errors"][0] if len(result["errors"]) > 0 else "Unknown"
		print("‚ùå Action failed: %s | Error: %s" % [action["type"], error_msg])
	
	return result


# ===========================================================================
# C√ÅC H√ÄM H√ÄNH ƒê·ªòNG CHI TI·∫æT
# ===========================================================================
func _action_draw_card(game_state, player_id):
	var player = game_state["players"][player_id]
	if game_state["phase"] != "draw":
		return _error(ERR_NOT_IN_DRAW_PHASE)
	if game_state["is_first_turn"] and player_id == game_state["first_player"]:
		return _error(ERR_NO_DRAW_FIRST_TURN)
	if player["deck"].empty():
		return _error(ERR_DECK_EMPTY)
	
	var card = player["deck"].pop_front()
	player["hand"].append(card)
	
	return {
		"success": true,
		"events": [
			{ "type": "DRAW_CARD", "card_id": card, "player": player_id }
		]
	}

func _action_play_monster(game_state, player_id, payload):
	var player = game_state["players"][player_id]
	var card_id = payload["card_id"]
	var to_zone = payload["to_zone"]
	var position = payload.get("position", "face_up_attack")

	if not player["hand"].has(card_id):
		return _error(ERR_CARD_NOT_IN_HAND)
	if to_zone < 0 or to_zone >= 5 or player["monster_zones"][to_zone] != null:
		return _error(ERR_ZONE_OCCUPIED)
	if not game_state["phase"] in ["main1", "main2"]:
		return _error(ERR_NOT_IN_MAIN_PHASE)
	if CardDatabase.get(card_id).get("type") != "monster":
		return _error(ERR_NOT_MONSTER_CARD)

	player["hand"].erase(card_id)
	player["monster_zones"][to_zone] = {
		"card_id": card_id,
		"position": position,
		"status": "summoned_this_turn",
		"attacked_this_turn": false
	}

	return {
		"success": true,
		"events": [
			{ "type": "SUMMON", "card_id": card_id, "player": player_id, "zone": to_zone }
		]
	}

func _action_set_monster(game_state, player_id, payload):
	var player = game_state["players"][player_id]
	var card_id = payload["card_id"]
	var to_zone = payload["to_zone"]

	if not player["hand"].has(card_id):
		return _error(ERR_CARD_NOT_IN_HAND)
	if to_zone < 0 or to_zone >= 5 or player["monster_zones"][to_zone] != null:
		return _error(ERR_ZONE_OCCUPIED)
	if not game_state["phase"] in ["main1", "main2"]:
		return _error(ERR_NOT_IN_MAIN_PHASE)
	if CardDatabase.get(card_id).get("type") != "monster":
		return _error(ERR_NOT_MONSTER_CARD)

	player["hand"].erase(card_id)
	player["monster_zones"][to_zone] = {
		"card_id": card_id,
		"position": "face_down_defense",
		"status": "set_this_turn",
		"attacked_this_turn": false
	}

	return {
		"success": true,
		"events": [
			{ "type": "SET_MONSTER", "card_id": card_id, "player": player_id, "zone": to_zone }
		]
	}

func _action_play_spell(game_state, player_id, payload, is_set):
	var player = game_state["players"][player_id]
	var card_id = payload["card_id"]
	var to_zone = payload["to_zone"]

	if not player["hand"].has(card_id):
		return _error(ERR_CARD_NOT_IN_HAND)
	if to_zone < 0 or to_zone >= 5 or player["spell_trap_zones"][to_zone] != null:
		return _error(ERR_SPELL_ZONE_OCCUPIED)
	if not game_state["phase"] in ["main1", "main2"]:
		return _error(ERR_NOT_IN_MAIN_PHASE)
	if CardDatabase.get(card_id).get("type") != "spell":
		return _error(ERR_NOT_SPELL_CARD)

	player["hand"].erase(card_id)
	var status = "face_down" if is_set else "face_up"
	player["spell_trap_zones"][to_zone] = {
		"card_id": card_id,
		"status": status
	}

	var event_type = "SET_SPELL" if is_set else "PLAY_SPELL"

	return {
		"success": true,
		"events": [
			{ "type": event_type, "card_id": card_id, "player": player_id, "zone": to_zone }
		]
	}

func _action_play_trap(game_state, player_id, payload, is_set):
	var player = game_state["players"][player_id]
	var card_id = payload["card_id"]
	var to_zone = payload["to_zone"]

	if not player["hand"].has(card_id):
		return _error(ERR_CARD_NOT_IN_HAND)
	if to_zone < 0 or to_zone >= 5 or player["spell_trap_zones"][to_zone] != null:
		return _error(ERR_TRAP_ZONE_OCCUPIED)
	if CardDatabase.get(card_id).get("type") != "trap":
		return _error(ERR_NOT_TRAP_CARD)

	player["hand"].erase(card_id)
	var status = "face_down" if is_set else "face_up"
	player["spell_trap_zones"][to_zone] = {
		"card_id": card_id,
		"status": status
	}

	var event_type = "SET_TRAP" if is_set else "ACTIVATE_TRAP"

	return {
		"success": true,
		"events": [
			{ "type": event_type, "card_id": card_id, "player": player_id, "zone": to_zone }
		]
	}

func _action_end_turn(game_state, player_id):
	if game_state["turn"] != player_id:
		return _error(ERR_NOT_YOUR_TURN)
	
	_reset_turn_flags(game_state["players"][player_id])
	game_state["turn"] = _get_opponent_id(game_state, player_id)
	game_state["phase"] = "draw"
	game_state["current_turn_count"] += 1
	game_state["is_first_turn"] = false
	game_state["chain"] = []
	game_state["chain_trigger"] = null

	return {
		"success": true,
		"events": [
			{ "type": "TURN_CHANGED", "next_player": game_state["turn"] }
		]
	}

func _action_surrender(game_state, player_id):
	var opponent_id = _get_opponent_id(game_state, player_id)
	game_state["winner"] = opponent_id
	game_state["win_reason"] = WIN_REASON_SURRENDER
	game_state["status"] = "finished"

	return {
		"success": true,
		"events": [
			{ "type": "WIN", "winner": opponent_id, "reason": WIN_REASON_SURRENDER }
		]
	}

func _action_change_position(game_state, player_id, payload):
	var player = game_state["players"][player_id]
	var zone_idx = payload["zone"]
	var to_position = payload["to_position"]  # e.g., "face_up_attack", "face_up_defense", "face_down_defense"

	if zone_idx < 0 or zone_idx >= 5 or player["monster_zones"][zone_idx] == null:
		return _error(ERR_INVALID_ZONE)
	var card_obj = player["monster_zones"][zone_idx]
	if card_obj.get("status") in ["summoned_this_turn", "set_this_turn"]:
		return _error(ERR_CANNOT_CHANGE_POS_THIS_TURN)
	if card_obj["position"] == to_position:
		return _error(ERR_SAME_POSITION)

	# Validate position
	if not to_position in ["face_up_attack", "face_up_defense", "face_down_defense"]:
		return _error("INVALID_POSITION")
	
	card_obj["position"] = to_position
	if to_position == "face_up_defense" and card_obj["position"] == "face_down_defense":
		# Flip summon
		return {
			"success": true,
			"events": [
				{ "type": "FLIP_SUMMON", "card_id": card_obj["card_id"], "zone": zone_idx, "player": player_id }
			]
		}

	return {
		"success": true,
		"events": [
			{ "type": "CHANGE_POSITION", "zone": zone_idx, "to_position": to_position, "player": player_id }
		]
	}

# ===========================================================================
# _action_activate_effect(game_state, player_id, payload)
# K√≠ch ho·∫°t hi·ªáu ·ª©ng c·ªßa qu√°i, spell, trap ‚Üí th√™m v√†o chain
# ===========================================================================
func _action_activate_effect(game_state, player_id, payload):
	var card_id = payload["card_id"]
	var zone_type = payload.get("zone_type", "spell_trap")
	var player = game_state["players"][player_id]
	
	# T√¨m v·ªã tr√≠
	var zone_idx = -1
	var zones = player["spell_trap_zones"] if zone_type == "spell_trap" else player["monster_zones"]
	for i in range(5):
		if zones[i] and zones[i].card_id == card_id:
			zone_idx = i
			break
	if zone_idx == -1:
		return _error(ERR_CARD_NOT_ON_FIELD)

	# Ki·ªÉm tra ƒëi·ªÅu ki·ªán
	if zone_type == "spell_trap" and zones[zone_idx].status != "face_up":
		return _error("CARD_NOT_ACTIVATABLE")
	if zone_type == "monster":
		var card_data = CardDatabase.get(card_id)
		if not card_data.has("effect") or card_data["effect"] == "":
			return _error(ERR_NO_EFFECT)
		# ‚úÖ Ki·ªÉm tra: SUIJIN ch·ªâ k√≠ch ho·∫°t khi c√≥ t·∫•n c√¥ng
		if card_id == "SUIJIN" and (not game_state["chain_trigger"] or game_state["chain_trigger"].get("type") != "ATTACK_DECLARED"):
			return _error("EFFECT_CANNOT_ACTIVATE_NOW")

	# Th√™m v√†o chain
	game_state["chain"].append({
		"card_id": card_id,
		"player_id": player_id,
		"zone_type": zone_type,
		"zone_idx": zone_idx
	})

	return {
		"success": true,
		"events": [
			{"type": "ACTIVATE_EFFECT", "card_id": card_id, "player": player_id}
		]
	}


func _action_declare_attack(game_state, player_id, payload):
	var player = game_state["players"][player_id]
	var opponent_id = _get_opponent_id(game_state, player_id)
	var opponent = game_state["players"][opponent_id]
	var atk_zone = payload["atk_zone"]
	var target_zone = payload.get("target_zone", -1)

	if game_state["phase"] != "battle":
		return _error(ERR_NOT_IN_BATTLE_PHASE)
	if atk_zone < 0 or atk_zone >= 5 or player["monster_zones"][atk_zone] == null:
		return _error(ERR_INVALID_ATTACKER)
	var attacker = player["monster_zones"][atk_zone]
	if attacker.position != "face_up_attack":
		return _error(ERR_NOT_IN_ATTACK_POSITION)
	if attacker.get("attacked_this_turn", false):
		return _error(ERR_ALREADY_ATTACKED)
	if attacker.get("status") == "summoned_this_turn":
		return _error(ERR_CANNOT_ATTACK_SUMMON_TURN)

	var events = []
	var atk = CardDatabase.get(attacker.card_id).get("atk", 0)

	# K√≠ch ho·∫°t chain cho attack
	game_state["chain_trigger"] = {"type": "ATTACK_DECLARED", "attacker_zone": atk_zone, "player_id": player_id}
	events.append({"type": "ATTACK_DECLARED", "attacker": attacker.card_id, "zone": atk_zone})

	if target_zone == -1:
		# Direct attack
		var has_monster = false
		for zone in opponent["monster_zones"]:
			if zone != null:
				has_monster = true
				break
		if has_monster:
			return _error(ERR_CANNOT_DIRECT_ATTACK)
		opponent["life_points"] = max(0, opponent["life_points"] - atk)
		events.append({"type": "DIRECT_ATTACK", "attacker": attacker.card_id, "damage": atk})
	else:
		if target_zone < 0 or target_zone >= 5 or opponent["monster_zones"][target_zone] == null:
			return _error(ERR_INVALID_TARGET)
		var target = opponent["monster_zones"][target_zone]
		var target_pos = target.position
		# ‚úÖ S·ª¨A: D√πng find() thay v√¨ contains()
		var is_defense = target_pos.find("defense") != -1
		var target_val = CardDatabase.get(target.card_id).get("def", 0) if is_defense else CardDatabase.get(target.card_id).get("atk", 0)

		# Flip if face down
		if target_pos == "face_down_defense":
			target.position = "face_up_defense"
			events.append({"type": "FLIP", "card_id": target.card_id})

		if atk > target_val:
			var damage = atk - target_val
			if is_defense:
				damage = 0
			else:
				opponent["life_points"] = max(0, opponent["life_points"] - damage)
			opponent["monster_zones"][target_zone] = null
			opponent["graveyard"].append(target.card_id)
			events.append({"type": "DESTROY_TARGET", "damage": damage})
		elif atk == target_val:
			if not is_defense:
				player["monster_zones"][atk_zone] = null
				player["graveyard"].append(attacker.card_id)
			opponent["monster_zones"][target_zone] = null
			opponent["graveyard"].append(target.card_id)
			events.append({"type": "DESTROY_BOTH"})
		else:
			var damage = target_val - atk
			player["life_points"] = max(0, player["life_points"] - damage)
			if not is_defense:
				player["monster_zones"][atk_zone] = null
				player["graveyard"].append(attacker.card_id)
			events.append({"type": "REBOUND", "damage": damage})

	attacker.attacked_this_turn = true
	return {"success": true, "events": events}

func _action_end_phase(game_state, player_id):
	if game_state["turn"] != player_id:
		return _error(ERR_NOT_YOUR_TURN)
	var idx = TURN_PHASES.find(game_state["phase"])
	if idx == -1 or idx >= len(TURN_PHASES) - 1:
		return _error(ERR_INVALID_PHASE)
	game_state["phase"] = TURN_PHASES[idx + 1]
	var events = [{"type": "PHASE_CHANGED", "new_phase": game_state["phase"]}]
	
	if game_state["phase"] == "end":
		var player = game_state["players"][player_id]
		if len(player["hand"]) > game_state["rules"].max_hand_size:
			var discard_count = len(player["hand"]) - game_state["rules"].max_hand_size
			for i in range(discard_count):
				var card = player["hand"].pop_back()
				player["graveyard"].append(card)
			events.append({"type": "DISCARD_HAND", "count": discard_count})
	
	return {"success": true, "events": events}


# ===========================================================================
# H√ÄM H·ªñ TR·ª¢
# ===========================================================================
func _create_player_state(player_id, deck, hand, lp):
	return {
		"player_id": player_id,
		"life_points": lp,
		"deck": deck,
		"hand": hand,
		"graveyard": [],
		"banished": [],
		"extra_deck": [],
		"monster_zones": [null, null, null, null, null],
		"spell_trap_zones": [null, null, null, null, null],
		"field_zone": null,
		"pendulum_zones": [null, null]
	}

func _shuffle(array):
	var n = len(array)
	for i in range(n - 1, 0, -1):
		var j = randi() % (i + 1)
		var temp = array[i]
		array[i] = array[j]
		array[j] = temp
	return array

func _draw_cards(deck, count):
	var cards = []
	for i in range(min(count, len(deck))):
		cards.append(deck.pop_front())
	return cards

func _can_activate_effect_out_of_turn(game_state, action):
	if action["type"] != "ACTIVATE_EFFECT":
		return false
	var card_id = action["payload"]["card_id"]
	var card_data = CardDatabase.get(card_id)
	return card_data.get("type") == "trap" or card_data.get("effect") in ["quick_effect"]  # M·ªü r·ªông sau

func _get_opponent_id(game_state, player_id):
	for pid in game_state["players"]:
		if pid != player_id:
			return pid
	return null

func _update_phase_if_needed(game_state):
	if game_state["phase"] == "draw" and game_state["chain"].empty():
		if not (game_state["is_first_turn"] and game_state["turn"] == game_state["first_player"]):
			var player = game_state["players"][game_state["turn"]]
			if not player["deck"].empty():
				var card = player["deck"].pop_front()
				player["hand"].append(card)
				print("Auto draw: %s" % card)
		game_state["phase"] = "standby"

func _get_available_actions(game_state, player_id):
	var actions = []
	var phase = game_state["phase"]
	var player = game_state["players"][player_id]
	var opponent_id = _get_opponent_id(game_state, player_id)
	
	var action_details = []
	if game_state["turn"] == player_id:
		action_details += [
			{"type": "END_PHASE"},
			{"type": "END_TURN"},
			{"type": "SURRENDER"}
		]
	
	if phase == "draw" and game_state["turn"] == player_id:
		if not (game_state["is_first_turn"] and player_id == game_state["first_player"]):
			action_details.append({"type": "DRAW_CARD"})
	
	if phase in ["main1", "main2"] and game_state["turn"] == player_id:
		for card_id in player["hand"]:
			var card_data = CardDatabase.get(card_id)
			var card_type = card_data.get("type", "")
			for i in range(5):
				if card_type == "monster" and player["monster_zones"][i] == null:
					action_details.append({
						"type": "PLAY_MONSTER",
						"payload": {"card_id": card_id, "to_zone": i, "position": "face_up_attack"}
					})
					action_details.append({
						"type": "SET_MONSTER",
						"payload": {"card_id": card_id, "to_zone": i}
					})
				elif card_type == "spell" and player["spell_trap_zones"][i] == null:
					action_details.append({
						"type": "PLAY_SPELL",
						"payload": {"card_id": card_id, "to_zone": i}
					})
					action_details.append({
						"type": "SET_SPELL",
						"payload": {"card_id": card_id, "to_zone": i}
					})
				elif card_type == "trap" and player["spell_trap_zones"][i] == null:
					action_details.append({
						"type": "PLAY_TRAP",
						"payload": {"card_id": card_id, "to_zone": i}
					})
					action_details.append({
						"type": "SET_TRAP",
						"payload": {"card_id": card_id, "to_zone": i}
					})
		for i in range(5):
			if player["monster_zones"][i] and not player["monster_zones"][i].get("status") in ["summoned_this_turn", "set_this_turn"]:
				for pos in ["face_up_attack", "face_up_defense", "face_down_defense"]:
					if pos != player["monster_zones"][i].position:
						action_details.append({
							"type": "CHANGE_POSITION",
							"payload": {"zone": i, "to_position": pos}
						})
			if player["monster_zones"][i] and CardDatabase.get(player["monster_zones"][i].card_id).get("effect") != "":
				action_details.append({
					"type": "ACTIVATE_EFFECT",
					"payload": {"card_id": player["monster_zones"][i].card_id, "zone_type": "monster"}
				})
			if player["spell_trap_zones"][i] and player["spell_trap_zones"][i].status == "face_up" and CardDatabase.get(player["spell_trap_zones"][i].card_id).get("effect") != "":
				action_details.append({
					"type": "ACTIVATE_EFFECT",
					"payload": {"card_id": player["spell_trap_zones"][i].card_id, "zone_type": "spell_trap"}
				})
	
	if phase == "battle" and game_state["turn"] == player_id:
		for i in range(5):
			if player["monster_zones"][i] and player["monster_zones"][i].position == "face_up_attack" and not player["monster_zones"][i].get("attacked_this_turn", false) and not player["monster_zones"][i].get("status") == "summoned_this_turn":
				var has_monster = false
				for j in range(5):
					if game_state["players"][opponent_id].monster_zones[j]:
						has_monster = true
						action_details.append({
							"type": "DECLARE_ATTACK",
							"payload": {"atk_zone": i, "target_zone": j}
						})
				if not has_monster:
					action_details.append({
						"type": "DECLARE_ATTACK",
						"payload": {"atk_zone": i}
					})
	
	# Th√™m h√†nh ƒë·ªông cho chain
	if not game_state["chain"].empty() and game_state["turn"] != player_id:
		for i in range(5):
			var card = player["spell_trap_zones"][i]
			if card and card["status"] == "face_down" and CardDatabase.get(card["card_id"]).get("type") == "trap":
				action_details.append({
					"type": "ACTIVATE_EFFECT",
					"payload": {"card_id": card["card_id"], "zone_type": "spell_trap"}
				})
	
	# Ch·ªâ l·∫•y type ƒë·ªÉ tr√°nh payload ascendedpayload d√†i
	for action in action_details:
		if not action["type"] in actions:
			actions.append(action["type"])
	
	return {"types": actions, "details": action_details}

func _resolve_chain(game_state, action):
	if game_state["chain"].empty():
		return
	
	# Resolve chain theo th·ª© t·ª± ng∆∞·ª£c
	var events = []
	for chain_link in game_state["chain"]:
		var card_id = chain_link["card_id"]
		var player_id = chain_link["player_id"]
		var zone_type = chain_link["zone_type"]
		var zone_idx = chain_link["zone_idx"]
		var player = game_state["players"][player_id]
		var opponent_id = _get_opponent_id(game_state, player_id)
		var opponent = game_state["players"][opponent_id]
		
		var resolve_result = _resolve_effect(game_state, card_id, player, opponent, zone_type, zone_idx)
		events += resolve_result.events
		if not resolve_result.success:
			return resolve_result
	
	game_state["chain"] = []
	game_state["chain_trigger"] = null
	return {"success": true, "events": events}

func _resolve_effect(game_state, card_id, player, opponent, zone_type, zone_idx):
	var effect = CardDatabase.get(card_id).get("effect", "")
	var events = []
	
	match effect:
		"draw_2":
			var drawn = _draw_cards(player["deck"], 2)
			player["hand"] += drawn
			events.append({"type": "DRAW_EFFECT", "cards": drawn, "player": player["player_id"]})
		"special_summon_graveyard":
			if player["graveyard"].empty():
				return _error("NO_CARDS_IN_GRAVEYARD")
			var summon_card = player["graveyard"].pop_back()
			var free_zone = -1
			for i in range(5):
				if player["monster_zones"][i] == null:
					free_zone = i
					break
			if free_zone == -1:
				return _error(ERR_ZONE_OCCUPIED)
			player["monster_zones"][free_zone] = {
				"card_id": summon_card,
				"position": "face_up_attack",
				"status": "summoned_this_turn",
				"attacked_this_turn": false
			}
			events.append({"type": "SPECIAL_SUMMON", "card_id": summon_card, "zone": free_zone})
		"destroy_all_monsters":
			for i in range(5):
				if player["monster_zones"][i]:
					player["graveyard"].append(player["monster_zones"][i].card_id)
					player["monster_zones"][i] = null
				if opponent["monster_zones"][i]:
					opponent["graveyard"].append(opponent["monster_zones"][i].card_id)
					opponent["monster_zones"][i] = null
			events.append({"type": "DESTROY_ALL_MONSTERS"})
		"destroy_all_attackers":
			for i in range(5):
				var zone = opponent["monster_zones"][i]
				if zone and zone.position.find("attack") != -1:
					opponent["graveyard"].append(zone.card_id)
					opponent["monster_zones"][i] = null
			events.append({"type": "DESTROY_MONSTERS", "player": opponent["player_id"]})
		"destroy_summoned_monster":
			var summoned = false
			for i in range(5):
				if opponent["monster_zones"][i] and opponent["monster_zones"][i].get("status") == "summoned_this_turn":
					opponent["graveyard"].append(opponent["monster_zones"][i].card_id)
					opponent["monster_zones"][i] = null
					summoned = true
					break
			if not summoned:
				return _error("NO_SUMMONED_MONSTER")
			events.append({"type": "DESTROY_MONSTER", "player": opponent["player_id"]})
		"reduce_atk_0":
			if game_state["chain_trigger"] and game_state["chain_trigger"].type == "ATTACK_DECLARED":
				var atk_zone = game_state["chain_trigger"].attacker_zone
				var atk_player = game_state["players"][game_state["chain_trigger"].player_id]
				if atk_player.monster_zones[atk_zone]:
					atk_player.monster_zones[atk_zone].atk_modifier = 0
					events.append({"type": "ATK_MODIFIED", "card_id": atk_player.monster_zones[atk_zone].card_id, "new_atk": 0})
		_:
			return _error(ERR_NO_EFFECT)
	
	# X√≥a card spell/trap sau khi activate (tr·ª´ continuous)
	if zone_type == "spell_trap" and not effect in ["continuous_effect"]:
		player["spell_trap_zones"][zone_idx] = null
		player["graveyard"].append(card_id)
	
	return {"success": true, "events": events}

func _check_win_condition(game_state):
	for pid in game_state["players"]:
		var p = game_state["players"][pid]
		if p.life_points <= 0:
			return {"winner": _get_opponent_id(game_state, pid), "reason": WIN_REASON_LP_ZERO}
		if len(p.deck) == 0 and game_state["phase"] == "draw":
			return {"winner": _get_opponent_id(game_state, pid), "reason": WIN_REASON_DECK_OUT}
		var exodia_pieces = ["EXODIA_HEAD", "LEFT_ARM", "RIGHT_ARM", "LEFT_LEG", "RIGHT_LEG"]
		var has_all_exodia = true
		for piece in exodia_pieces:
			if not piece in p.hand:
				has_all_exodia = false
				break
		if has_all_exodia:
			return {"winner": pid, "reason": WIN_REASON_EXODIA}
	return {"winner": null, "reason": null}

func _reset_turn_flags(player):
	for i in range(5):
		if player["monster_zones"][i]:
			player["monster_zones"][i].erase("status")
			player["monster_zones"][i].erase("attacked_this_turn")
			player["monster_zones"][i].erase("atk_modifier")

func _error(reason):
	return {
		"success": false,
		"errors": [reason],
		"events": [],
		"available_actions": []
	}




================================================================================

--- FILE: server_yugiDuel\autoload\CardDatabase.gd ---
# ===========================================================================
# CardDatabase.gd - N·∫°p v√† qu·∫£n l√Ω to√†n b·ªô d·ªØ li·ªáu b√†i Yu-Gi-Oh!
# Autoload Singleton - D√πng ƒë·ªÉ truy v·∫•n th√¥ng tin b√†i
# ===========================================================================

extends Node

# L∆∞u to√†n b·ªô d·ªØ li·ªáu b√†i: card_id ‚Üí card_data
var cards = {}

# Signal ƒë·ªÉ th√¥ng b√°o l·ªói cho bot ho·∫∑c debug
signal card_database_error(error_code, message)

# Error codes
const ERR_FILE_NOT_FOUND = "FILE_NOT_FOUND"
const ERR_JSON_INVALID = "JSON_INVALID"
const ERR_CARD_INVALID = "CARD_INVALID"
const ERR_CARD_NOT_FOUND = "CARD_NOT_FOUND"
const PATH_CARDS = "res://data/cards.json"

# ===========================================================================
# _ready()
# T·ª± ƒë·ªông n·∫°p file JSON khi game kh·ªüi ƒë·ªông
# ===========================================================================
func _ready():
	randomize()  # C·∫ßn cho randi()
	var error = _load_cards(PATH_CARDS)
	if error:
		emit_signal("card_database_error", error[0], error[1])
		push_error("‚ùå CardDatabase: Kh√¥ng th·ªÉ n·∫°p cards.json - %s" % error[1])
	else:
		print("‚úÖ CardDatabase: ƒê√£ n·∫°p %d l√° b√†i." % cards.size())


# ===========================================================================
# _load_cards(path)
# N·∫°p file JSON v√† l∆∞u v√†o b·ªô nh·ªõ
# Tr·∫£ v·ªÅ [error_code, message] n·∫øu c√≥ l·ªói, null n·∫øu th√†nh c√¥ng
# ===========================================================================
func _load_cards(path):
	if not File.new().file_exists(path):
		return [ERR_FILE_NOT_FOUND, "File kh√¥ng t·ªìn t·∫°i: %s" % path]

	var file = File.new()
	var err = file.open(path, File.READ)
	if err != OK:
		return [ERR_FILE_NOT_FOUND, "Kh√¥ng th·ªÉ m·ªü file: %s (m√£ l·ªói: %d)" % [path, err]]

	var json_data = file.get_as_text()
	file.close()

	if json_data.empty():
		return [ERR_JSON_INVALID, "File JSON r·ªóng: %s" % path]

	var parse_result = JSON.parse(json_data)
	if parse_result.error != OK:
		return [ERR_JSON_INVALID, "L·ªói parse JSON t·∫°i d√≤ng %d: %s" % [parse_result.error_line, parse_result.error_string]]

	var data = parse_result.result
	if typeof(data) != TYPE_DICTIONARY:
		return [ERR_JSON_INVALID, "JSON kh√¥ng ph·∫£i object: %s" % path]

	# Validate v√† g√°n
	cards = {}
	for card_id in data:
		var card = data[card_id]
		var error = _validate_card(card_id, card)
		if error:
			print("card ko hop le: %s | %s"% [card_id, error])
			emit_signal("card_database_error", ERR_CARD_INVALID, "Card %s kh√¥ng h·ª£p l·ªá: %s" % [card_id, error])
			continue
		cards[card_id] = card

	return null


# ===========================================================================
# _validate_card(card_id, card)
# Ki·ªÉm tra d·ªØ li·ªáu l√° b√†i h·ª£p l·ªá
# Tr·∫£ v·ªÅ null n·∫øu ok, ho·∫∑c string m√¥ t·∫£ l·ªói
# ===========================================================================

#json parse tr·∫£ v·ªÅ type_real ko ph·∫£i type INT
func _validate_card(card_id, card):
	if not card is Dictionary:
		return "Kh√¥ng ph·∫£i dictionary"

	# T·ª± ƒë·ªông ƒëi·ªÅn ID n·∫øu thi·∫øu
	if not card.has("id") or card["id"] != card_id:
		card["id"] = card_id  # T·ª± s·ª≠a

	if not card.has("name"):
		push_warning("Card %s thi·∫øu 'name'" % card_id)
		card["name"] = card_id

	if not card.has("type") or not card["type"]  in ["monster", "spell", "trap"]:
		return "Thi·∫øu ho·∫∑c type kh√¥ng h·ª£p l·ªá: %s" % card.get("type", "missing")

	if card["type"] == "monster":
		# Ki·ªÉm tra atk
		if not card.has("atk"):
			return "Monster thi·∫øu atk"
		var atk = card["atk"]
		if typeof(atk) != TYPE_INT and typeof(atk) != TYPE_REAL:
			return "atk ph·∫£i l√† s·ªë (hi·ªán t·∫°i: %s, ki·ªÉu: %s)" % [str(atk), typeof(atk)]
		if int(atk) < 0:
			return "atk kh√¥ng ƒë∆∞·ª£c √¢m"
		card["atk"] = int(atk)

		# Ki·ªÉm tra def
		if not card.has("def"):
			return "Monster thi·∫øu def"
		var def_val = card["def"]
		if typeof(def_val) != TYPE_INT and typeof(def_val) != TYPE_REAL:
			return "def ph·∫£i l√† s·ªë"
		if int(def_val) < 0:
			return "def kh√¥ng ƒë∆∞·ª£c √¢m"
		card["def"] = int(def_val)

	if card["type"] in ["spell", "trap"]:
		if not card.has("effect"):
			push_warning("Card %s thi·∫øu 'effect'" % card_id)
			card["effect"] = ""

	return null


# ===========================================================================
# get(card_id) ‚Üí Dictionary
# L·∫•y d·ªØ li·ªáu l√° b√†i theo ID
# Tr·∫£ v·ªÅ {} n·∫øu kh√¥ng t√¨m th·∫•y
# ===========================================================================
func get(card_id):
	if cards.has(card_id):
		return cards[card_id].duplicate()  # Tr·∫£ b·∫£n sao
	else:
		emit_signal("card_database_error", ERR_CARD_NOT_FOUND, "Kh√¥ng t√¨m th·∫•y b√†i v·ªõi ID '%s'" % card_id)
		return {}


# ===========================================================================
# exists(card_id) ‚Üí bool
# Ki·ªÉm tra b√†i c√≥ t·ªìn t·∫°i kh√¥ng
# ===========================================================================
func exists(card_id):
	return cards.has(card_id)


# ===========================================================================
# find_by_name(name) ‚Üí Array[card]
# T√¨m b√†i theo t√™n (ph·∫ßn trƒÉm tr√πng kh·ªõp - ƒë∆°n gi·∫£n)
# ===========================================================================
func find_by_name(name):
	name = name.to_lower()
	var results = []
	for card_id in cards:
		var card = cards[card_id]
		if str(card.get("name", "")).to_lower().find(name) != -1:
			results.append(card.duplicate())
	return results


# ===========================================================================
# get_cards_by_type(type) ‚Üí Array[card]
# L·∫•y t·∫•t c·∫£ b√†i theo type (monster, spell, trap)
# ===========================================================================
func get_cards_by_type(type):
	var results = []
	for card_id in cards:
		if cards[card_id].get("type") == type:
			results.append(cards[card_id].duplicate())
	return results


# ===========================================================================
# get_random_card(type=null) ‚Üí Dictionary
# L·∫•y ng·∫´u nhi√™n m·ªôt l√° b√†i, t√πy ch·ªçn l·ªçc theo type
# ===========================================================================
func get_random_card(type=null):
	var valid_cards = cards.keys()
	if type:
		var filtered_cards = []
		for id in valid_cards:
			if cards[id].get("type") == type:
				filtered_cards.append(id)
		valid_cards = filtered_cards
	if valid_cards.empty():
		return {}
	var card_id = valid_cards[randi() % valid_cards.size()]
	return cards[card_id].duplicate()


# ===========================================================================
# get_all() ‚Üí Dictionary
# Tr·∫£ v·ªÅ to√†n b·ªô c∆° s·ªü d·ªØ li·ªáu (d√πng cho debug)
# ===========================================================================
func get_all():
	return cards.duplicate(true)




================================================================================

--- FILE: server_yugiDuel\autoload\DatabaseManager.gd ---
# ===========================================================================
# DatabaseManager.gd - Qu·∫£n l√Ω d·ªØ li·ªáu ng∆∞·ªùi ch∆°i (Godot 3.6)
# Autoload Singleton
# Ch·ª©c nƒÉng:
#   - ƒêƒÉng k√Ω / ƒëƒÉng nh·∫≠p ng∆∞·ªùi ch∆°i
#   - L∆∞u deck, stats, l·ªãch s·ª≠
#   - D√πng JSON ƒë·ªÉ l∆∞u tr·ªØ ƒë∆°n gi·∫£n
# ===========================================================================
extends Node

const SAVE_PATH = "user://players.json"
var players_data = {}

# ===========================================================================
# _ready()
# N·∫°p d·ªØ li·ªáu ng∆∞·ªùi ch∆°i t·ª´ file
# ===========================================================================
func _ready():
	_load_players()
	randomize()  # ƒê·∫£m b·∫£o randi() ho·∫°t ƒë·ªông

# ===========================================================================
# _load_players()
# ƒê·ªçc file JSON, n·∫øu kh√¥ng c√≥ th√¨ t·∫°o m·ªõi
# ===========================================================================
func _load_players():
	if not File.new().file_exists(SAVE_PATH):
		players_data = {}
		print("üÜï T·∫°o file d·ªØ li·ªáu ng∆∞·ªùi ch∆°i m·ªõi.")
		return

	var file = File.new()
	if file.open(SAVE_PATH, File.READ) != OK:
		push_error("‚ùå Kh√¥ng th·ªÉ m·ªü file: %s" % SAVE_PATH)
		players_data = {}
		return

	var json_str = file.get_as_text()
	file.close()

	var parse = JSON.parse(json_str)
	if parse.error != OK:
		push_error("‚ùå L·ªói parse JSON: %s" % parse.error_string)
		players_data = {}
		return

	players_data = parse.result if typeof(parse.result) == TYPE_DICTIONARY else {}
	print("‚úÖ ƒê√£ n·∫°p d·ªØ li·ªáu %d ng∆∞·ªùi ch∆°i." % players_data.size())

# ===========================================================================
# _save_players()
# L∆∞u d·ªØ li·ªáu ng∆∞·ªùi ch∆°i xu·ªëng file
# ===========================================================================
func _save_players():
	var file = File.new()
	if file.open(SAVE_PATH, File.WRITE) != OK:
		push_error("‚ùå Kh√¥ng th·ªÉ ghi file: %s" % SAVE_PATH)
		return

	file.store_string(JSON.print(players_data))
	file.close()
	print("üíæ ƒê√£ l∆∞u d·ªØ li·ªáu ng∆∞·ªùi ch∆°i.")

# ===========================================================================
# register(username, password) ‚Üí Dict
# ƒêƒÉng k√Ω ng∆∞·ªùi ch∆°i m·ªõi
# ===========================================================================
func register(username, password):
	if players_data.has(username):
		return { "success": false, "error": "USERNAME_EXISTS" }

	players_data[username] = {
		"username": username,
		"password_hash": _hash_password(password),
		"created_at": OS.get_unix_time(),
		"last_login": 0,
		"lp": 8000,
		"deck": [
			"BLUE_EYES_WHITE_DRAGON", "DARK_MAGICIAN",
			"POT_OF_GREED", "MONSTER_REBORN", "MIRROR_FORCE",
			"GYOUKI", "SUMMONED_SKULL"
		],
		"stats": {
			"win": 0,
			"loss": 0,
			"draw": 0
		},
		"match_history": []
	}
	_save_players()
	return { "success": true, "player": players_data[username].duplicate() }

# ===========================================================================
# login(username, password) ‚Üí Dict
# X√°c th·ª±c ƒëƒÉng nh·∫≠p
# ===========================================================================
func login(username, password):
	if not players_data.has(username):
		return { "success": false, "error": "USER_NOT_FOUND" }

	var data = players_data[username]
	if data["password_hash"] != _hash_password(password):
		return { "success": false, "error": "INVALID_PASSWORD" }

	data["last_login"] = OS.get_unix_time()
	_save_players()

	return { "success": true, "player": data.duplicate() }

# ===========================================================================
# get_player(username) ‚Üí Dict
# L·∫•y th√¥ng tin ng∆∞·ªùi ch∆°i (kh√¥ng bao g·ªìm password)
# ===========================================================================
func get_player(username):
	if not players_data.has(username):
		return {}
	var p = players_data[username].duplicate()
	p.erase("password_hash")
	return p

# ===========================================================================
# update_stats(username, win, loss, draw)
# C·∫≠p nh·∫≠t th·ªëng k√™ sau tr·∫≠n ƒë·∫•u
# ===========================================================================
func update_stats(username, win=0, loss=0, draw=0):
	if not players_data.has(username):
		return
	players_data[username]["stats"]["win"] += win
	players_data[username]["stats"]["loss"] += loss
	players_data[username]["stats"]["draw"] += draw
	_save_players()

# ===========================================================================
# add_match_history(username, opponent, result, room_id)
# Th√™m l·ªãch s·ª≠ tr·∫≠n ƒë·∫•u
# ===========================================================================
func add_match_history(username, opponent, result, room_id):
	if not players_data.has(username):
		return
	players_data[username]["match_history"].append({
		"opponent": opponent,
		"result": result,  # "win", "loss", "draw"
		"room_id": room_id,
		"timestamp": OS.get_unix_time()
	})
	_save_players()

# ===========================================================================
# get_deck(username) ‚Üí Array
# L·∫•y b·ªô b√†i c·ªßa ng∆∞·ªùi ch∆°i
# ===========================================================================
func get_deck(username):
	return players_data.get(username, {}).get("deck", [
		"BLUE_EYES_WHITE_DRAGON", "DARK_MAGICIAN",
		"POT_OF_GREED", "MONSTER_REBORN", "MIRROR_FORCE"
	])

# ===========================================================================
# _hash_password(password) ‚Üí String
# Hash ƒë∆°n gi·∫£n (kh√¥ng d√πng MD5 th·∫≠t, ch·ªâ m√¥ ph·ªèng)
# ===========================================================================
func _hash_password(password):
	var hash_ = 5381
	for c in password.to_ascii():
		hash_ = (hash_ * 33) + c
	return str(hash_)

# ===========================================================================
# create_guest() ‚Üí Dict
# T·∫°o ng∆∞·ªùi ch∆°i t·∫°m (guest)
# ===========================================================================
func create_guest():
	var guest_id = "guest_%d" % (OS.get_unix_time() % 10000)
	var deck = [
		"GYOUKI", "SUMMONED_SKULL", "POT_OF_GREED",
		"TRAP_HOLE", "SUIJIN", "DARK_MAGICIAN"
	]
	players_data[guest_id] = {
		"username": guest_id,
		"password_hash": "",
		"created_at": OS.get_unix_time(),
		"last_login": OS.get_unix_time(),
		"lp": 8000,
		"deck": deck,
		"stats": { "win": 0, "loss": 0, "draw": 0 },
		"match_history": [],
		"is_guest": true
	}
	_save_players()
	return { "success": true, "player": players_data[guest_id].duplicate() }

================================================================================

--- FILE: server_yugiDuel\autoload\GameManager.gd ---
# ===========================================================================
# GameManager.gd - Qu·∫£n l√Ω v√≤ng ƒë·ªùi tr·∫≠n ƒë·∫•u
# Kh√¥ng x·ª≠ l√Ω m·∫°ng, ch·ªâ d√πng BattleCore v√† DatabaseManager
# ===========================================================================
extends Node

# Danh s√°ch tr·∫≠n ƒë·∫•u: room_id ‚Üí { player_a, player_b, status, ... }
var active_games = {}

# Tham chi·∫øu
onready var database_manager = DatabaseManager
onready var battle_core = BattleCore

# Signal
signal game_started(room_id, player_a, player_b)
signal game_finished(room_id, winner, reason)
signal game_event(room_id, events)  # ‚úÖ Th√™m signal ƒë·ªÉ th√¥ng b√°o event t·ª´ bot

# ===========================================================================
# create_duel(player_a_id, player_b_id)
# T·∫°o tr·∫≠n ƒë·∫•u m·ªõi (PvP 1v1)
# ===========================================================================
func create_duel(player_a_id, player_b_id):
	var deck_a = database_manager.get_deck(player_a_id)
	var deck_b = database_manager.get_deck(player_b_id)
	var rules = { "start_lp": 8000, "max_hand_size": 6 }

	var room_id = battle_core.start_duel(player_a_id, player_b_id, deck_a, deck_b, rules)
	if typeof(room_id) != TYPE_STRING:
		return { "success": false, "error": "FAILED_TO_CREATE_DUEL" }

	active_games[room_id] = {
		"player_a": player_a_id,
		"player_b": player_b_id,
		"room_id": room_id,
		"status": "started",
		"start_time": OS.get_unix_time(),
		"mode": "pvp_1v1"
	}

	emit_signal("game_started", room_id, player_a_id, player_b_id)
	print("üéÆ GameManager: Tr·∫≠n PvP '%s' ƒë√£ t·∫°o gi·ªØa %s v√† %s" % [room_id, player_a_id, player_b_id])
	return { "success": true, "room_id": room_id }

# ===========================================================================
# submit_action(room_id, action)
# G·ª≠i h√†nh ƒë·ªông ƒë·∫øn BattleCore
# ===========================================================================
func submit_action(room_id, action):
	if not active_games.has(room_id):
		return { "success": false, "error": "GAME_NOT_FOUND" }
	return battle_core.submit_action(room_id, action)

# ===========================================================================
# get_game_state(room_id, player_id)
# L·∫•y tr·∫°ng th√°i tr·∫≠n (·∫©n b√†i ƒë·ªëi th·ªß)
# ===========================================================================
func get_game_state(room_id, player_id):
	return battle_core.get_game_state(room_id, player_id)

# ===========================================================================
# end_game(room_id, winner, reason)
# K·∫øt th√∫c tr·∫≠n, c·∫≠p nh·∫≠t stats
# ===========================================================================
func end_game(room_id, winner, reason):
	if not active_games.has(room_id):
		return

	var game = active_games[room_id]
	var player_a = game["player_a"]
	var player_b = game["player_b"]

	# C·∫≠p nh·∫≠t stats
	if winner == player_a:
		database_manager.update_stats(player_a, 1)
		database_manager.update_stats(player_b, 1)
		database_manager.add_match_history(player_a, player_b, "win", room_id)
		database_manager.add_match_history(player_b, player_a, "loss", room_id)
	elif winner == player_b:
		database_manager.update_stats(player_b, 1)
		database_manager.update_stats(player_a, 1)
		database_manager.add_match_history(player_b, player_a, "win", room_id)
		database_manager.add_match_history(player_a, player_b, "loss", room_id)

	# D·ªçn d·∫πp
	active_games.erase(room_id)
	emit_signal("game_finished", room_id, winner, reason)
	print("üèÅ GameManager: Tr·∫≠n '%s' k·∫øt th√∫c. Ng∆∞·ªùi th·∫Øng: %s" % [room_id, winner])

# ===========================================================================
# create_duel_vs_bot(player_id)
# T·∫°o tr·∫≠n ƒë·∫•u gi·ªØa ng∆∞·ªùi ch∆°i v√† bot (AI)
# ===========================================================================
func create_duel_vs_bot(player_id):
	var bot_id = "bot_ai"
	var player_deck = database_manager.get_deck(player_id)
	var bot_deck = _get_bot_deck()

	var rules = { "start_lp": 8000, "max_hand_size": 6 }
	var room_id = battle_core.start_duel(player_id, bot_id, player_deck, bot_deck, rules)

	if typeof(room_id) != TYPE_STRING:
		return { "success": false, "error": "FAILED_TO_CREATE_DUEL" }

	# L∆∞u v√†o danh s√°ch tr·∫≠n
	active_games[room_id] = {
		"player_a": player_id,
		"player_b": bot_id,
		"room_id": room_id,
		"status": "started",
		"start_time": OS.get_unix_time(),
		"mode": "pve"
	}

	# Th√¥ng b√°o tr·∫≠n b·∫Øt ƒë·∫ßu
	emit_signal("game_started", room_id, player_id, bot_id)
	print("üéÆ GameManager: Tr·∫≠n PvE '%s' ƒë√£ t·∫°o gi·ªØa %s v√† %s" % [room_id, player_id, bot_id])

	# B·∫Øt ƒë·∫ßu v√≤ng l·∫∑p bot
	_schedule_bot_turn(room_id)

	return { "success": true, "room_id": room_id }

# ===========================================================================
# _get_bot_deck() ‚Üí Array
# Tr·∫£ v·ªÅ b·ªô b√†i m·∫´u cho bot
# ===========================================================================
func _get_bot_deck() -> Array:
	return [
		"BLUE_EYES_WHITE_DRAGON", "BLUE_EYES_WHITE_DRAGON", "SUMMONED_SKULL",
		"DARK_MAGICIAN", "GYOUKI", "SUIJIN", "KURIBOH", "MAN_EATER_BUTTERFLY",
		"DARK_HOLE", "MIRROR_FORCE", "TRAP_HOLE", "POT_OF_GREED", "CARD_OF_DESTRUCTION",
		"MONSTER_REBORN", "FACE_UP", "SACRIFICE", "OFFERING", "DRAGON", "WARRIOR", "SPELL"
	]

# ===========================================================================
# _schedule_bot_turn(room_id)
# L·∫≠p l·ªãch ƒë·ªÉ bot ch∆°i l∆∞·ª£t (d√πng deferred ƒë·ªÉ tr√°nh l·ªói tree)
# ===========================================================================
func _schedule_bot_turn(room_id):
	get_tree().create_timer(1.5).connect("timeout", self, "_run_bot_turn", [room_id])

# ===========================================================================
# _run_bot_turn(room_id)
# X·ª≠ l√Ω l∆∞·ª£t c·ªßa bot
# ===========================================================================
func _run_bot_turn(room_id):
	# Ki·ªÉm tra tr·∫≠n c√≤n t·ªìn t·∫°i
	if not active_games.has(room_id):
		return

	var game = active_games[room_id]
	var bot_id = game["player_b"]
	if bot_id != "bot_ai":
		return

	var state = battle_core.get_game_state(room_id)
	if not state or state.status != "active":
		return

	# N·∫øu ƒë·∫øn l∆∞·ª£t bot
	if state.turn == bot_id:
		var available_actions = battle_core.get_available_actions(room_id, bot_id)
		if available_actions.empty():
			return

		# Bot ch·ªçn h√†nh ƒë·ªông
		var action = YugiBot.choose_action(state, bot_id, available_actions)
		if action:
			action.player_id = bot_id
			var result = battle_core.submit_action(room_id, action)

			# H·ªçc t·ª´ k·∫øt qu·∫£ n·∫øu b·∫≠t learning
			if Agent.learning_mode:
				Agent.learn_from_result(state, action, result)

			# Ph√°t t√≠n hi·ªáu ƒë·ªÉ ServerManager g·ª≠i v·ªÅ client
			emit_signal("game_event", room_id, result.events)

	# N·∫øu ch∆∞a ph·∫£i l∆∞·ª£t bot, ti·∫øp t·ª•c schedule (ƒë·ªÉ ki·ªÉm tra sau)
	if state.turn != bot_id and state.status == "active":
		_schedule_bot_turn(room_id)

================================================================================

--- FILE: server_yugiDuel\autoload\NetworkManager.gd ---
# ===========================================================================
# NetworkManager.gd - Qu·∫£n l√Ω k·∫øt n·ªëi multiplayer d√πng ENet (Godot 3.6)
# Autoload Singleton
# Ch·ª©c nƒÉng:
#   - Kh·ªüi t·∫°o server ENet
#   - Qu·∫£n l√Ω k·∫øt n·ªëi/disconnect
#   - Nh·∫≠n v√† ƒë·ªãnh tuy·∫øn tin nh·∫Øn
#   - G·ª≠i d·ªØ li·ªáu v·ªÅ client
# ===========================================================================
extends Node

# C·ªïng server s·∫Ω l·∫Øng nghe
const DEFAULT_PORT = 8080

# Peer ID c·ªßa server (lu√¥n l√† 1)
const SERVER_PEER_ID = 1

# Tr·∫°ng th√°i
var multiplayer_peer = null
var is_server = false

# Danh s√°ch peer_id ‚Üí player_id (mapping)
var peer_to_player = {}

# Signal ƒë·ªÉ g·ª≠i tin hi·ªáu ƒë·∫øn c√°c manager kh√°c
signal client_connected(player_id, peer_id)
signal client_disconnected(peer_id)
signal message_received(player_id, message)

# ===========================================================================
# _ready()
# Kh·ªüi t·∫°o server ENet
# ===========================================================================
func _ready():
	# Thi·∫øt l·∫≠p multiplayer
	get_tree().network_peer = _create_server(DEFAULT_PORT)
	var error = get_tree().network_peer
	if error:
		is_server = true
		print("üåê NetworkManager: Server ƒëang ch·∫°y tr√™n c·ªïng %d" % DEFAULT_PORT)
	else:
		push_error("‚ùå NetworkManager: Kh√¥ng th·ªÉ kh·ªüi t·∫°o server ENet")
		return

	# K·∫øt n·ªëi c√°c signal
	get_tree().connect("network_peer_connected", self, "_on_peer_connected")
	get_tree().connect("network_peer_disconnected", self, "_on_peer_disconnected")
	get_tree().connect("connected_to_server", self, "_on_connected_to_server")
	get_tree().connect("connection_failed", self, "_on_connection_failed")

# ===========================================================================
# _create_server(port) ‚Üí NetworkedMultiplayerENet
# T·∫°o server ENet l·∫Øng nghe tr√™n c·ªïng
# ===========================================================================
func _create_server(port):
	var enet = NetworkedMultiplayerENet.new()
	var err = enet.create_server(port, 32)  # T·ªëi ƒëa 32 client
	if err != OK:
		push_error("L·ªói t·∫°o server ENet: %d" % err)
		return null
	return enet

# ===========================================================================
# _process(delta)
# X·ª≠ l√Ω tin nh·∫Øn m·∫°ng
# ===========================================================================
func _process(delta):
	if not is_server or not multiplayer.network_peer:
		return
	# ƒê·∫£m b·∫£o x·ª≠ l√Ω t·∫•t c·∫£ tin nh·∫Øn
	multiplayer.poll()

# ===========================================================================
# _on_peer_connected(peer_id)
# Khi client k·∫øt n·ªëi th√†nh c√¥ng
# peer_id: ID do ENet c·∫•p (2, 3, 4,...)
# ===========================================================================
func _on_peer_connected(peer_id):
	print("üü¢ Client k·∫øt n·ªëi: peer_id=%d" % peer_id)
	# G√°n t·∫°m player_id theo peer_id
	var player_id = "player_%d" % peer_id
	peer_to_player[peer_id] = player_id
	# Ph√°t t√≠n hi·ªáu ƒë·ªÉ c√°c manager kh√°c x·ª≠ l√Ω (v√≠ d·ª• AuthManager)
	emit_signal("client_connected", player_id, peer_id)
	# G·ª≠i ph·∫£n h·ªìi ch√†o m·ª´ng
	var welcome_msg = {
		"type": "WELCOME",
		"your_player_id": player_id,
		"server_time": OS.get_unix_time()
	}
	rpc_id(peer_id, "receive_message", welcome_msg)

# ===========================================================================
# _on_peer_disconnected(peer_id)
# Khi client ng·∫Øt k·∫øt n·ªëi
# ===========================================================================
func _on_peer_disconnected(peer_id):
	var player_id = peer_to_player.get(peer_id, "unknown")
	print("üî¥ Client ng·∫Øt k·∫øt n·ªëi: peer_id=%d, player_id=%s" % [peer_id, player_id])
	peer_to_player.erase(peer_id)
	emit_signal("client_disconnected", peer_id)

# ===========================================================================
# _on_connected_to_server()
# (Ch·ªâ d√πng n·∫øu l√† client ‚Äì kh√¥ng c·∫ßn thi·∫øt cho server)
# ===========================================================================
func _on_connected_to_server():
	pass

# ===========================================================================
# _on_connection_failed()
# (Ch·ªâ d√πng n·∫øu l√† client)
# ===========================================================================
func _on_connection_failed():
	pass

# ===========================================================================
# receive_message(message) ‚Üê RPC
# H√†m nh·∫≠n tin nh·∫Øn t·ª´ client (g·ªçi qua RPC)
# ===========================================================================
remote func receive_message(message):
	# var peer_id = get_tree().get_network_peer().get_packet_peer()
	# var player_id = peer_to_player.get(peer_id, "unknown")
	var peer_id = multiplayer.get_rpc_sender_id()
	var player_id = peer_to_player.get(peer_id, "unknown")
	
	if message.type == null:
		_send_error(peer_id, "MISSING_MESSAGE_TYPE")
		return
	
	print("üì© Nh·∫≠n tin: peer_id=%d | player_id=%s | type=%s" % [peer_id, player_id, message.type])
	
	# Ph√°t t√≠n hi·ªáu ƒë·ªÉ c√°c manager kh√°c x·ª≠ l√Ω (AuthManager, ServerManager)
	emit_signal("message_received", player_id, message)

# ===========================================================================
# send_message_to_player(player_id, data)
# G·ª≠i tin v·ªÅ 1 ng∆∞·ªùi ch∆°i
# ===========================================================================
func send_message_to_player(player_id, data):
	var peer_id = _get_peer_from_player(player_id)
	if peer_id == 0:
		push_warning("Kh√¥ng t√¨m th·∫•y peer cho player: %s" % player_id)
		return
	rpc_id(peer_id, "receive_message", data)

# ===========================================================================
# broadcast_message(data, exclude_player = null)
# G·ª≠i tin ƒë·∫øn t·∫•t c·∫£ client (tr·ª´ 1 n·∫øu c·∫ßn)
# ===========================================================================
func broadcast_message(data, exclude_player = null):
	for peer_id in peer_to_player:
		if exclude_player:
			var p = peer_to_player[peer_id]
			if p == exclude_player:
				continue
		rpc_id(peer_id, "receive_message", data)

# ===========================================================================
# _get_peer_from_player(player_id) ‚Üí int
# T√¨m peer_id t·ª´ player_id
# ===========================================================================
func _get_peer_from_player(player_id):

	for pid in peer_to_player:
		if player_id == peer_to_player[pid]:
			return pid
	return 0

# ===========================================================================
# _send_error(peer_id, error_code, message = "")
# G·ª≠i ph·∫£n h·ªìi l·ªói v·ªÅ client
# ===========================================================================
func _send_error(peer_id, error_code, message = ""):
	var err_msg = {
		"type": "ERROR",
		"code": error_code,
		"message": message if message else "L·ªói: %s" % error_code
	}
	rpc_id(peer_id, "receive_message", err_msg)

# ===========================================================================
# shutdown()
# T·∫Øt server
# ===========================================================================
func shutdown():
	if multiplayer.network_peer:
		multiplayer.network_peer.close()
		multiplayer.network_peer = null
		print("üõë NetworkManager: Server ƒë√£ t·∫Øt")

================================================================================

--- FILE: server_yugiDuel\autoload\PvEManager.gd ---
# res://autoload/PvEManager.gd
extends Node

# Tham chi·∫øu
onready var battle_core = BattleCore
onready var network_manager = NetworkManager
onready var card_db = CardDatabase

# ID bot ·∫£o
const BOT_ID = "bot_ai_1"
const BOT_DECK = ["BLUE_EYES_WHITE_DRAGON", "BLUE_EYES_WHITE_DRAGON", "BLUE_EYES_WHITE_DRAGON", "SUIJIN", "POT_OF_GREED", "MIRROR_FORCE", "DARK_HOLE", "TRAP_HOLE", "MONSTER_REBORN", "KURIBOH"] # V√≠ d·ª•

func start_pve_game(player_id, deck_player):
	# T·∫°o deck cho bot (c√≥ th·ªÉ random sau)
	var deck_bot = BOT_DECK.duplicate()
	
	# D√πng BattleCore c√≥ s·∫µn ƒë·ªÉ t·∫°o tr·∫≠n
	var room_id = battle_core.start_duel(player_id, BOT_ID, deck_player, deck_bot, {})
	
	if not room_id:
		return false

	# G·ª≠i th√¥ng b√°o cho client
	network_manager.send_message_to_player(player_id, {
		"type": "GAME_STARTED",
		"room_id": room_id,
		"side": "player", # ho·∫∑c random
		"mode": "pve"
	})

	# B·∫Øt ƒë·∫ßu v√≤ng l·∫∑p bot
	_schedule_bot_turn(room_id)

	return true

# H√†m l·∫≠p l·ªãch l∆∞·ª£t bot
func _schedule_bot_turn(room_id):
	# D√πng timer ƒë·ªÉ ch·∫°y sau khi frame hi·ªán t·∫°i xong
	get_tree().call_deferred("_run_bot_turn", room_id)

func _run_bot_turn(room_id):
	if not battle_core.active_duels.has(room_id):
		return
	
	var game_state = battle_core.get_game_state(room_id)
	if not game_state:
		return

	# Ki·ªÉm tra xem c√≥ ph·∫£i l∆∞·ª£t bot kh√¥ng
	if game_state.turn == BOT_ID and game_state.status == "active":
		# L·∫•y c√°c h√†nh ƒë·ªông kh·∫£ d·ª•ng
		var available_actions = battle_core.get_available_actions(room_id, BOT_ID)
		
		# Bot ch·ªçn h√†nh ƒë·ªông (d√πng YugiBot hi·ªán c√≥)
		var action = YugiBot.choose_action(game_state, BOT_ID, available_actions)
		
		if action:
			# G·ª≠i h√†nh ƒë·ªông v√†o core
			var result = battle_core.submit_action(room_id, action)
			
			# G·ª≠i k·∫øt qu·∫£ v·ªÅ cho ng∆∞·ªùi ch∆°i (ƒë·ªÉ update UI)
			for player in [game_state.players.keys()[0]]: # ch·ªâ player th·∫≠t
				if player != BOT_ID:
					network_manager.send_message_to_player(player, {
						"type": "ACTION_RESULT",
						"result": result
					})
	
	# Lu√¥n schedule l·∫°i ƒë·ªÉ ki·ªÉm tra ti·∫øp
	get_tree().create_timer(1.5).connect("timeout", self, "_schedule_bot_turn", [room_id])

================================================================================

--- FILE: server_yugiDuel\autoload\ServerManager.gd ---
# ===========================================================================
# ServerManager.gd - Qu·∫£n l√Ω to√†n b·ªô server multiplayer
# ===========================================================================
extends Node

# Danh s√°ch ph√≤ng: room_id ‚Üí { player_a, player_b, status }
var rooms = {}
# player_id ‚Üí room_id
var player_to_room = {}

# Tham chi·∫øu
onready var network_manager = NetworkManager
onready var auth_manager = AuthManager
onready var game_manager = GameManager

# ===========================================================================
# _ready()
# K·∫øt n·ªëi c√°c signal
# ===========================================================================
func _ready():
	network_manager.connect("client_disconnected", self, "_on_client_disconnected")
	auth_manager.connect("player_authenticated", self, "_on_player_authenticated")
	network_manager.connect("message_received", self, "_on_message_received")
	game_manager.connect("game_started", self, "_on_game_started")
	game_manager.connect("game_finished", self, "_on_game_finished")
	game_manager.connect("game_event", self, "_on_game_event")

# ===========================================================================
# _on_player_authenticated(player_id, token, peer_id)
# Khi ng∆∞·ªùi ch∆°i x√°c th·ª±c th√†nh c√¥ng
# ===========================================================================
func _on_player_authenticated(player_id, token, peer_id):
	print("üü¢ ServerManager: '%s' ƒë√£ x√°c th·ª±c th√†nh c√¥ng." % player_id)
	
	# ‚úÖ G·ª≠i th√¥ng tin ng∆∞·ªùi ch∆°i, KH√îNG g·ª≠i AUTH_SUCCESS
	network_manager.send_message_to_player(player_id, {
		"type": "PLAYER_INFO",
		"player": DatabaseManager.get_player(player_id)
	})

# ===========================================================================
# _on_message_received(player_id, message)
# X·ª≠ l√Ω tin nh·∫Øn t·ª´ client
# ===========================================================================
func _on_message_received(player_id, message):
    var token = message.get("token", "")
    var valid = _verify_token(player_id, token)
    
    if not valid:
        _send_error(player_id, "INVALID_TOKEN")
        return

# ===========================================================================
# _handle_create_room(player_id, message)
# T·∫°o ph√≤ng m·ªõi, h·ªó tr·ª£ PvP v√† PvE
# ===========================================================================
func _handle_create_room(player_id, message):
	var mode = message.get("mode", "pvp")  # M·∫∑c ƒë·ªãnh l√† PvP
	
	match mode:
		"pvp":
			_create_pvp_room(player_id)
		"pve":
			_start_pve_game(player_id)
		_:
			_send_error(player_id, "INVALID_MODE")

# ===========================================================================
# _create_pvp_room(player_id)
# T·∫°o ph√≤ng PvP ch·ªù ng∆∞·ªùi kh√°c
# ===========================================================================
func _create_pvp_room(player_id):
	var room_id = "room_%d" % OS.get_unix_time()
	rooms[room_id] = {
		"host": player_id,
		"player_a": player_id,
		"player_b": null,
		"status": "waiting"
	}
	player_to_room[player_id] = room_id
	network_manager.send_message_to_player(player_id, {
		"type": "ROOM_CREATED",
		"room_id": room_id
	})
	_broadcast_rooms()

# ===========================================================================
# _start_pve_game(player_id)
# T·∫°o tr·∫≠n ƒë·∫•u v·ªõi bot (do GameManager x·ª≠ l√Ω)
# ===========================================================================
func _start_pve_game(player_id):
	var result = game_manager.create_duel_vs_bot(player_id)
	
	if not result.success:
		_send_error(player_id, "FAILED_TO_START_GAME")
		return

	var room_id = result.room_id
	player_to_room[player_id] = room_id

	# G·∫Øn room v√†o danh s√°ch (ƒë·ªÉ hi·ªÉn th·ªã, broadcast)
	rooms[room_id] = {
		"host": player_id,
		"player_a": player_id,
		"player_b": "bot_ai",
		"status": "started"
	}

	# Th√¥ng b√°o cho client
	network_manager.send_message_to_player(player_id, {
		"type": "GAME_STARTED",
		"room_id": room_id
	})

	# C·∫≠p nh·∫≠t danh s√°ch ph√≤ng
	_broadcast_rooms()

# ===========================================================================
# _handle_join_room(player_id, room_id)
# V√†o ph√≤ng
# ===========================================================================
func _handle_join_room(player_id, room_id):
	if not rooms.has(room_id):
		_send_error(player_id, "ROOM_NOT_FOUND")
		return
	var room = rooms[room_id]
	if room.player_b != null:
		_send_error(player_id, "ROOM_FULL")
		return
	room.player_b = player_id
	player_to_room[player_id] = room_id
	# B·∫Øt ƒë·∫ßu tr·∫≠n
	var result = game_manager.create_duel(room.player_a, room.player_b)
	if result.success:
		room.status = "started"
		# Th√¥ng b√°o cho c·∫£ hai
		_broadcast_to_room(room_id, {
			"type": "GAME_STARTED",
			"room_id": result.room_id
		})
	else:
		_send_error(player_id, "FAILED_TO_START_GAME")

# ===========================================================================
# _handle_list_rooms(player_id)
# G·ª≠i danh s√°ch ph√≤ng
# ===========================================================================
func _handle_list_rooms(player_id):
	var list = []
	for rid in rooms:
		var r = rooms[rid]
		list.append({
			"room_id": rid,
			"host": r.host,
			"player_count": 1 if r.player_b == null else 2,
			"status": r.status
		})
	network_manager.send_message_to_player(player_id, {
		"type": "ROOM_LIST",
		"rooms": list
	})

# ===========================================================================
# _handle_submit_action(player_id, action)
# G·ª≠i h√†nh ƒë·ªông v√†o tr·∫≠n
# ===========================================================================
func _handle_submit_action(player_id, action):
	var room_id = player_to_room.get(player_id)
	if not room_id:
		_send_error(player_id, "NOT_IN_ROOM")
		return
	action["player_id"] = player_id
	var result = game_manager.submit_action(room_id, action)
	# G·ª≠i k·∫øt qu·∫£ v·ªÅ ng∆∞·ªùi ch∆°i
	network_manager.send_message_to_player(player_id, {
		"type": "ACTION_RESULT",
		"result": result
	})
	# N·∫øu c√≥ events ‚Üí broadcast
	if result.success and result.events:
		_broadcast_to_room(room_id, {
			"type": "GAME_EVENT",
			"events": result.events
		})

# ===========================================================================
# _handle_get_state(player_id, room_id)
# G·ª≠i tr·∫°ng th√°i tr·∫≠n
# ===========================================================================
func _handle_get_state(player_id, room_id):
	var state = game_manager.get_game_state(room_id, player_id)
	network_manager.send_message_to_player(player_id, {
		"type": "GAME_STATE",
		"state": state
	})

# ===========================================================================
# _on_game_started(room_id, player_a, player_b)
# Khi tr·∫≠n ƒë·∫•u b·∫Øt ƒë·∫ßu
# ===========================================================================
func _on_game_started(room_id, player_a, player_b):
	_broadcast_to_room(room_id, {
		"type": "BATTLE_STARTED",
		"room_id": room_id
	})

# ===========================================================================
# _on_game_finished(room_id, winner, reason)
# Khi tr·∫≠n k·∫øt th√∫c
# ===========================================================================
func _on_game_finished(room_id, winner, reason):
	if rooms.has(room_id):
		var player_a = rooms[room_id].player_a
		var player_b = rooms[room_id].player_b
		_broadcast_to_room(room_id, {
			"type": "GAME_OVER",
			"winner": winner,
			"reason": reason
		})
		# D·ªçn d·∫πp
		if player_a: player_to_room.erase(player_a)
		if player_b: player_to_room.erase(player_b)
		rooms.erase(room_id)
	_broadcast_rooms()

# ===========================================================================
# _broadcast_rooms()
# G·ª≠i danh s√°ch ph√≤ng cho t·∫•t c·∫£
# ===========================================================================
func _broadcast_rooms():
	var list = []
	for rid in rooms:
		var r = rooms[rid]
		list.append({
			"room_id": rid,
			"host": r.host,
			"player_count": 1 if r.player_b == null else 2,
			"status": r.status
		})
	network_manager.broadcast_message({
		"type": "ROOM_LIST_UPDATE",
		"rooms": list
	})

func _on_game_event(room_id, events):
	if events and events.size() > 0:
		_broadcast_to_room(room_id, {
			"type": "GAME_EVENT",
			"events": events
		})

# ===========================================================================
# _broadcast_to_room(room_id, msg)
# G·ª≠i tin ƒë·∫øn t·∫•t c·∫£ trong ph√≤ng
# ===========================================================================
func _broadcast_to_room(room_id, msg):
	var room = rooms.get(room_id)
	if not room: return
	for p in [room.player_a, room.player_b]:
		if p: network_manager.send_message_to_player(p, msg)

# ===========================================================================
# _send_error(player_id, error_code)
# G·ª≠i l·ªói
# ===========================================================================
func _send_error(player_id, error_code):
	network_manager.send_message_to_player(player_id, {
		"type": "ERROR",
		"code": error_code
	})


func _verify_token(player_id, token):
    return AuthManager.is_token_valid(token) and AuthManager.get_player_id_from_token(token) == player_id



func _on_client_disconnected(player_id):
    # X√≥a kh·ªèi ph√≤ng
    var room_id = player_to_room.get(player_id, "")
    # if room_id != "":
    #     _remove_player_from_room(player_id)
    #     _broadcast_to_room(room_id, {
    #         "type": "PLAYER_DISCONNECTED",
    #         "player_id": player_id
    #     })
    # X√≥a session
    AuthManager.logout_player(player_id)
================================================================================

--- FILE: server_yugiDuel\autoload\YugiBot.gd ---
# ===========================================================================
# YugiBot.gd - Bot ch∆°i Yu-Gi-Oh! th·ªß c√¥ng (Godot 3.6)
# Autoload Singleton - T·ª± ƒë·ªông ch·ªçn v√† th·ª±c hi·ªán h√†nh ƒë·ªông d·ª±a tr√™n heuristic
# Kh√¥ng c·∫ßn UI, kh√¥ng c·∫ßn m·∫°ng, t√≠ch h·ª£p v·ªõi BattleCore v√† CardDatabase
# ===========================================================================
extends Node

# ===========================================================================
# play_turn(room_id, player_id)
# Bot th·ª±c hi·ªán to√†n b·ªô l∆∞·ª£t c·ªßa player_id trong room_id
# Tr·∫£ v·ªÅ: { success: bool, action_taken: Dictionary, result: Dictionary }
# ===========================================================================
func play_turn(room_id, player_id):
	var state = BattleCore.get_game_state(room_id, player_id)
	if state.empty():
		return {"success": false, "action_taken": {}, "result": {"errors": ["ROOM_NOT_FOUND"]}}
	if state["status"] != "active" or state["turn"] != player_id:
		return {"success": false, "action_taken": {}, "result": {"errors": ["NOT_YOUR_TURN"]}}
	var actions = BattleCore.get_available_actions(room_id, player_id)
	var action = _choose_action(state, player_id, actions)
	if action["type"] == "":
		return {"success": false, "action_taken": {}, "result": {"errors": ["NO_ACTION_CHOSEN"]}}
	var result = BattleCore.submit_action(room_id, action)
	return {"success": result["success"], "action_taken": action, "result": result}

# ===========================================================================
# _choose_action(state, player_id, actions)
# Ch·ªçn h√†nh ƒë·ªông t·ªëi ∆∞u d·ª±a tr√™n heuristic
# ‚úÖ ƒê√É S·ª¨A: ∆Øu ti√™n END_TURN khi ·ªü phase "end"
# ===========================================================================
func _choose_action(state, player_id, actions):
	var phase = state["phase"]
	var action_details = actions.details

	# X·ª≠ l√Ω chain tr∆∞·ªõc (n·∫øu c√≥)
	if not state["chain"].empty():
		var trap_action = _choose_trap_action(state, player_id, action_details)
		if trap_action.type != "":
			trap_action["player_id"] = player_id
			return trap_action

	# X·ª≠ l√Ω theo phase
	if phase == "draw" and "DRAW_CARD" in actions.types:
		return {"type": "DRAW_CARD", "player_id": player_id, "payload": {}}

	if phase in ["main1", "main2"]:
		var main_action = _choose_main_phase_action(state, player_id, action_details)
		if main_action.type != "":
			main_action["player_id"] = player_id
			return main_action

	if phase == "battle":
		var attack_action = _choose_attack_action(state, player_id, action_details)
		if attack_action.type != "":
			attack_action["player_id"] = player_id
			return attack_action

	# üü¢ ∆Øu ti√™n END_TURN n·∫øu ƒëang ·ªü phase "end"
	if phase == "end":
		if "END_TURN" in actions.types:
			return {"type": "END_TURN", "player_id": player_id, "payload": {}}
		elif "END_PHASE" in actions.types:
			return {"type": "END_PHASE", "player_id": player_id, "payload": {}}
		else:
			return {"type": "END_TURN", "player_id": player_id, "payload": {}}

	# N·∫øu kh√¥ng ph·∫£i end phase, th√¨ END_PHASE
	if "END_PHASE" in actions.types:
		return {"type": "END_PHASE", "player_id": player_id, "payload": {}}
	if "END_TURN" in actions.types:
		return {"type": "END_TURN", "player_id": player_id, "payload": {}}

	return {"type": "", "player_id": player_id, "payload": {}}

# ===========================================================================
# _choose_main_phase_action(state, player_id, action_details)
# Ch·ªçn h√†nh ƒë·ªông trong main phase (summon, spell, trap)
# ===========================================================================
func _choose_main_phase_action(state, player_id, action_details):
	# ∆Øu ti√™n 1: Activate spell c√≥ effect m·∫°nh (Pot of Greed, Monster Reborn, Dark Hole)
	for act in action_details:
		if act.type == "PLAY_SPELL":
			var card_id = act.payload["card_id"]
			var effect = CardDatabase.get(card_id).get("effect", "")
			if effect in ["draw_2", "special_summon_graveyard", "destroy_all_monsters"]:
				var action = act.duplicate()
				action["player_id"] = player_id
				return action

	# ∆Øu ti√™n 2: Summon qu√°i c√≥ ATK cao nh·∫•t
	var best_atk = -1
	var best_action = null
	for act in action_details:
		if act.type == "PLAY_MONSTER":
			var card_id = act.payload["card_id"]
			var atk = CardDatabase.get(card_id).get("atk", 0)
			if atk > best_atk:
				best_atk = atk
				best_action = act
	if best_action:
		var action = best_action.duplicate()
		action["player_id"] = player_id
		return action

	# ∆Øu ti√™n 3: Set trap
	for act in action_details:
		if act.type == "SET_TRAP":
			var action = act.duplicate()
			action["player_id"] = player_id
			return action

	# ∆Øu ti√™n 4: Set spell
	for act in action_details:
		if act.type == "SET_SPELL":
			var action = act.duplicate()
			action["player_id"] = player_id
			return action

	# ∆Øu ti√™n 5: Set monster n·∫øu kh√¥ng summon ƒë∆∞·ª£c
	for act in action_details:
		if act.type == "SET_MONSTER":
			var action = act.duplicate()
			action["player_id"] = player_id
			return action

	# # ∆Øu ti√™n 6: Activate effect tr√™n s√¢n
	# for act in action_details:
	# 	if act.type == "ACTIVATE_EFFECT":
	# 		var card_id = act.payload["card_id"]
	# 		var effect = CardDatabase.get(card_id).get("effect", "")
	# 		if effect != "":
	# 			var action = act.duplicate()
	# 			action["player_id"] = player_id
	# 			return action

	return {"type": "", "player_id": player_id, "payload": {}}

# ===========================================================================
# _choose_attack_action(state, player_id, action_details)
# Ch·ªçn h√†nh ƒë·ªông t·∫•n c√¥ng (∆∞u ti√™n qu√°i y·∫øu nh·∫•t c·ªßa ƒë·ªëi th·ªß)
# ===========================================================================
func _choose_attack_action(state, player_id, action_details):
	var player = state["players"][player_id]
	var opponent_id = _get_opponent_id(state)
	var opponent = state["players"][opponent_id]

	# T√¨m qu√°i m·∫°nh nh·∫•t c·ªßa m√¨nh ch∆∞a t·∫•n c√¥ng
	var best_atk = -1
	var best_atk_zone = -1
	for i in range(5):
		var monster_obj = player["monster_zones"][i]
		if monster_obj and monster_obj.position == "face_up_attack" and not monster_obj.get("attacked_this_turn", false):
			var atk = CardDatabase.get(monster_obj.card_id).get("atk", 0)
			if atk > best_atk:
				best_atk = atk
				best_atk_zone = i
	if best_atk_zone == -1:
		return {"type": "", "player_id": player_id, "payload": {}}

	# Ki·ªÉm tra direct attack
	var has_monster = false
	for zone in opponent["monster_zones"]:
		if zone != null:
			has_monster = true
			break
	if not has_monster:
		for act in action_details:
			if act.type == "DECLARE_ATTACK" and act.payload["atk_zone"] == best_atk_zone and not act.payload.has("target_zone"):
				var action = act.duplicate()
				action["player_id"] = player_id
				return action

	# T·∫•n c√¥ng qu√°i y·∫øu nh·∫•t
	var weakest_atk = 999999
	var weakest_zone = -1
	for i in range(5):
		if opponent["monster_zones"][i]:
			var atk = CardDatabase.get(opponent["monster_zones"][i].card_id).get("atk", 0)
			if atk < weakest_atk:
				weakest_atk = atk
				weakest_zone = i
	if weakest_zone != -1:
		for act in action_details:
			if act.type == "DECLARE_ATTACK" and act.payload["atk_zone"] == best_atk_zone and act.payload["target_zone"] == weakest_zone:
				var action = act.duplicate()
				action["player_id"] = player_id
				return action

	return {"type": "", "player_id": player_id, "payload": {}}

# ===========================================================================
# _choose_trap_action(state, player_id, action_details)
# Ch·ªçn trap ƒë·ªÉ k√≠ch ho·∫°t trong chain
# ===========================================================================
func _choose_trap_action(state, player_id, action_details):
	if state["chain_trigger"]:
		var trigger_type = state["chain_trigger"].get("type", "")
		if trigger_type == "ATTACK_DECLARED":
			for act in action_details:
				if act.type == "ACTIVATE_EFFECT":
					var card_id = act.payload["card_id"]
					var effect = CardDatabase.get(card_id).get("effect", "")
					if effect in ["destroy_all_attackers", "destroy_summoned_monster", "reduce_atk_0"]:
						var action = act.duplicate()
						action["player_id"] = player_id
						return action

		elif trigger_type == "SUMMON":
			for act in action_details:
				if act.type == "ACTIVATE_EFFECT":
					var card_id = act.payload["card_id"]
					var effect = CardDatabase.get(card_id).get("effect", "")
					if effect == "destroy_summoned_monster":
						var action = act.duplicate()
						action["player_id"] = player_id
						return action

	return {"type": "", "player_id": player_id, "payload": {}}

# ===========================================================================
# _get_opponent_id(state)
# L·∫•y ID c·ªßa ƒë·ªëi th·ªß
# ===========================================================================
func _get_opponent_id(state):
	for pid in state["players"]:
		if pid != state["turn"]:
			return pid
	return null
================================================================================

--- FILE: server_yugiDuel\core\main.gd ---
# ===========================================================================
# Main.gd - Scene ch√≠nh ƒë·ªÉ test h·ªá th·ªëng Yu-Gi-Oh! (Godot 3.6)
# Kh·ªüi t·∫°o tr·∫≠n ƒë·∫•u, ƒë·ªÉ YugiBot ch∆°i t·ª± ƒë·ªông v√† gi·∫£ l·∫≠p ng∆∞·ªùi ch∆°i
# Kh√¥ng d√πng UI, ch·ªâ in k·∫øt qu·∫£ qua console
# ===========================================================================

extends Node

var room_id = ""
var human_player = "player_a"
var bot_player = "player_b"

# ===========================================================================
# _ready()
# Kh·ªüi t·∫°o tr·∫≠n ƒë·∫•u khi scene ch·∫°y
# ===========================================================================
func _ready():
	# ƒê·∫£m b·∫£o CardDatabase ƒë√£ n·∫°p
	if CardDatabase.get_all().empty():
		print("‚ùå L·ªói: CardDatabase ch∆∞a n·∫°p d·ªØ li·ªáu!")
		return
	
	# T·∫°o deck m·∫´u
	var deck_a = [
		"BLUE_EYES_WHITE_DRAGON", "BLUE_EYES_WHITE_DRAGON",
		"POT_OF_GREED", "MONSTER_REBORN", "DARK_HOLE",
		"SUMMONED_SKULL", "GYOUKI"
	]
	var deck_b = [
		"DARK_MAGICIAN", "DARK_MAGICIAN",
		"MIRROR_FORCE", "TRAP_HOLE", "SUIJIN",
		"GYOUKI", "SUMMONED_SKULL"
	]
	
	# Kh·ªüi t·∫°o tr·∫≠n ƒë·∫•u
	room_id = BattleCore.start_duel(human_player, bot_player, deck_a, deck_b, {
		"start_lp": 8000,
		"max_hand_size": 6,
		"forbidden_cards": []
	})
	print("this is room", room_id)
	if room_id == "":
		print("‚ùå L·ªói: Kh√¥ng th·ªÉ t·∫°o tr·∫≠n ƒë·∫•u!")
		return
	
	print("üéÆ Tr·∫≠n ƒë·∫•u b·∫Øt ƒë·∫ßu: %s" % room_id)
	_play_next_turn()


# ===========================================================================
# _play_next_turn()
# X·ª≠ l√Ω l∆∞·ª£t ti·∫øp theo, g·ªçi bot ho·∫∑c gi·∫£ l·∫≠p ng∆∞·ªùi ch∆°i
# ===========================================================================
# ===========================================================================
# _play_next_turn()
# ‚úÖ ƒê√É S·ª¨A: Th√™m v√≤ng l·∫∑p cho bot ƒë·ªÉ th·ª±c hi·ªán nhi·ªÅu h√†nh ƒë·ªông trong 1 l∆∞·ª£t
# ===========================================================================
func _play_next_turn():
	var state = BattleCore.get_game_state(room_id, human_player)
	if state.empty() or state["status"] != "active":
		print("üèÅ K·∫øt th√∫c tr·∫≠n.")
		return

	_print_game_state(state)

	if state["turn"] == bot_player:
		# üîÅ V√íNG L·∫∂P: Cho ph√©p bot th·ª±c hi·ªán nhi·ªÅu h√†nh ƒë·ªông
		while true:
			# L·∫•y tr·∫°ng th√°i m·ªõi nh·∫•t
			var current_state = BattleCore.get_game_state(room_id, bot_player)
			if current_state.empty() or current_state["status"] != "active" or current_state["turn"] != bot_player:
				break

			var bot_result = YugiBot.play_turn(room_id, bot_player)
			if bot_result.success:
				print("ü§ñ Bot action: %s" % bot_result.action_taken)
				print("üìà K·∫øt qu·∫£: %s", bot_result.result["events"])
			else:
				print("‚ùå Bot th·∫•t b·∫°i: %s" % bot_result.result["errors"])
				break

			# ‚úÖ TH√äM D√íNG N√ÄY: D·ª´ng 0.1s ƒë·ªÉ tr√°nh treo
			yield(get_tree().create_timer(0.1), "timeout")
	else:
		# üë§ Ng∆∞·ªùi ch∆°i (gi·∫£ l·∫≠p)
		var actions = BattleCore.get_available_actions(room_id, human_player)
		var action = _simulate_human_action(state, human_player, actions)
		var result = BattleCore.submit_action(room_id, action)
		if result["success"]:
			print("üë§ Human action: %s" % action)
			print("üìà K·∫øt qu·∫£: %s" , result["events"])
		else:
			print("‚ùå Human th·∫•t b·∫°i: %s" % result["errors"])

	# Ch·ªù 1 gi√¢y r·ªìi ti·∫øp t·ª•c
	yield(get_tree().create_timer(1.0), "timeout")
	_play_next_turn()

# ===========================================================================
# _simulate_human_action(state, player_id, actions)
# Gi·∫£ l·∫≠p h√†nh ƒë·ªông cho ng∆∞·ªùi ch∆°i (d·ª±a tr√™n heuristic ƒë∆°n gi·∫£n)
# ===========================================================================
func _simulate_human_action(state, player_id, actions):
	# ∆Øu ti√™n: Activate spell m·∫°nh
	for act in actions.details:
		if act.type == "PLAY_SPELL":
			var effect = CardDatabase.get(act.payload["card_id"]).get("effect", "")
			if effect in ["draw_2", "special_summon_graveyard", "destroy_all_monsters"]:
				return _with_player(act, player_id)  # ‚úÖ ƒê√£ c√≥ player_id
	# ∆Øu ti√™n 2: Summon qu√°i c√≥ ATK cao nh·∫•t
	var best_atk = -1
	var best_action = null
	for act in actions.details:
		if act.type == "PLAY_MONSTER":
			var atk = CardDatabase.get(act.payload["card_id"]).get("atk", 0)
			if atk > best_atk:
				best_atk = atk
				best_action = act
	if best_action:
		return _with_player(best_action, player_id)  # ‚úÖ
	# ∆Øu ti√™n 3: Attack qu√°i y·∫øu nh·∫•t
	if state["phase"] == "battle":
		var opponent_id = _get_opponent_id(state)
		var opponent = state["players"][opponent_id]
		var weakest_atk = 999999
		var weakest_zone = -1
		for i in range(5):
			if opponent["monster_zones"][i]:
				var atk = CardDatabase.get(opponent["monster_zones"][i].card_id).get("atk", 0)
				if atk < weakest_atk:
					weakest_atk = atk
					weakest_zone = i
		if weakest_zone != -1:
			for act in actions.details:
				if act.type == "DECLARE_ATTACK" and act.payload["target_zone"] == weakest_zone:
					return _with_player(act, player_id)  # ‚úÖ
		# Direct attack
		for act in actions.details:
			if act.type == "DECLARE_ATTACK" and not act.payload.has("target_zone"):
				return _with_player(act, player_id)  # ‚úÖ
	# ∆Øu ti√™n 4: Set trap/spell
	for act in actions.details:
		if act.type in ["SET_TRAP", "SET_SPELL"]:
			return _with_player(act, player_id)  # ‚úÖ
	# ∆Øu ti√™n 5: Set monster
	for act in actions.details:
		if act.type == "SET_MONSTER":
			return _with_player(act, player_id)  # ‚úÖ
	# ∆Øu ti√™n 6: END_PHASE ho·∫∑c END_TURN
	if state["phase"] == "end":
		for act in actions.details:
			if act.type == "END_TURN":
				return _with_player(act, player_id)  # ‚úÖ
		return _with_player({"type": "END_TURN", "payload": {}}, player_id)  # ‚úÖ
	for act in actions.details:
		if act.type == "END_PHASE":
			return _with_player(act, player_id)  # ‚úÖ
		if act.type == "END_TURN":
			return _with_player(act, player_id)  # ‚úÖ
	# Fallback
	return _with_player({"type": "END_TURN", "payload": {}}, player_id)  # ‚úÖ

func _with_player(action, player_id):
	var new_action = action.duplicate()
	new_action["player_id"] = player_id
	return new_action

# ===========================================================================
# _print_game_state(state)
# In tr·∫°ng th√°i tr·∫≠n ƒë·∫•u ƒë·ªÉ debug
# ===========================================================================
func _print_game_state(state):
	var player = state["players"][human_player]
	var opponent_id = _get_opponent_id(state)
	var opponent = state["players"][opponent_id]
	
	print("=== Tr·∫°ng th√°i tr·∫≠n ƒë·∫•u ===")
	print("L∆∞·ª£t: %s | Phase: %s | Turn count: %d" % [state["turn"], state["phase"], state["current_turn_count"]])
	print("Ng∆∞·ªùi ch∆°i %s: LP=%d, Hand=%d, Deck=%d" % [human_player, player["life_points"], len(player["hand"]), len(player["deck"])])
	for i in range(5):
		if player["monster_zones"][i]:
			var card = CardDatabase.get(player["monster_zones"][i].card_id)
			print("  Monster zone %d: %s (%s, ATK=%d, DEF=%d)" % [i, card["name"], player["monster_zones"][i].position, card["atk"], card["def"]])
		if player["spell_trap_zones"][i]:
			var card = CardDatabase.get(player["spell_trap_zones"][i].card_id)
			print("  Spell/Trap zone %d: %s (%s)" % [i, card["name"], player["spell_trap_zones"][i].status])
	print("ƒê·ªëi th·ªß %s: LP=%d, Hand=%d, Deck=%d" % [opponent_id, opponent["life_points"], len(opponent["hand"]), len(opponent["deck"])])
	for i in range(5):
		if opponent["monster_zones"][i]:
			var card = CardDatabase.get(opponent["monster_zones"][i].card_id)
			print("  Opponent Monster zone %d: %s (%s, ATK=%d, DEF=%d)" % [i, card["name"], opponent["monster_zones"][i].position, card["atk"], card["def"]])
		if opponent["spell_trap_zones"][i]:
			var card = CardDatabase.get(opponent["spell_trap_zones"][i].card_id)
			print("  Opponent Spell/Trap zone %d: %s (%s)" % [i, card["name"], opponent["spell_trap_zones"][i].status])
	if not state["chain"].empty():
		print("Chain: %s" % state["chain"])
	if state["winner"]:
		print("Ng∆∞·ªùi th·∫Øng: %s | L√Ω do: %s" % [state["winner"], state["win_reason"]])
	print("==========================")


# ===========================================================================
# _get_opponent_id(state)
# L·∫•y ID c·ªßa ƒë·ªëi th·ªß
# ===========================================================================
func _get_opponent_id(state):
	for pid in state["players"]:
		if pid != state["turn"]:
			return pid
	return null




================================================================================

--- FILE: server_yugiDuel\core\TrainBot.gd ---
# ===========================================================================
# train_agent.gd - Hu·∫•n luy·ªán Agent h·ªçc t·ª´ tr·∫≠n ƒë·∫•u Yu-Gi-Oh!
# D√πng Agent.gd (hybrid: Q-Learning + Rule-based response)
# ===========================================================================

extends Node

# S·ªë tr·∫≠n ƒë·ªÉ hu·∫•n luy·ªán
const TRAINING_GAMES = 100

# B·ªô b√†i m·∫´u
var deck = [
	"BLUE_EYES_WHITE_DRAGON",
	"DARK_MAGICIAN",
	"MIRROR_FORCE",
	"GYOUKI",
	"SACK",
	"EFFECT_VEILER",
	"BOOK_OF_MOON",
	"CARD_001",
	"CARD_002",
	"CARD_003"
]

# ===========================================================================
# _ready()
# B·∫Øt ƒë·∫ßu hu·∫•n luy·ªán
# ===========================================================================
func _ready():
	print("üöÄ B·∫Øt ƒë·∫ßu hu·∫•n luy·ªán Agent cho %d tr·∫≠n..." % TRAINING_GAMES)
	
	for i in range(TRAINING_GAMES):
		print("üéÆ Tr·∫≠n #%d" % (i + 1))
		_train_one_game(deck, deck)
	
	# L∆∞u model sau khi h·ªçc xong
	Agent.save_q_table()
	print("üéâ Ho√†n th√†nh hu·∫•n luy·ªán %d tr·∫≠n! Model ƒë√£ ƒë∆∞·ª£c l∆∞u." % TRAINING_GAMES)


# ===========================================================================
# _train_one_game(deck_a, deck_b)
# Ch·∫°y m·ªôt tr·∫≠n ƒë·∫•u gi·ªØa Agent v√† Bot (random)
# ===========================================================================
func _train_one_game(deck_a, deck_b):
	# Kh·ªüi t·∫°o tr·∫≠n ƒë·∫•u
	var room_id = BattleCore.start_duel("agent", "bot", deck_a, deck_b)
	if not room_id:
		print("‚ùå Kh√¥ng th·ªÉ kh·ªüi t·∫°o tr·∫≠n ƒë·∫•u")
		return
	
	var game_over = false
	var current_state = BattleCore.get_game_state(room_id, "agent")
	
	# V√≤ng l·∫∑p tr·∫≠n ƒë·∫•u
	while not game_over:
		var game_data = BattleCore.active_duels[room_id]
		if not game_data:
			break
		
		var current_player = game_data.turn
		
		if current_player == "agent":
			# L∆∞·ª£t c·ªßa Agent
			var available_actions = BattleCore.get_available_actions(room_id, "agent")
			if available_actions.empty():
				game_over = true
				continue
			
			# 1. Agent ch·ªçn h√†nh ƒë·ªông ch√≠nh
			var action_type = Agent.get_action(current_state, "agent", available_actions)
			var action = {
				"player_id": "agent",
				"type": action_type
			}
			
			# 2. ƒêi·ªÅn payload (c√≥ th·ªÉ m·ªü r·ªông sau)
			action.payload = _build_payload(action_type, current_state, "agent")
			
			# 3. G·ª≠i h√†nh ƒë·ªông
			var result = BattleCore.submit_action(room_id, action)
			
			# 4. H·ªçc t·ª´ k·∫øt qu·∫£
			Agent.learn_from_result(current_state, action, result)
			
			# 5. C·∫≠p nh·∫≠t tr·∫°ng th√°i
			var new_state = BattleCore.get_game_state(room_id, "agent")
			current_state = new_state
			
			# 6. X·ª≠ l√Ω s·ª± ki·ªán: c√≥ c·∫ßn ph·∫£n ·ª©ng kh√¥ng?
			var response = Agent.on_event(new_state, result.events, "agent")
			if response:
				var response_result = BattleCore.submit_action(room_id, response)
				# C√≥ th·ªÉ h·ªçc th√™m t·ª´ ph·∫£n ·ª©ng
				Agent.learn_from_result(new_state, response, response_result)
				current_state = BattleCore.get_game_state(room_id, "agent")
			
			# 7. Ki·ªÉm tra k·∫øt th√∫c
			if result.events.find({"type": "WIN"}) or new_state.status == "finished":
				game_over = true
				
		else:
			# L∆∞·ª£t c·ªßa bot ƒë·ªëi th·ªß (random)
			var available = BattleCore.get_available_actions(room_id, "bot")
			if available.empty():
				game_over = true
				continue
			
			var action_type = available[randi() % available.size()]
			var action = {
				"player_id": "bot",
				"type": action_type
			}
			
			# T·∫°o payload ƒë∆°n gi·∫£n
			action.payload = _build_payload(action_type, BattleCore.get_game_state(room_id, "bot"), "bot")
			
			BattleCore.submit_action(room_id, action)
		
		# Ki·ªÉm tra tr·∫°ng th√°i tr·∫≠n
		var duel = BattleCore.active_duels.get(room_id)
		if not duel or duel.status == "finished":
			game_over = true
	
	print("‚úÖ Tr·∫≠n ƒë·∫•u k·∫øt th√∫c.")


# ===========================================================================
# _build_payload(action_type, game_state, player_id)
# T·∫°o payload h·ª£p l·ªá cho h√†nh ƒë·ªông
# (C√≥ th·ªÉ m·ªü r·ªông th√†nh logic ch·ªçn b√†i th√¥ng minh)
# ===========================================================================
func _build_payload(action_type, game_state, player_id):
	var payload = {}
	var player = game_state.players[player_id]
	
	match action_type:
		"PLAY_MONSTER":
			# Ch·ªçn qu√°i ƒë·∫ßu ti√™n tr√™n tay
			for card_id in player.hand:
				if CardDatabase.exists(card_id):
					var card = CardDatabase.get(card_id)
					if card.type == "Monster":
						payload.card_id = card_id
						payload.from_zone = "hand"
						payload.to_zone = _find_empty_zone(player.monster_zones)
						payload.position = "face_up_attack"
						return payload
			return null  # Kh√¥ng c√≥ qu√°i
			
		"SET_MONSTER", "SET_SPELL", "SET_TRAP":
			payload.to_zone = _find_empty_zone(
				player.spell_trap_zones if "SPELL" in action_type or "TRAP" in action_type 
				else player.monster_zones
			)
			# T√¨m b√†i ph√π h·ª£p
			for card_id in player.hand:
				if CardDatabase.exists(card_id):
					var card = CardDatabase.get(card_id)
					if ("SPELL" in action_type and card.type == "Spell") or \
					   ("TRAP" in action_type and card.type == "Trap") or \
					   ("MONSTER" in action_type and card.type == "Monster"):
						payload.card_id = card_id
						return payload
			return null
			
		"PLAY_SPELL", "PLAY_TRAP":
			payload.to_zone = _find_empty_zone(player.spell_trap_zones)
			# T∆∞∆°ng t·ª± nh∆∞ tr√™n
			for card_id in player.hand:
				if CardDatabase.exists(card_id):
					var card = CardDatabase.get(card_id)
					if ("SPELL" in action_type and card.type == "Spell") or \
					   ("TRAP" in action_type and card.type == "Trap"):
						payload.card_id = card_id
						return payload
			return null
			
		"DECLARE_ATTACK":
			# T√¨m qu√°i t·∫•n c√¥ng
			for i in range(5):
				var card = player.monster_zones[i]
				if card and card.position == "face_up_attack" and not card.has("attacked_this_turn"):
					var opp = game_state.players[_get_opponent_id(game_state, player_id)]
					# T√¨m m·ª•c ti√™u
					for j in range(5):
						if opp.monster_zones[j]:
							payload.attacker = card.card_id
							payload.target = opp.monster_zones[j].card_id
							return payload
					# N·∫øu kh√¥ng c√≥ qu√°i ‚Üí t·∫•n c√¥ng tr·ª±c ti·∫øp
					payload.attacker = card.card_id
					payload.target = null
					return payload
			return null
			
		"CHANGE_POSITION":
			for i in range(5):
				var card = player.monster_zones[i]
				if card and card.position == "face_up_attack":
					payload.card_id = card.card_id
					payload.to_position = "defense"
					payload.face = "up"
					return payload
			return null
			
		"ACTIVATE_EFFECT":
			# T√¨m b√†i c√≥ th·ªÉ k√≠ch ho·∫°t
			for zone in player.monster_zones:
				if zone:
					payload.card_id = zone.card_id
					return payload
			for zone in player.spell_trap_zones:
				if zone and zone.status == "face_up":
					payload.card_id = zone.card_id
					return payload
			return null
			
		"END_TURN", "END_PHASE", "DRAW_CARD", "SURRENDER":
			# Kh√¥ng c·∫ßn payload
			pass
	
	return payload


# ===========================================================================
# H√†m h·ªó tr·ª£
# ===========================================================================
func _find_empty_zone(zones):
	for i in range(zones.size()):
		if zones[i] == null:
			return i
	return 0  # M·∫∑c ƒë·ªãnh

func _get_opponent_id(game_state, player_id):
	for pid in game_state.players.keys():
		if pid != player_id:
			return pid
	return null

================================================================================

--- FILE: server_yugiDuel\core\types\GameState.gd ---
# res://types/GameState.gd
class_name GameState

var room_id: String
var turn: String
var phase: String  # "draw", "standby", "main1", "battle", "main2", "end"
var players: Dictionary  # player_id ‚Üí PlayerState
var chain: Array = []    # Danh s√°ch hi·ªáu ·ª©ng ƒëang x·ª≠ l√Ω
var status: String = "active"
================================================================================

--- FILE: server_yugiDuel\core\types\PlayerState.gd ---
# res://types/PlayerState.gd
class_name PlayerState

var life_points: int = 8000
var deck: Array
var hand: Array
var graveyard: Array
var monster_zones: Array  # 5 √¥
var spell_trap_zones: Array  # 5 √¥
var extra_deck: Array
var field_zone  = null
================================================================================

--- FILE: server_yugiDuel\data\cards.json ---
{
  "BLUE_EYES_WHITE_DRAGON": {
    "id": "BLUE_EYES_WHITE_DRAGON",
    "name": "Blue-Eyes White Dragon",
    "type": "monster",
    "atk": 3000,
    "def": 2500,
    "level": 8,
    "attribute": "light",
    "effect": ""
  },
  "DARK_MAGICIAN": {
    "id": "DARK_MAGICIAN",
    "name": "Dark Magician",
    "type": "monster",
    "atk": 2500,
    "def": 2100,
    "level": 7,
    "attribute": "dark",
    "effect": ""
  },
  "SUMMONED_SKULL": {
    "id": "SUMMONED_SKULL",
    "name": "Summoned Skull",
    "type": "monster",
    "atk": 2500,
    "def": 1200,
    "level": 6,
    "attribute": "dark",
    "effect": ""
  },
  "GYOUKI": {
    "id": "GYOUKI",
    "name": "Gyouki",
    "type": "monster",
    "atk": 1500,
    "def": 1000,
    "level": 4,
    "attribute": "dark",
    "effect": ""
  },
  "POT_OF_GREED": {
    "id": "POT_OF_GREED",
    "name": "Pot of Greed",
    "type": "spell",
    "effect": "draw_2"
  },
  "MONSTER_REBORN": {
    "id": "MONSTER_REBORN",
    "name": "Monster Reborn",
    "type": "spell",
    "effect": "special_summon_graveyard"
  },
  "DARK_HOLE": {
    "id": "DARK_HOLE",
    "name": "Dark Hole",
    "type": "spell",
    "effect": "destroy_all_monsters"
  },
  "MIRROR_FORCE": {
    "id": "MIRROR_FORCE",
    "name": "Mirror Force",
    "type": "trap",
    "effect": "destroy_all_attackers"
  },
  "TRAP_HOLE": {
    "id": "TRAP_HOLE",
    "name": "Trap Hole",
    "type": "trap",
    "effect": "destroy_summoned_monster"
  },
  "SUIJIN": {
    "id": "SUIJIN",
    "name": "Suijin",
    "type": "monster",
    "atk": 2500,
    "def": 2400,
    "level": 7,
    "attribute": "water",
    "effect": "reduce_atk_0"
  }
}



================================================================================

