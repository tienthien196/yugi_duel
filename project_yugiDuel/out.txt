=== DUMP CODE T·ª™: E:\GODOT\yugi_duel\project_yugiDuel ===
Ch·ªâ dump c√°c file: .afinn, .c, .cfg, .conf, .cpp, .css, .gd, .go, .h, .hpp, .html, .ini, .java, .js, .json, .lark, .py, .rs, .toml, .ts, .yaml, .yml
================================================================================

--- FILE: autoload\agent.gd ---
# ===========================================================================
# Agent.gd - C·∫¨P NH·∫¨T: H·ªçc t·ª´ EVENTS v√† CHAIN (kh√¥ng ch·ªâ state/action)
# ===========================================================================

extends Node

# --- State ---
var current_game_state
var my_player_id
var learning_mode = true

# --- Q-Table (v·∫´n gi·ªØ ƒë·ªÉ ch·ªçn h√†nh ƒë·ªông ch√≠nh) ---
var q_table = {}
var learning_rate = 0.1
var discount_factor = 0.9
var exploration_rate = 0.3

# --- Rule-based Response Database (m·ªõi) ---
# Khi c√≥ event ‚Üí ph·∫£n ·ª©ng n√†o h·ª£p l√Ω?
var response_rules = {
	"TRIGGER_EFFECT": {
		"Mirror Force": ["ACTIVATE_EFFECT", "card_id", "Effect Veiler"],
		"Solemn Judgment": ["ACTIVATE_EFFECT", "card_id", "Infinite Emperor"]
	},
	"DAMAGE_STEP": {
		"common": ["ACTIVATE_EFFECT", "card_id", "Book of Moon"]
	}
}

# --- Feature Extraction ---
func _extract_state_key(game_state, player_id):
	var p = game_state["players"][player_id]
	var opp = game_state["players"][_get_opponent_id(game_state, player_id)]
	var my_lr = int(p.life_points / 2000)
	var opp_lr = int(opp.life_points / 2000)
	var my_mc = 0
	for m in p.monster_zones:
		if m: my_mc += 1
	var opp_mc = 0
	for m in opp.monster_zones:
		if m: opp_mc += 1
	return "%d_%d_%d_%d_%s" % [my_lr, opp_lr, my_mc, opp_mc, game_state["phase"]]

func _get_q_value(state_key, action):
	return q_table.get(state_key, {}).get(action, 0.0)

# ===========================================================================
# get_action(game_state, player_id, available_actions)
# Tr·∫£ v·ªÅ h√†nh ƒë·ªông ch√≠nh (l∆∞·ª£t c·ªßa t√¥i)
# ===========================================================================
func get_action(game_state, player_id, available_actions):
	my_player_id = player_id
	current_game_state = game_state.duplicate(true)
	
	var state_key = _extract_state_key(game_state, player_id)
	
	# Kh√°m ph√° ho·∫∑c khai th√°c
	if randf() < exploration_rate:
		return available_actions[randi() % available_actions.size()]
	
	var best_action = "END_TURN"
	var best_value = -1e9
	for action in available_actions:
		var q = _get_q_value(state_key, action)
		if q > best_value:
			best_value = q
			best_action = action
	return best_action

# ===========================================================================
# on_event(game_state, event_list)
# üÜï H√†m m·ªõi: Khi c√≥ s·ª± ki·ªán ‚Üí xem c√≥ c·∫ßn ph·∫£n ·ª©ng kh√¥ng?
# D√πng ƒë·ªÉ h·ªçc c√°ch "ƒë√°p l·∫°i hi·ªáu ·ª©ng"
# ===========================================================================
func on_event(game_state, events, player_id):
	my_player_id = player_id
	current_game_state = game_state.duplicate(true)
	
	for event in events:
		match event["type"]:
			"TRIGGER_EFFECT":
				return _handle_trigger_effect(game_state, event)
			"CHAIN_STARTED":
				return _handle_chain_started(game_state, event)
			"DAMAGE_STEP":
				return _handle_damage_step(game_state, event)
			"SUMMON":
				return _handle_summon_reaction(game_state, event)
	return null  # Kh√¥ng ph·∫£n ·ª©ng

# --- X·ª≠ l√Ω c√°c lo·∫°i event ---

func _handle_trigger_effect(game_state, event):
	var card_name = CardDatabase.get(event["card_id"]).name
	if response_rules.TRIGGER_EFFECT.has(card_name):
		var rule = response_rules.TRIGGER_EFFECT[card_name]
		if rule[0] == "ACTIVATE_EFFECT":
			var target_card = rule[2]
			if _has_card_in_hand(game_state, my_player_id, target_card):
				return {
					"type": "ACTIVATE_EFFECT",
					"payload": { "card_id": target_card }
				}
	return null

func _handle_summon_reaction(game_state, event):
	# N·∫øu ƒë·ªëi ph∆∞∆°ng tri·ªáu h·ªìi qu√°i m·∫°nh ‚Üí ch·∫∑n b·∫±ng b·∫´y
	var card_data = CardDatabase.get(event["card_id"])
	if card_data["attack"] >= 2500:
		if _has_card_in_hand(game_state, my_player_id, "MIRROR_FORCE"):
			return {
				"type": "PLAY_TRAP",
				"payload": { "card_id": "MIRROR_FORCE", "to_zone": 0 }
			}
	return null

func _handle_chain_started(game_state, event):
	# ƒêang trong chain ‚Üí c√≥ th·ªÉ ph·∫£n ·ª©ng
	return null  # T·∫°m th·ªùi kh√¥ng l√†m g√¨

func _handle_damage_step(game_state, event):
	return response_rules.get("DAMAGE_STEP", {}).get("common", null)

# --- H·ªó tr·ª£ ---

func _has_card_in_hand(game_state, player_id, card_id):
	return game_state["players"][player_id].hand.has(card_id)

func _get_opponent_id(game_state, player_id):
	for pid in game_state["players"].keys():
		if pid != player_id:
			return pid
	return null

# ===========================================================================
# learn_from_result(old_state, action, result)
# üÜï H·ªçc t·ª´ to√†n b·ªô result, kh√¥ng ch·ªâ reward
# ===========================================================================
func learn_from_result(old_state, action, result):
	if not result["success"]:
		return
	
	var new_state = result["game_state"]
	var events = result["events"]
	var state_key = _extract_state_key(old_state, action["player_id"])
	var next_key = _extract_state_key(new_state, action["player_id"])
	
	# T√≠nh reward t·ª´ events
	var reward = 0.0
	for event in events:
		match event["type"]:
			"DAMAGE":
				if event["target"] == action["player_id"]:
					reward -= event["amount"] / 100.0
				else:
					reward += event["amount"] / 100.0
			"WIN":
				if event["winner"] == action["player_id"]:
					reward += 10.0
				else:
					reward -= 10.0
			"SUMMON":
				var card = CardDatabase.get(event["card_id"])
				if card and card["attack"] > 2500:
					reward += 0.5
			"DESTROYED":
				if event["player"] == action["player_id"]:
					reward -= 1.0
				else:
					reward += 1.0
	
	# C·∫≠p nh·∫≠t Q-value
	var old_q = _get_q_value(state_key, action["type"])
	var future = 0.0
	if new_state["status"] != "finished":
		for a in ["END_TURN", "PLAY_MONSTER", "ACTIVATE_EFFECT"]:
			future = max(future, _get_q_value(next_key, a))
	var new_q = (1 - learning_rate) * old_q + learning_rate * (reward + discount_factor * future)
	
	if not q_table.has(state_key):
		q_table[state_key] = {}
	q_table[state_key][action["type"]] = new_q
	
	# üÜï H·ªçc t·ª´ events ƒë·ªÉ c·∫≠p nh·∫≠t response_rules
	_learn_from_events(events, action["player_id"])

func _learn_from_events(events, player_id):
	for event in events:
		if event["type"] == "TRIGGER_EFFECT" and event["card_id"] == "MIRROR_FORCE":
			# N·∫øu t√¥i kh√¥ng ph·∫£n ·ª©ng ‚Üí b·ªã thi·ªát ‚Üí n√™n h·ªçc d√πng Effect Veiler
			if _recently_lost_battle_due_to(event["card_id"]):
				_add_response_rule("TRIGGER_EFFECT", "Mirror Force", [
					"ACTIVATE_EFFECT", "card_id", "EFFECT_VEILER"
				])

func _add_response_rule(category, trigger, action):
	if not response_rules.has(category):
		response_rules[category] = {}
	response_rules[category][trigger] = action

func _recently_lost_battle_due_to(card_id):
	# C√≥ th·ªÉ l∆∞u log tr·∫≠n thua
	return false  # T·∫°m th·ªùi




================================================================================

--- FILE: autoload\BattleCore.gd ---
# ===========================================================================
# BattleCore.gd - Core x·ª≠ l√Ω tr·∫≠n ƒë·∫•u Yu-Gi-Oh! (Godot 3.6)
# Autoload Singleton - D√πng ƒë·ªÉ qu·∫£n l√Ω to√†n b·ªô logic tr·∫≠n ƒë·∫•u
# Kh√¥ng c·∫ßn UI, kh√¥ng c·∫ßn m·∫°ng - ch·ªâ c·∫ßn ch·∫°y trong Godot
# ===========================================================================

extends Node

# Danh s√°ch c√°c tr·∫≠n ƒëang di·ªÖn ra: room_id ‚Üí game_state
var active_duels = {}

# Th·ª© t·ª± c√°c phase trong m·ªôt l∆∞·ª£t
const TURN_PHASES = ["draw", "standby", "main1", "battle", "main2", "end"]

# C√°c l√Ω do chi·∫øn th·∫Øng
const WIN_REASON_LP_ZERO = "lp_zero"
const WIN_REASON_DECK_OUT = "deck_out"
const WIN_REASON_SURRENDER = "surrender"
const WIN_REASON_EXODIA = "exodia"
const WIN_REASON_FORFEIT = "forfeit"

# Error codes
const ERR_ROOM_NOT_FOUND = "ROOM_NOT_FOUND"
const ERR_DUEL_NOT_ACTIVE = "DUEL_NOT_ACTIVE"
const ERR_INVALID_PLAYER = "INVALID_PLAYER"
const ERR_NOT_YOUR_TURN = "NOT_YOUR_TURN"
const ERR_NOT_IN_DRAW_PHASE = "NOT_IN_DRAW_PHASE"
const ERR_NO_DRAW_FIRST_TURN = "NO_DRAW_FIRST_TURN"
const ERR_DECK_EMPTY = "DECK_EMPTY"
const ERR_CARD_NOT_IN_HAND = "CARD_NOT_IN_HAND"
const ERR_ZONE_OCCUPIED = "ZONE_OCCUPIED"
const ERR_NOT_IN_MAIN_PHASE = "NOT_IN_MAIN_PHASE"
const ERR_NOT_MONSTER_CARD = "NOT_MONSTER_CARD"
const ERR_NOT_SPELL_CARD = "NOT_SPELL_CARD"
const ERR_NOT_TRAP_CARD = "NOT_TRAP_CARD"
const ERR_SPELL_ZONE_OCCUPIED = "SPELL_ZONE_OCCUPIED"
const ERR_TRAP_ZONE_OCCUPIED = "TRAP_ZONE_OCCUPIED"
const ERR_INVALID_ZONE = "INVALID_ZONE"
const ERR_CANNOT_CHANGE_POS_THIS_TURN = "CANNOT_CHANGE_POS_THIS_TURN"
const ERR_SAME_POSITION = "SAME_POSITION"
const ERR_CARD_NOT_ON_FIELD = "CARD_NOT_ON_FIELD"
const ERR_NO_EFFECT = "NO_EFFECT"
const ERR_NOT_IN_BATTLE_PHASE = "NOT_IN_BATTLE_PHASE"
const ERR_INVALID_ATTACKER = "INVALID_ATTACKER"
const ERR_NOT_IN_ATTACK_POSITION = "NOT_IN_ATTACK_POSITION"
const ERR_ALREADY_ATTACKED = "ALREADY_ATTACKED"
const ERR_CANNOT_ATTACK_SUMMON_TURN = "CANNOT_ATTACK_SUMMON_TURN"
const ERR_CANNOT_DIRECT_ATTACK = "CANNOT_DIRECT_ATTACK"
const ERR_INVALID_TARGET = "INVALID_TARGET"
const ERR_INVALID_PHASE = "INVALID_PHASE"
const ERR_INVALID_CARD = "INVALID_CARD"

# ===========================================================================
# start_duel(player_a_id, player_b_id, deck_a, deck_b, rules)
# T·∫°o m·ªôt tr·∫≠n ƒë·∫•u m·ªõi
# ===========================================================================
func start_duel(player_a_id, player_b_id, deck_a, deck_b, rules = {}):
	var room_id: String = "duel_%d_%d" % [OS.get_unix_time(), randi() % 10000]



	
	# Validate deck
	for card_id in deck_a + deck_b:
		if not CardDatabase.exists(card_id):
			return _error(ERR_INVALID_CARD)
		if card_id in rules.get("forbidden_cards", []):
			return _error("FORBIDDEN_CARD_IN_DECK")
	
	# Sao ch√©p v√† x√°o b√†i
	var deck_a_copy = deck_a.duplicate(true)
	var deck_b_copy = deck_b.duplicate(true)
	_shuffle(deck_a_copy)
	_shuffle(deck_b_copy)
	
	# B·ªëc 5 b√†i ƒë·∫ßu
	var hand_a = _draw_cards(deck_a_copy, 5)
	var hand_b = _draw_cards(deck_b_copy, 5)
	
	# Ch·ªçn ai ƒëi tr∆∞·ªõc
	var first_player = [player_a_id, player_b_id][randi() % 2]
	
	# T·∫°o tr·∫°ng th√°i tr·∫≠n ƒë·∫•u
	var start_lp = rules.get("start_lp", 8000)
	var game_state = {
		"room_id": room_id,
		"turn": first_player,
		"phase": "draw",
		"current_turn_count": 1,
		"is_first_turn": true,
		"first_player": first_player,
		"players": {
			player_a_id: _create_player_state(player_a_id, deck_a_copy, hand_a, start_lp),
			player_b_id: _create_player_state(player_b_id, deck_b_copy, hand_b, start_lp)
		},
		"status": "active",
		"winner": null,
		"win_reason": null,
		"chain": [],
		"chain_trigger": null,  # L∆∞u h√†nh ƒë·ªông trigger chain
		"rules": {
			"start_lp": start_lp,
			"max_hand_size": rules.get("max_hand_size", 6),
			"forbidden_cards": rules.get("forbidden_cards", [])
		}
	}
	
	# L∆∞u v√†o h·ªá th·ªëng
	active_duels[room_id] = game_state
	print("‚úÖ BattleCore: Tr·∫≠n '%s' ƒë√£ kh·ªüi t·∫°o. Ng∆∞·ªùi ƒëi tr∆∞·ªõc: %s" % [room_id, first_player])
	var temp: String = room_id
	
	
	return temp


# ===========================================================================
# submit_action(room_id, action)
# X·ª≠ l√Ω h√†nh ƒë·ªông t·ª´ ng∆∞·ªùi ch∆°i ho·∫∑c bot
# Tr·∫£ v·ªÅ: { success, events, available_actions, errors }
# ===========================================================================
func submit_action(room_id, action):
	if not active_duels.has(room_id):
		return _error(ERR_ROOM_NOT_FOUND)
	
	var game_state = active_duels[room_id]
	if game_state["status"] != "active":
		return _error(ERR_DUEL_NOT_ACTIVE)
	
	var player_id = action.get("player_id", "")
	if not game_state["players"].has(player_id):
		return _error(ERR_INVALID_PLAYER)
	
	# Ki·ªÉm tra l∆∞·ª£t ƒëi (tr·ª´ khi chain ho·∫∑c quick effect)
	if game_state["turn"] != player_id and action["type"] != "ACTIVATE_EFFECT":
		if not _can_activate_effect_out_of_turn(game_state, action):
			return _error(ERR_NOT_YOUR_TURN)
	
	# X·ª≠ l√Ω h√†nh ƒë·ªông
	var result = _process_action(game_state, action)
	
	# C·∫≠p nh·∫≠t tr·∫°ng th√°i
	if result["success"] and action["type"] == "ACTIVATE_EFFECT":
		_resolve_chain(game_state, action)
	
	# C·∫≠p nh·∫≠t l·∫°i tr·∫°ng th√°i
	active_duels[room_id] = game_state
	
	# Ki·ªÉm tra ƒëi·ªÅu ki·ªán chi·∫øn th·∫Øng
	var win_check = _check_win_condition(game_state)
	if win_check.winner:
		game_state["winner"] = win_check.winner
		game_state["win_reason"] = win_check.reason
		game_state["status"] = "finished"
		result["events"].append({
			"type": "WIN",
			"winner": win_check.winner,
			"reason": win_check.reason
		})
	elif result["success"] and game_state["chain"].empty():
		_update_phase_if_needed(game_state)
	
	# G√°n danh s√°ch h√†nh ƒë·ªông kh·∫£ d·ª•ng
	result["available_actions"] = _get_available_actions(game_state, player_id)
	result["game_state"] = game_state.duplicate(true)
	
	return result


# ===========================================================================
# get_game_state(room_id, player_id)
# Tr·∫£ v·ªÅ tr·∫°ng th√°i tr·∫≠n, ·∫©n b√†i tr√™n tay ƒë·ªëi th·ªß
# ===========================================================================
func get_game_state(room_id, player_id):
	if not active_duels.has(room_id):
		return {}
	
	var game_state = active_duels[room_id].duplicate(true)
	var opponent_id = _get_opponent_id(game_state, player_id)
	
	if game_state["players"].has(opponent_id):
		var opponent = game_state["players"][opponent_id]
		opponent["hand"] = []  # ·∫®n b√†i
		opponent["hand_count"] = len(opponent["hand"])  # Gi·ªØ s·ªë l∆∞·ª£ng
	
	return game_state


# ===========================================================================
# get_available_actions(room_id, player_id)
# Tr·∫£ v·ªÅ danh s√°ch h√†nh ƒë·ªông h·ª£p l·ªá (d√πng cho bot)
# ===========================================================================
func get_available_actions(room_id, player_id):
	if not active_duels.has(room_id):
		return []
	var game_state = active_duels[room_id]
	return _get_available_actions(game_state, player_id)


# ===========================================================================
# end_duel(room_id, winner, reason)
# K·∫øt th√∫c tr·∫≠n ƒë·∫•u (d√πng cho test, l·ªói, v.v.)
# ===========================================================================
func end_duel(room_id, winner, reason = WIN_REASON_FORFEIT):
	if not active_duels.has(room_id):
		return
	var game_state = active_duels[room_id]
	game_state["winner"] = winner
	game_state["win_reason"] = reason
	game_state["status"] = "finished"
	print("üèÅ Tr·∫≠n '%s' k·∫øt th√∫c. Ng∆∞·ªùi th·∫Øng: %s | L√Ω do: %s" % [room_id, winner, reason])


# ===========================================================================
# H√ÄM X·ª¨ L√ù H√ÄNH ƒê·ªòNG
# ===========================================================================
func _process_action(game_state, action):
	var player_id = action["player_id"]
	var result = {
		"success": false,
		"events": [],
		"errors": []
	}
	
	match action["type"]:
		"DRAW_CARD":
			result = _action_draw_card(game_state, player_id)
		"PLAY_MONSTER":
			result = _action_play_monster(game_state, player_id, action["payload"])
		"SET_MONSTER":
			result = _action_set_monster(game_state, player_id, action["payload"])
		"PLAY_SPELL", "SET_SPELL":
			result = _action_play_spell(game_state, player_id, action["payload"], action["type"] == "SET_SPELL")
		"PLAY_TRAP", "SET_TRAP":
			result = _action_play_trap(game_state, player_id, action["payload"], action["type"] == "SET_TRAP")
		"END_TURN":
			result = _action_end_turn(game_state, player_id)
		"SURRENDER":
			result = _action_surrender(game_state, player_id)
		"CHANGE_POSITION":
			result = _action_change_position(game_state, player_id, action["payload"])
		"ACTIVATE_EFFECT":
			pass
			# result = _action_activate_effect(game_state, player_id, action["payload"])
		"DECLARE_ATTACK":
			result = _action_declare_attack(game_state, player_id, action["payload"])
		"END_PHASE":
			result = _action_end_phase(game_state, player_id)
		_:
			result["errors"].append("UNKNOWN_ACTION")
	
	if result["success"]:
		print("‚úÖ Action: %s | Player: %s" % [action["type"], player_id])
	else:
		var error_msg = result["errors"][0] if len(result["errors"]) > 0 else "Unknown"
		print("‚ùå Action failed: %s | Error: %s" % [action["type"], error_msg])
	
	return result


# ===========================================================================
# C√ÅC H√ÄM H√ÄNH ƒê·ªòNG CHI TI·∫æT
# ===========================================================================
func _action_draw_card(game_state, player_id):
	var player = game_state["players"][player_id]
	if game_state["phase"] != "draw":
		return _error(ERR_NOT_IN_DRAW_PHASE)
	if game_state["is_first_turn"] and player_id == game_state["first_player"]:
		return _error(ERR_NO_DRAW_FIRST_TURN)
	if player["deck"].empty():
		return _error(ERR_DECK_EMPTY)
	
	var card = player["deck"].pop_front()
	player["hand"].append(card)
	
	return {
		"success": true,
		"events": [
			{ "type": "DRAW_CARD", "card_id": card, "player": player_id }
		]
	}

func _action_play_monster(game_state, player_id, payload):
	var player = game_state["players"][player_id]
	var card_id = payload["card_id"]
	var to_zone = payload["to_zone"]
	var position = payload.get("position", "face_up_attack")

	if not player["hand"].has(card_id):
		return _error(ERR_CARD_NOT_IN_HAND)
	if to_zone < 0 or to_zone >= 5 or player["monster_zones"][to_zone] != null:
		return _error(ERR_ZONE_OCCUPIED)
	if not game_state["phase"] in ["main1", "main2"]:
		return _error(ERR_NOT_IN_MAIN_PHASE)
	if CardDatabase.get(card_id).get("type") != "monster":
		return _error(ERR_NOT_MONSTER_CARD)

	player["hand"].erase(card_id)
	player["monster_zones"][to_zone] = {
		"card_id": card_id,
		"position": position,
		"status": "summoned_this_turn",
		"attacked_this_turn": false
	}

	return {
		"success": true,
		"events": [
			{ "type": "SUMMON", "card_id": card_id, "player": player_id, "zone": to_zone }
		]
	}

func _action_set_monster(game_state, player_id, payload):
	var player = game_state["players"][player_id]
	var card_id = payload["card_id"]
	var to_zone = payload["to_zone"]

	if not player["hand"].has(card_id):
		return _error(ERR_CARD_NOT_IN_HAND)
	if to_zone < 0 or to_zone >= 5 or player["monster_zones"][to_zone] != null:
		return _error(ERR_ZONE_OCCUPIED)
	if not game_state["phase"] in ["main1", "main2"]:
		return _error(ERR_NOT_IN_MAIN_PHASE)
	if CardDatabase.get(card_id).get("type") != "monster":
		return _error(ERR_NOT_MONSTER_CARD)

	player["hand"].erase(card_id)
	player["monster_zones"][to_zone] = {
		"card_id": card_id,
		"position": "face_down_defense",
		"status": "set_this_turn",
		"attacked_this_turn": false
	}

	return {
		"success": true,
		"events": [
			{ "type": "SET_MONSTER", "card_id": card_id, "player": player_id, "zone": to_zone }
		]
	}

func _action_play_spell(game_state, player_id, payload, is_set):
	var player = game_state["players"][player_id]
	var card_id = payload["card_id"]
	var to_zone = payload["to_zone"]

	if not player["hand"].has(card_id):
		return _error(ERR_CARD_NOT_IN_HAND)
	if to_zone < 0 or to_zone >= 5 or player["spell_trap_zones"][to_zone] != null:
		return _error(ERR_SPELL_ZONE_OCCUPIED)
	if not game_state["phase"] in ["main1", "main2"]:
		return _error(ERR_NOT_IN_MAIN_PHASE)
	if CardDatabase.get(card_id).get("type") != "spell":
		return _error(ERR_NOT_SPELL_CARD)

	player["hand"].erase(card_id)
	var status = "face_down" if is_set else "face_up"
	player["spell_trap_zones"][to_zone] = {
		"card_id": card_id,
		"status": status
	}

	var event_type = "SET_SPELL" if is_set else "PLAY_SPELL"

	return {
		"success": true,
		"events": [
			{ "type": event_type, "card_id": card_id, "player": player_id, "zone": to_zone }
		]
	}

func _action_play_trap(game_state, player_id, payload, is_set):
	var player = game_state["players"][player_id]
	var card_id = payload["card_id"]
	var to_zone = payload["to_zone"]

	if not player["hand"].has(card_id):
		return _error(ERR_CARD_NOT_IN_HAND)
	if to_zone < 0 or to_zone >= 5 or player["spell_trap_zones"][to_zone] != null:
		return _error(ERR_TRAP_ZONE_OCCUPIED)
	if CardDatabase.get(card_id).get("type") != "trap":
		return _error(ERR_NOT_TRAP_CARD)

	player["hand"].erase(card_id)
	var status = "face_down" if is_set else "face_up"
	player["spell_trap_zones"][to_zone] = {
		"card_id": card_id,
		"status": status
	}

	var event_type = "SET_TRAP" if is_set else "ACTIVATE_TRAP"

	return {
		"success": true,
		"events": [
			{ "type": event_type, "card_id": card_id, "player": player_id, "zone": to_zone }
		]
	}

func _action_end_turn(game_state, player_id):
	if game_state["turn"] != player_id:
		return _error(ERR_NOT_YOUR_TURN)
	
	_reset_turn_flags(game_state["players"][player_id])
	game_state["turn"] = _get_opponent_id(game_state, player_id)
	game_state["phase"] = "draw"
	game_state["current_turn_count"] += 1
	game_state["is_first_turn"] = false
	game_state["chain"] = []
	game_state["chain_trigger"] = null

	return {
		"success": true,
		"events": [
			{ "type": "TURN_CHANGED", "next_player": game_state["turn"] }
		]
	}

func _action_surrender(game_state, player_id):
	var opponent_id = _get_opponent_id(game_state, player_id)
	game_state["winner"] = opponent_id
	game_state["win_reason"] = WIN_REASON_SURRENDER
	game_state["status"] = "finished"

	return {
		"success": true,
		"events": [
			{ "type": "WIN", "winner": opponent_id, "reason": WIN_REASON_SURRENDER }
		]
	}

func _action_change_position(game_state, player_id, payload):
	var player = game_state["players"][player_id]
	var zone_idx = payload["zone"]
	var to_position = payload["to_position"]  # e.g., "face_up_attack", "face_up_defense", "face_down_defense"

	if zone_idx < 0 or zone_idx >= 5 or player["monster_zones"][zone_idx] == null:
		return _error(ERR_INVALID_ZONE)
	var card_obj = player["monster_zones"][zone_idx]
	if card_obj.get("status") in ["summoned_this_turn", "set_this_turn"]:
		return _error(ERR_CANNOT_CHANGE_POS_THIS_TURN)
	if card_obj["position"] == to_position:
		return _error(ERR_SAME_POSITION)

	# Validate position
	if not to_position in ["face_up_attack", "face_up_defense", "face_down_defense"]:
		return _error("INVALID_POSITION")
	
	card_obj["position"] = to_position
	if to_position == "face_up_defense" and card_obj["position"] == "face_down_defense":
		# Flip summon
		return {
			"success": true,
			"events": [
				{ "type": "FLIP_SUMMON", "card_id": card_obj["card_id"], "zone": zone_idx, "player": player_id }
			]
		}

	return {
		"success": true,
		"events": [
			{ "type": "CHANGE_POSITION", "zone": zone_idx, "to_position": to_position, "player": player_id }
		]
	}

# func _resolve_effect(game_state, card_id, player, opponent, zone_type, zone_idx):
# 	var effect = CardDatabase.get(card_id).get("effect", "")
# 	var events = []

# 	match effect:
# 		"draw_2":
# 			var drawn = _draw_cards(player["deck"], 2)
# 			player["hand"] += drawn
# 			events.append({"type": "DRAW_EFFECT", "cards": drawn, "player": player["player_id"]})
# 		"special_summon_graveyard":
# 			if player["graveyard"].empty():
# 				return _error("NO_CARDS_IN_GRAVEYARD")
# 			var free_zone = _find_free_monster_zone(player)
# 			if free_zone == -1:
# 				return _error(ERR_ZONE_OCCUPIED)
# 			var summon_card = player["graveyard"].pop_back()
# 			player["monster_zones"][free_zone] = {
# 				"card_id": summon_card,
# 				"position": "face_up_attack",
# 				"status": "summoned_this_turn",
# 				"attacked_this_turn": false
# 			}
# 			events.append({"type": "SPECIAL_SUMMON", "card_id": summon_card, "zone": free_zone})
# 		"destroy_all_monsters":
# 			_destroy_all_monsters(player, opponent, events)
# 		"destroy_all_attackers":
# 			_destroy_all_attackers(opponent, events)
# 		"destroy_summoned_monster":
# 			_destroy_summoned_monster(opponent, events)
# 		"reduce_atk_0":
# 			if game_state["chain_trigger"] and game_state["chain_trigger"].type == "ATTACK_DECLARED":
# 				var atk_zone = game_state["chain_trigger"].attacker_zone
# 				var atk_player = game_state["players"][game_state["chain_trigger"].player_id]
# 				if atk_player.monster_zones[atk_zone]:
# 					var card_id_ = atk_player.monster_zones[atk_zone].card_id
# 					atk_player.monster_zones[atk_zone].temp_atk = 0
# 					events.append({
# 						"type": "ATK_MODIFIED",
# 						"card_id": card_id_,
# 						"new_atk": 0
# 					})
# 		_:
# 			return _error(ERR_NO_EFFECT)

# 	# X√≥a spell/trap sau khi d√πng (tr·ª´ continuous)
# 	if (zone_type == "spell_trap") and not effect  in ["continuous_effect"]:
# 		player["spell_trap_zones"][zone_idx] = null
# 		player["graveyard"].append(card_id)

# 	return {"success": true, "events": events}

func _action_declare_attack(game_state, player_id, payload):
	var player = game_state["players"][player_id]
	var opponent_id = _get_opponent_id(game_state, player_id)
	var opponent = game_state["players"][opponent_id]
	var atk_zone = payload["atk_zone"]
	var target_zone = payload.get("target_zone", -1)

	if game_state["phase"] != "battle":
		return _error(ERR_NOT_IN_BATTLE_PHASE)
	if atk_zone < 0 or atk_zone >= 5 or player["monster_zones"][atk_zone] == null:
		return _error(ERR_INVALID_ATTACKER)
	var attacker = player["monster_zones"][atk_zone]
	if attacker.position != "face_up_attack":
		return _error(ERR_NOT_IN_ATTACK_POSITION)
	if attacker.get("attacked_this_turn", false):
		return _error(ERR_ALREADY_ATTACKED)
	if attacker.get("status") == "summoned_this_turn":
		return _error(ERR_CANNOT_ATTACK_SUMMON_TURN)

	var events = []
	var atk = CardDatabase.get(attacker.card_id).get("atk", 0)

	# K√≠ch ho·∫°t chain cho attack
	game_state["chain_trigger"] = {"type": "ATTACK_DECLARED", "attacker_zone": atk_zone, "player_id": player_id}
	events.append({"type": "ATTACK_DECLARED", "attacker": attacker.card_id, "zone": atk_zone})

	if target_zone == -1:
		# Direct attack
		var has_monster = false
		for zone in opponent["monster_zones"]:
			if zone != null:
				has_monster = true
				break
		if has_monster:
			return _error(ERR_CANNOT_DIRECT_ATTACK)
		opponent["life_points"] = max(0, opponent["life_points"] - atk)
		events.append({"type": "DIRECT_ATTACK", "attacker": attacker.card_id, "damage": atk})
	else:
		if target_zone < 0 or target_zone >= 5 or opponent["monster_zones"][target_zone] == null:
			return _error(ERR_INVALID_TARGET)
		var target = opponent["monster_zones"][target_zone]
		var target_pos = target.position
		var target_val = CardDatabase.get(target.card_id).get("def", 0) if target_pos.contains("defense") else CardDatabase.get(target.card_id).get("atk", 0)

		# Flip if face down
		if target_pos == "face_down_defense":
			target.position = "face_up_defense"
			events.append({"type": "FLIP", "card_id": target.card_id})

		if atk > target_val:
			var damage = atk - target_val
			if target_pos.contains("defense"):
				damage = 0
			else:
				opponent["life_points"] = max(0, opponent["life_points"] - damage)
			opponent["monster_zones"][target_zone] = null
			opponent["graveyard"].append(target.card_id)
			events.append({"type": "DESTROY_TARGET", "damage": damage})
		elif atk == target_val:
			if not target_pos.contains("defense"):
				player["monster_zones"][atk_zone] = null
				player["graveyard"].append(attacker.card_id)
			opponent["monster_zones"][target_zone] = null
			opponent["graveyard"].append(target.card_id)
			events.append({"type": "DESTROY_BOTH"})
		else:
			var damage = target_val - atk
			player["life_points"] = max(0, player["life_points"] - damage)
			if not target_pos.contains("defense"):
				player["monster_zones"][atk_zone] = null
				player["graveyard"].append(attacker.card_id)
			events.append({"type": "REBOUND", "damage": damage})

	attacker.attacked_this_turn = true
	return {"success": true, "events": events}

func _action_end_phase(game_state, player_id):
	if game_state["turn"] != player_id:
		return _error(ERR_NOT_YOUR_TURN)
	var idx = TURN_PHASES.find(game_state["phase"])
	if idx == -1 or idx >= len(TURN_PHASES) - 1:
		return _error(ERR_INVALID_PHASE)
	game_state["phase"] = TURN_PHASES[idx + 1]
	var events = [{"type": "PHASE_CHANGED", "new_phase": game_state["phase"]}]
	
	if game_state["phase"] == "end":
		var player = game_state["players"][player_id]
		if len(player["hand"]) > game_state["rules"].max_hand_size:
			var discard_count = len(player["hand"]) - game_state["rules"].max_hand_size
			for i in range(discard_count):
				var card = player["hand"].pop_back()
				player["graveyard"].append(card)
			events.append({"type": "DISCARD_HAND", "count": discard_count})
	
	return {"success": true, "events": events}


# ===========================================================================
# H√ÄM H·ªñ TR·ª¢
# ===========================================================================
func _create_player_state(player_id, deck, hand, lp):
	return {
		"player_id": player_id,
		"life_points": lp,
		"deck": deck,
		"hand": hand,
		"graveyard": [],
		"banished": [],
		"extra_deck": [],
		"monster_zones": [null, null, null, null, null],
		"spell_trap_zones": [null, null, null, null, null],
		"field_zone": null,
		"pendulum_zones": [null, null]
	}

func _shuffle(array):
	var n = len(array)
	for i in range(n - 1, 0, -1):
		var j = randi() % (i + 1)
		var temp = array[i]
		array[i] = array[j]
		array[j] = temp
	return array

func _draw_cards(deck, count):
	var cards = []
	for i in range(min(count, len(deck))):
		cards.append(deck.pop_front())
	return cards

func _can_activate_effect_out_of_turn(game_state, action):
	if action["type"] != "ACTIVATE_EFFECT":
		return false
	var card_id = action["payload"].card_id
	var card_data = CardDatabase.get(card_id)
	return card_data.get("type") == "trap" or card_data.get("effect") in ["quick_effect"]  # M·ªü r·ªông sau

func _get_opponent_id(game_state, player_id):
	for pid in game_state["players"]:
		if pid != player_id:
			return pid
	return null

func _update_phase_if_needed(game_state):
	if game_state["phase"] == "draw" and game_state["chain"].empty():
		if not (game_state["is_first_turn"] and game_state["turn"] == game_state["first_player"]):
			var player = game_state["players"][game_state["turn"]]
			if not player["deck"].empty():
				var card = player["deck"].pop_front()
				player["hand"].append(card)
				print("Auto draw: %s" % card)
		game_state["phase"] = "standby"

func _get_available_actions(game_state, player_id):
	var actions = []
	var phase = game_state["phase"]
	var player = game_state["players"][player_id]
	var opponent_id = _get_opponent_id(game_state, player_id)
	
	var action_details = []
	if game_state["turn"] == player_id:
		action_details += [
			{"type": "END_PHASE"},
			{"type": "END_TURN"},
			{"type": "SURRENDER"}
		]
	
	if phase == "draw" and game_state["turn"] == player_id:
		if not (game_state["is_first_turn"] and player_id == game_state["first_player"]):
			action_details.append({"type": "DRAW_CARD"})
	
	if phase in ["main1", "main2"] and game_state["turn"] == player_id:
		for card_id in player["hand"]:
			var card_data = CardDatabase.get(card_id)
			var card_type = card_data.get("type", "")
			for i in range(5):
				if card_type == "monster" and player["monster_zones"][i] == null:
					action_details.append({
						"type": "PLAY_MONSTER",
						"payload": {"card_id": card_id, "to_zone": i, "position": "face_up_attack"}
					})
					action_details.append({
						"type": "SET_MONSTER",
						"payload": {"card_id": card_id, "to_zone": i}
					})
				elif card_type == "spell" and player["spell_trap_zones"][i] == null:
					action_details.append({
						"type": "PLAY_SPELL",
						"payload": {"card_id": card_id, "to_zone": i}
					})
					action_details.append({
						"type": "SET_SPELL",
						"payload": {"card_id": card_id, "to_zone": i}
					})
				elif card_type == "trap" and player["spell_trap_zones"][i] == null:
					action_details.append({
						"type": "PLAY_TRAP",
						"payload": {"card_id": card_id, "to_zone": i}
					})
					action_details.append({
						"type": "SET_TRAP",
						"payload": {"card_id": card_id, "to_zone": i}
					})
		for i in range(5):
			if player["monster_zones"][i] and not player["monster_zones"][i].get("status") in ["summoned_this_turn", "set_this_turn"]:
				for pos in ["face_up_attack", "face_up_defense", "face_down_defense"]:
					if pos != player["monster_zones"][i].position:
						action_details.append({
							"type": "CHANGE_POSITION",
							"payload": {"zone": i, "to_position": pos}
						})
			if player["monster_zones"][i] and CardDatabase.get(player["monster_zones"][i].card_id).get("effect") != "":
				action_details.append({
					"type": "ACTIVATE_EFFECT",
					"payload": {"card_id": player["monster_zones"][i].card_id, "zone_type": "monster"}
				})
			if player["spell_trap_zones"][i] and player["spell_trap_zones"][i].status == "face_up" and CardDatabase.get(player["spell_trap_zones"][i].card_id).get("effect") != "":
				action_details.append({
					"type": "ACTIVATE_EFFECT",
					"payload": {"card_id": player["spell_trap_zones"][i].card_id, "zone_type": "spell_trap"}
				})
	
	if phase == "battle" and game_state["turn"] == player_id:
		for i in range(5):
			if player["monster_zones"][i] and player["monster_zones"][i].position == "face_up_attack" and not player["monster_zones"][i].get("attacked_this_turn", false) and not player["monster_zones"][i].get("status") == "summoned_this_turn":
				var has_monster = false
				for j in range(5):
					if game_state["players"][opponent_id].monster_zones[j]:
						has_monster = true
						action_details.append({
							"type": "DECLARE_ATTACK",
							"payload": {"atk_zone": i, "target_zone": j}
						})
				if not has_monster:
					action_details.append({
						"type": "DECLARE_ATTACK",
						"payload": {"atk_zone": i}
					})
	
	# Th√™m h√†nh ƒë·ªông cho chain
	if not game_state["chain"].empty() and game_state["turn"] != player_id:
		for i in range(5):
			var card = player["spell_trap_zones"][i]
			if card and card["status"] == "face_down" and CardDatabase.get(card["card_id"]).get("type") == "trap":
				action_details.append({
					"type": "ACTIVATE_EFFECT",
					"payload": {"card_id": card["card_id"], "zone_type": "spell_trap"}
				})
	
	# Ch·ªâ l·∫•y type ƒë·ªÉ tr√°nh payload ascendedpayload d√†i
	for action in action_details:
		if not action["type"] in actions:
			actions.append(action["type"])
	
	return {"types": actions, "details": action_details}

func _resolve_chain(game_state, action):
	if game_state["chain"].empty():
		return
	
	# Resolve chain theo th·ª© t·ª± ng∆∞·ª£c
	var events = []
	for chain_link in game_state["chain"]:
		var card_id = chain_link["card_id"]
		var player_id = chain_link["player_id"]
		var zone_type = chain_link["zone_type"]
		var zone_idx = chain_link["zone_idx"]
		var player = game_state["players"][player_id]
		var opponent_id = _get_opponent_id(game_state, player_id)
		var opponent = game_state["players"][opponent_id]
		
		var resolve_result = _resolve_effect(game_state, card_id, player, opponent, zone_type, zone_idx)
		events += resolve_result.events
		if not resolve_result.success:
			return resolve_result
	
	game_state["chain"] = []
	game_state["chain_trigger"] = null
	return {"success": true, "events": events}

func _resolve_effect(game_state, card_id, player, opponent, zone_type, zone_idx):
	var effect = CardDatabase.get(card_id).get("effect", "")
	var events = []
	
	match effect:
		"draw_2":
			var drawn = _draw_cards(player["deck"], 2)
			player["hand"] += drawn
			events.append({"type": "DRAW_EFFECT", "cards": drawn, "player": player["player_id"]})
		"special_summon_graveyard":
			if player["graveyard"].empty():
				return _error("NO_CARDS_IN_GRAVEYARD")
			var summon_card = player["graveyard"].pop_back()
			var free_zone = -1
			for i in range(5):
				if player["monster_zones"][i] == null:
					free_zone = i
					break
			if free_zone == -1:
				return _error(ERR_ZONE_OCCUPIED)
			player["monster_zones"][free_zone] = {
				"card_id": summon_card,
				"position": "face_up_attack",
				"status": "summoned_this_turn",
				"attacked_this_turn": false
			}
			events.append({"type": "SPECIAL_SUMMON", "card_id": summon_card, "zone": free_zone})
		"destroy_all_monsters":
			for i in range(5):
				if player["monster_zones"][i]:
					player["graveyard"].append(player["monster_zones"][i].card_id)
					player["monster_zones"][i] = null
				if opponent["monster_zones"][i]:
					opponent["graveyard"].append(opponent["monster_zones"][i].card_id)
					opponent["monster_zones"][i] = null
			events.append({"type": "DESTROY_ALL_MONSTERS"})
		"destroy_all_attackers":
			for i in range(5):
				if opponent["monster_zones"][i] and opponent["monster_zones"][i].position.contains("attack"):
					opponent["graveyard"].append(opponent["monster_zones"][i].card_id)
					opponent["monster_zones"][i] = null
			events.append({"type": "DESTROY_MONSTERS", "player": opponent["player_id"]})
		"destroy_summoned_monster":
			var summoned = false
			for i in range(5):
				if opponent["monster_zones"][i] and opponent["monster_zones"][i].get("status") == "summoned_this_turn":
					opponent["graveyard"].append(opponent["monster_zones"][i].card_id)
					opponent["monster_zones"][i] = null
					summoned = true
					break
			if not summoned:
				return _error("NO_SUMMONED_MONSTER")
			events.append({"type": "DESTROY_MONSTER", "player": opponent["player_id"]})
		"reduce_atk_0":
			if game_state["chain_trigger"] and game_state["chain_trigger"].type == "ATTACK_DECLARED":
				var atk_zone = game_state["chain_trigger"].attacker_zone
				var atk_player = game_state["players"][game_state["chain_trigger"].player_id]
				if atk_player.monster_zones[atk_zone]:
					atk_player.monster_zones[atk_zone].atk_modifier = 0
					events.append({"type": "ATK_MODIFIED", "card_id": atk_player.monster_zones[atk_zone].card_id, "new_atk": 0})
		_:
			return _error(ERR_NO_EFFECT)
	
	# X√≥a card spell/trap sau khi activate (tr·ª´ continuous)
	if zone_type == "spell_trap" and not effect in ["continuous_effect"]:
		player["spell_trap_zones"][zone_idx] = null
		player["graveyard"].append(card_id)
	
	return {"success": true, "events": events}

func _check_win_condition(game_state):
	for pid in game_state["players"]:
		var p = game_state["players"][pid]
		if p.life_points <= 0:
			return {"winner": _get_opponent_id(game_state, pid), "reason": WIN_REASON_LP_ZERO}
		if len(p.deck) == 0 and game_state["phase"] == "draw":
			return {"winner": _get_opponent_id(game_state, pid), "reason": WIN_REASON_DECK_OUT}
		var exodia_pieces = ["EXODIA_HEAD", "LEFT_ARM", "RIGHT_ARM", "LEFT_LEG", "RIGHT_LEG"]
		var has_all_exodia = true
		for piece in exodia_pieces:
			if not piece in p.hand:
				has_all_exodia = false
				break
		if has_all_exodia:
			return {"winner": pid, "reason": WIN_REASON_EXODIA}
	return {"winner": null, "reason": null}

func _reset_turn_flags(player):
	for i in range(5):
		if player["monster_zones"][i]:
			player["monster_zones"][i].erase("status")
			player["monster_zones"][i].erase("attacked_this_turn")
			player["monster_zones"][i].erase("atk_modifier")

func _error(reason):
	return {
		"success": false,
		"errors": [reason],
		"events": [],
		"available_actions": []
	}




================================================================================

--- FILE: autoload\CardDatabase.gd ---
# ===========================================================================
# CardDatabase.gd - N·∫°p v√† qu·∫£n l√Ω to√†n b·ªô d·ªØ li·ªáu b√†i Yu-Gi-Oh!
# Autoload Singleton - D√πng ƒë·ªÉ truy v·∫•n th√¥ng tin b√†i
# ===========================================================================

extends Node

# L∆∞u to√†n b·ªô d·ªØ li·ªáu b√†i: card_id ‚Üí card_data
var cards = {}

# Signal ƒë·ªÉ th√¥ng b√°o l·ªói cho bot ho·∫∑c debug
signal card_database_error(error_code, message)

# Error codes
const ERR_FILE_NOT_FOUND = "FILE_NOT_FOUND"
const ERR_JSON_INVALID = "JSON_INVALID"
const ERR_CARD_INVALID = "CARD_INVALID"
const ERR_CARD_NOT_FOUND = "CARD_NOT_FOUND"
const PATH_CARDS = "res://data/cards.json"

# ===========================================================================
# _ready()
# T·ª± ƒë·ªông n·∫°p file JSON khi game kh·ªüi ƒë·ªông
# ===========================================================================
func _ready():
	randomize()  # C·∫ßn cho randi()
	var error = _load_cards(PATH_CARDS)
	if error:
		emit_signal("card_database_error", error[0], error[1])
		push_error("‚ùå CardDatabase: Kh√¥ng th·ªÉ n·∫°p cards.json - %s" % error[1])
	else:
		print("‚úÖ CardDatabase: ƒê√£ n·∫°p %d l√° b√†i." % cards.size())


# ===========================================================================
# _load_cards(path)
# N·∫°p file JSON v√† l∆∞u v√†o b·ªô nh·ªõ
# Tr·∫£ v·ªÅ [error_code, message] n·∫øu c√≥ l·ªói, null n·∫øu th√†nh c√¥ng
# ===========================================================================
func _load_cards(path):
	if not File.new().file_exists(path):
		return [ERR_FILE_NOT_FOUND, "File kh√¥ng t·ªìn t·∫°i: %s" % path]

	var file = File.new()
	var err = file.open(path, File.READ)
	if err != OK:
		return [ERR_FILE_NOT_FOUND, "Kh√¥ng th·ªÉ m·ªü file: %s (m√£ l·ªói: %d)" % [path, err]]

	var json_data = file.get_as_text()
	file.close()

	if json_data.empty():
		return [ERR_JSON_INVALID, "File JSON r·ªóng: %s" % path]

	var parse_result = JSON.parse(json_data)
	if parse_result.error != OK:
		return [ERR_JSON_INVALID, "L·ªói parse JSON t·∫°i d√≤ng %d: %s" % [parse_result.error_line, parse_result.error_string]]

	var data = parse_result.result
	if typeof(data) != TYPE_DICTIONARY:
		return [ERR_JSON_INVALID, "JSON kh√¥ng ph·∫£i object: %s" % path]

	# Validate v√† g√°n
	cards = {}
	for card_id in data:
		var card = data[card_id]
		var error = _validate_card(card_id, card)
		if error:
			print("card ko hop le: %s | %s"% [card_id, error])
			emit_signal("card_database_error", ERR_CARD_INVALID, "Card %s kh√¥ng h·ª£p l·ªá: %s" % [card_id, error])
			continue
		cards[card_id] = card

	return null


# ===========================================================================
# _validate_card(card_id, card)
# Ki·ªÉm tra d·ªØ li·ªáu l√° b√†i h·ª£p l·ªá
# Tr·∫£ v·ªÅ null n·∫øu ok, ho·∫∑c string m√¥ t·∫£ l·ªói
# ===========================================================================

#json parse tr·∫£ v·ªÅ type_real ko ph·∫£i type INT
func _validate_card(card_id, card):
	if not card is Dictionary:
		return "Kh√¥ng ph·∫£i dictionary"

	# T·ª± ƒë·ªông ƒëi·ªÅn ID n·∫øu thi·∫øu
	if not card.has("id") or card["id"] != card_id:
		card["id"] = card_id  # T·ª± s·ª≠a

	if not card.has("name"):
		push_warning("Card %s thi·∫øu 'name'" % card_id)
		card["name"] = card_id

	if not card.has("type") or not card["type"]  in ["monster", "spell", "trap"]:
		return "Thi·∫øu ho·∫∑c type kh√¥ng h·ª£p l·ªá: %s" % card.get("type", "missing")

	if card["type"] == "monster":
		# Ki·ªÉm tra atk
		if not card.has("atk"):
			return "Monster thi·∫øu atk"
		var atk = card["atk"]
		if typeof(atk) != TYPE_INT and typeof(atk) != TYPE_REAL:
			return "atk ph·∫£i l√† s·ªë (hi·ªán t·∫°i: %s, ki·ªÉu: %s)" % [str(atk), typeof(atk)]
		if int(atk) < 0:
			return "atk kh√¥ng ƒë∆∞·ª£c √¢m"
		card["atk"] = int(atk)

		# Ki·ªÉm tra def
		if not card.has("def"):
			return "Monster thi·∫øu def"
		var def_val = card["def"]
		if typeof(def_val) != TYPE_INT and typeof(def_val) != TYPE_REAL:
			return "def ph·∫£i l√† s·ªë"
		if int(def_val) < 0:
			return "def kh√¥ng ƒë∆∞·ª£c √¢m"
		card["def"] = int(def_val)

	if card["type"] in ["spell", "trap"]:
		if not card.has("effect"):
			push_warning("Card %s thi·∫øu 'effect'" % card_id)
			card["effect"] = ""

	return null


# ===========================================================================
# get(card_id) ‚Üí Dictionary
# L·∫•y d·ªØ li·ªáu l√° b√†i theo ID
# Tr·∫£ v·ªÅ {} n·∫øu kh√¥ng t√¨m th·∫•y
# ===========================================================================
func get(card_id):
	if cards.has(card_id):
		return cards[card_id].duplicate()  # Tr·∫£ b·∫£n sao
	else:
		emit_signal("card_database_error", ERR_CARD_NOT_FOUND, "Kh√¥ng t√¨m th·∫•y b√†i v·ªõi ID '%s'" % card_id)
		return {}


# ===========================================================================
# exists(card_id) ‚Üí bool
# Ki·ªÉm tra b√†i c√≥ t·ªìn t·∫°i kh√¥ng
# ===========================================================================
func exists(card_id):
	return cards.has(card_id)


# ===========================================================================
# find_by_name(name) ‚Üí Array[card]
# T√¨m b√†i theo t√™n (ph·∫ßn trƒÉm tr√πng kh·ªõp - ƒë∆°n gi·∫£n)
# ===========================================================================
func find_by_name(name):
	name = name.to_lower()
	var results = []
	for card_id in cards:
		var card = cards[card_id]
		if str(card.get("name", "")).to_lower().find(name) != -1:
			results.append(card.duplicate())
	return results


# ===========================================================================
# get_cards_by_type(type) ‚Üí Array[card]
# L·∫•y t·∫•t c·∫£ b√†i theo type (monster, spell, trap)
# ===========================================================================
func get_cards_by_type(type):
	var results = []
	for card_id in cards:
		if cards[card_id].get("type") == type:
			results.append(cards[card_id].duplicate())
	return results


# ===========================================================================
# get_random_card(type=null) ‚Üí Dictionary
# L·∫•y ng·∫´u nhi√™n m·ªôt l√° b√†i, t√πy ch·ªçn l·ªçc theo type
# ===========================================================================
func get_random_card(type=null):
	var valid_cards = cards.keys()
	if type:
		var filtered_cards = []
		for id in valid_cards:
			if cards[id].get("type") == type:
				filtered_cards.append(id)
		valid_cards = filtered_cards
	if valid_cards.empty():
		return {}
	var card_id = valid_cards[randi() % valid_cards.size()]
	return cards[card_id].duplicate()


# ===========================================================================
# get_all() ‚Üí Dictionary
# Tr·∫£ v·ªÅ to√†n b·ªô c∆° s·ªü d·ªØ li·ªáu (d√πng cho debug)
# ===========================================================================
func get_all():
	return cards.duplicate(true)




================================================================================

--- FILE: autoload\YugiBot.gd ---
# ===========================================================================
# YugiBot.gd - Bot ch∆°i Yu-Gi-Oh! th·ªß c√¥ng (Godot 3.6)
# Autoload Singleton - T·ª± ƒë·ªông ch·ªçn v√† th·ª±c hi·ªán h√†nh ƒë·ªông d·ª±a tr√™n heuristic
# Kh√¥ng c·∫ßn UI, kh√¥ng c·∫ßn m·∫°ng, t√≠ch h·ª£p v·ªõi BattleCore v√† CardDatabase
# ===========================================================================

extends Node

# ===========================================================================
# play_turn(room_id, player_id)
# Bot th·ª±c hi·ªán to√†n b·ªô l∆∞·ª£t c·ªßa player_id trong room_id
# Tr·∫£ v·ªÅ: { success: bool, action_taken: Dictionary, result: Dictionary }
# ===========================================================================
func play_turn(room_id, player_id):
	var state = BattleCore.get_game_state(room_id, player_id)
	if state.empty():
		return {"success": false, "action_taken": {}, "result": {"errors": ["ROOM_NOT_FOUND"]}}
	
	if state["status"] != "active" or state["turn"] != player_id:
		return {"success": false, "action_taken": {}, "result": {"errors": ["NOT_YOUR_TURN"]}}
	
	var actions = BattleCore.get_available_actions(room_id, player_id)
	var action = _choose_action(state, player_id, actions)
	
	if action["type"] == "":
		return {"success": false, "action_taken": {}, "result": {"errors": ["NO_ACTION_CHOSEN"]}}
	
	var result = BattleCore.submit_action(room_id, action)
	return {"success": result["success"], "action_taken": action, "result": result}


# ===========================================================================
# _choose_action(state, player_id, actions)
# Ch·ªçn h√†nh ƒë·ªông t·ªëi ∆∞u d·ª±a tr√™n heuristic
# Tr·∫£ v·ªÅ: Dictionary {type, player_id, payload}
# ===========================================================================
func _choose_action(state, player_id, actions):
	var phase = state["phase"]
	var player = state["players"][player_id]
	var opponent_id = _get_opponent_id(state)
	var opponent = state["players"][opponent_id]
	
	var action = {"type": "", "player_id": player_id, "payload": {}}
	
	# X·ª≠ l√Ω chain tr∆∞·ªõc (n·∫øu c√≥)
	if not state["chain"].empty():
		var trap_action = _choose_trap_action(state, player_id, actions.details)
		if trap_action.type != "":
			return trap_action
	
	# X·ª≠ l√Ω theo phase
	if phase == "draw" and "DRAW_CARD" in actions.types:
		return {"type": "DRAW_CARD", "player_id": player_id, "payload": {}}
	
	if phase in ["main1", "main2"]:
		var main_action = _choose_main_phase_action(state, player_id, actions.details)
		if main_action.type != "":
			return main_action
	
	if phase == "battle":
		var attack_action = _choose_attack_action(state, player_id, actions.details)
		if attack_action.type != "":
			return attack_action
	
	# N·∫øu kh√¥ng c√≥ h√†nh ƒë·ªông t·ªëi ∆∞u, end phase ho·∫∑c turn
	if "END_PHASE" in actions.types:
		return {"type": "END_PHASE", "player_id": player_id, "payload": {}}
	if "END_TURN" in actions.types:
		return {"type": "END_TURN", "player_id": player_id, "payload": {}}
	
	return action


# ===========================================================================
# _choose_main_phase_action(state, player_id, action_details)
# Ch·ªçn h√†nh ƒë·ªông trong main phase (summon, spell, trap)
# ===========================================================================
func _choose_main_phase_action(state, player_id, action_details):
	var player = state["players"][player_id]
	var action = {"type": "", "player_id": player_id, "payload": {}}
	
	# ∆Øu ti√™n 1: Activate spell c√≥ effect m·∫°nh (Pot of Greed, Monster Reborn, Dark Hole)
	for act in action_details:
		if act.type == "PLAY_SPELL":
			var card_id = act.payload["card_id"]
			var effect = CardDatabase.get(card_id).get("effect", "")
			if effect in ["draw_2", "special_summon_graveyard", "destroy_all_monsters"]:
				return act
	
	# ∆Øu ti√™n 2: Summon qu√°i c√≥ ATK cao nh·∫•t
	var best_monster = null
	var best_atk = -1
	var monster_action = null
	for act in action_details:
		if act.type == "PLAY_MONSTER":
			var card_id = act.payload["card_id"]
			var atk = CardDatabase.get(card_id).get("atk", 0)
			if atk > best_atk:
				best_atk = atk
				best_monster = card_id
				monster_action = act
	if monster_action:
		return monster_action
	
	# ∆Øu ti√™n 3: Set trap
	for act in action_details:
		if act.type == "SET_TRAP":
			return act
	
	# ∆Øu ti√™n 4: Set spell
	for act in action_details:
		if act.type == "SET_SPELL":
			return act
	
	# ∆Øu ti√™n 5: Set monster n·∫øu kh√¥ng summon ƒë∆∞·ª£c
	for act in action_details:
		if act.type == "SET_MONSTER":
			return act
	
	# ∆Øu ti√™n 6: Activate effect tr√™n s√¢n
	for act in action_details:
		if act.type == "ACTIVATE_EFFECT":
			var card_id = act.payload["card_id"]
			var effect = CardDatabase.get(card_id).get("effect", "")
			if effect != "":
				return act
	
	return action


# ===========================================================================
# _choose_attack_action(state, player_id, action_details)
# Ch·ªçn h√†nh ƒë·ªông t·∫•n c√¥ng (∆∞u ti√™n qu√°i y·∫øu nh·∫•t c·ªßa ƒë·ªëi th·ªß)
# ===========================================================================
func _choose_attack_action(state, player_id, action_details):
	var player = state["players"][player_id]
	var opponent_id = _get_opponent_id(state)
	var opponent = state["players"][opponent_id]
	var action = {"type": "", "player_id": player_id, "payload": {}}
	
	# T√¨m qu√°i m·∫°nh nh·∫•t c·ªßa m√¨nh
	var best_atk = -1
	var best_atk_zone = -1
	for i in range(5):
		if player["monster_zones"][i] and player["monster_zones"][i].position == "face_up_attack" and not player["monster_zones"][i].get("attacked_this_turn", false):
			var atk = CardDatabase.get(player["monster_zones"][i].card_id).get("atk", 0)
			if atk > best_atk:
				best_atk = atk
				best_atk_zone = i
	
	if best_atk_zone == -1:
		return action
	
	# Direct attack n·∫øu ƒë·ªëi th·ªß kh√¥ng c√≥ qu√°i
	var has_monster = false
	for zone in opponent["monster_zones"]:
		if zone != null:
			has_monster = true
			break
	if not has_monster:
		for act in action_details:
			if act.type == "DECLARE_ATTACK" and act.payload["atk_zone"] == best_atk_zone and not act.payload.has("target_zone"):
				return act
	
	# T·∫•n c√¥ng qu√°i y·∫øu nh·∫•t c·ªßa ƒë·ªëi th·ªß
	var weakest_atk = 999999
	var weakest_zone = -1
	for i in range(5):
		if opponent["monster_zones"][i]:
			var atk = CardDatabase.get(opponent["monster_zones"][i].card_id).get("atk", 0)
			if atk < weakest_atk:
				weakest_atk = atk
				weakest_zone = i
	
	if weakest_zone != -1:
		for act in action_details:
			if act.type == "DECLARE_ATTACK" and act.payload["atk_zone"] == best_atk_zone and act.payload["target_zone"] == weakest_zone:
				return act
	
	return action


# ===========================================================================
# _choose_trap_action(state, player_id, action_details)
# Ch·ªçn trap ƒë·ªÉ k√≠ch ho·∫°t trong chain
# ===========================================================================
func _choose_trap_action(state, player_id, action_details):
	var action = {"type": "", "player_id": player_id, "payload": {}}
	
	if state["chain_trigger"] and state["chain_trigger"].type == "ATTACK_DECLARED":
		for act in action_details:
			if act.type == "ACTIVATE_EFFECT":
				var card_id = act.payload["card_id"]
				var effect = CardDatabase.get(card_id).get("effect", "")
				if effect in ["destroy_all_attackers", "destroy_summoned_monster", "reduce_atk_0"]:
					return act
	
	if state["chain_trigger"] and state["chain_trigger"].type == "SUMMON":
		for act in action_details:
			if act.type == "ACTIVATE_EFFECT" and CardDatabase.get(act.payload["card_id"]).get("effect") == "destroy_summoned_monster":
				return act
	
	return action


# ===========================================================================
# _get_opponent_id(state)
# L·∫•y ID c·ªßa ƒë·ªëi th·ªß
# ===========================================================================
func _get_opponent_id(state):
	for pid in state["players"]:
		if pid != state["turn"]:
			return pid
	return null



================================================================================

--- FILE: core\main.gd ---
# ===========================================================================
# Main.gd - Scene ch√≠nh ƒë·ªÉ test h·ªá th·ªëng Yu-Gi-Oh! (Godot 3.6)
# Kh·ªüi t·∫°o tr·∫≠n ƒë·∫•u, ƒë·ªÉ YugiBot ch∆°i t·ª± ƒë·ªông v√† gi·∫£ l·∫≠p ng∆∞·ªùi ch∆°i
# Kh√¥ng d√πng UI, ch·ªâ in k·∫øt qu·∫£ qua console
# ===========================================================================

extends Node

var room_id = ""
var human_player = "player_a"
var bot_player = "player_b"

# ===========================================================================
# _ready()
# Kh·ªüi t·∫°o tr·∫≠n ƒë·∫•u khi scene ch·∫°y
# ===========================================================================
func _ready():
	# ƒê·∫£m b·∫£o CardDatabase ƒë√£ n·∫°p
	if CardDatabase.get_all().empty():
		print("‚ùå L·ªói: CardDatabase ch∆∞a n·∫°p d·ªØ li·ªáu!")
		return
	
	# T·∫°o deck m·∫´u
	var deck_a = [
		"BLUE_EYES_WHITE_DRAGON", "BLUE_EYES_WHITE_DRAGON",
		"POT_OF_GREED", "MONSTER_REBORN", "DARK_HOLE",
		"SUMMONED_SKULL", "GYOUKI"
	]
	var deck_b = [
		"DARK_MAGICIAN", "DARK_MAGICIAN",
		"MIRROR_FORCE", "TRAP_HOLE", "SUIJIN",
		"GYOUKI", "SUMMONED_SKULL"
	]
	
	# Kh·ªüi t·∫°o tr·∫≠n ƒë·∫•u
	room_id = BattleCore.start_duel(human_player, bot_player, deck_a, deck_b, {
		"start_lp": 8000,
		"max_hand_size": 6,
		"forbidden_cards": []
	})
	print("this is room", room_id)
	if room_id == "":
		print("‚ùå L·ªói: Kh√¥ng th·ªÉ t·∫°o tr·∫≠n ƒë·∫•u!")
		return
	
	print("üéÆ Tr·∫≠n ƒë·∫•u b·∫Øt ƒë·∫ßu: %s" % room_id)
	_play_next_turn()


# ===========================================================================
# _play_next_turn()
# X·ª≠ l√Ω l∆∞·ª£t ti·∫øp theo, g·ªçi bot ho·∫∑c gi·∫£ l·∫≠p ng∆∞·ªùi ch∆°i
# ===========================================================================
func _play_next_turn():
	var state = BattleCore.get_game_state(room_id, human_player)
	if state.empty():
		print("‚ùå L·ªói: Kh√¥ng t√¨m th·∫•y tr·∫≠n ƒë·∫•u %s" % room_id)
		return
	
	if state["status"] != "active":
		print("üèÅ Tr·∫≠n ƒë·∫•u k·∫øt th√∫c! Ng∆∞·ªùi th·∫Øng: %s | L√Ω do: %s" % [state["winner"], state["win_reason"]])
		return
	
	# In tr·∫°ng th√°i hi·ªán t·∫°i
	_print_game_state(state)
	
	if state["turn"] == bot_player:
		# Bot ch∆°i
		var bot_result = YugiBot.play_turn(room_id, bot_player)
		if bot_result.success:
			print("ü§ñ Bot action: %s" % bot_result.action_taken)
			print("üìà K·∫øt qu·∫£: %s" % bot_result.result["events"])
		else:
			print("‚ùå Bot th·∫•t b·∫°i: %s" % bot_result.result["errors"])
	else:
		# Gi·∫£ l·∫≠p ng∆∞·ªùi ch∆°i
		var actions = BattleCore.get_available_actions(room_id, human_player)
		var action = _simulate_human_action(state, human_player, actions)
		var result = BattleCore.submit_action(room_id, action)
		if result["success"]:
			print("üë§ Human action: %s" % action)
			print("üìà K·∫øt qu·∫£: %s" % result["events"])
		else:
			print("‚ùå Human th·∫•t b·∫°i: %s" % result["errors"])
	
	# Ti·∫øp t·ª•c l∆∞·ª£t sau (v·ªõi delay ƒë·ªÉ d·ªÖ theo d√µi)
	yield(get_tree().create_timer(1.0), "timeout")
	_play_next_turn()


# ===========================================================================
# _simulate_human_action(state, player_id, actions)
# Gi·∫£ l·∫≠p h√†nh ƒë·ªông cho ng∆∞·ªùi ch∆°i (d·ª±a tr√™n heuristic ƒë∆°n gi·∫£n)
# ===========================================================================
func _simulate_human_action(state, player_id, actions):
	# ∆Øu ti√™n: Summon qu√°i m·∫°nh, activate spell m·∫°nh, attack qu√°i y·∫øu
	var best_action = {"type": "", "player_id": player_id, "payload": {}}
	
	# ∆Øu ti√™n 1: Activate spell m·∫°nh
	for act in actions.details:
		if act.type == "PLAY_SPELL":
			var effect = CardDatabase.get(act.payload["card_id"]).get("effect", "")
			if effect in ["draw_2", "special_summon_graveyard", "destroy_all_monsters"]:
				return act
	
	# ∆Øu ti√™n 2: Summon qu√°i c√≥ ATK cao nh·∫•t
	var best_atk = -1
	for act in actions.details:
		if act.type == "PLAY_MONSTER":
			var atk = CardDatabase.get(act.payload["card_id"]).get("atk", 0)
			if atk > best_atk:
				best_atk = atk
				best_action = act
	
	if best_action.type != "":
		return best_action
	
	# ∆Øu ti√™n 3: Attack qu√°i y·∫øu nh·∫•t
	if state["phase"] == "battle":
		var opponent_id = _get_opponent_id(state)
		var opponent = state["players"][opponent_id]
		var weakest_atk = 999999
		var weakest_zone = -1
		for i in range(5):
			if opponent["monster_zones"][i]:
				var atk = CardDatabase.get(opponent["monster_zones"][i].card_id).get("atk", 0)
				if atk < weakest_atk:
					weakest_atk = atk
					weakest_zone = i
		if weakest_zone != -1:
			for act in actions.details:
				if act.type == "DECLARE_ATTACK" and act.payload.has("target_zone") and act.payload["target_zone"] == weakest_zone:
					return act
	
	# ∆Øu ti√™n 4: Direct attack
	for act in actions.details:
		if act.type == "DECLARE_ATTACK" and not act.payload.has("target_zone"):
			return act
	
	# ∆Øu ti√™n 5: Set trap/spell
	for act in actions.details:
		if act.type in ["SET_TRAP", "SET_SPELL"]:
			return act
	
	# M·∫∑c ƒë·ªãnh: End phase ho·∫∑c turn
	for act in actions.details:
		if act.type == "END_PHASE":
			return act
		if act.type == "END_TURN":
			return act
	
	return {"type": "END_TURN", "player_id": player_id, "payload": {}}


# ===========================================================================
# _print_game_state(state)
# In tr·∫°ng th√°i tr·∫≠n ƒë·∫•u ƒë·ªÉ debug
# ===========================================================================
func _print_game_state(state):
	var player = state["players"][human_player]
	var opponent_id = _get_opponent_id(state)
	var opponent = state["players"][opponent_id]
	
	print("=== Tr·∫°ng th√°i tr·∫≠n ƒë·∫•u ===")
	print("L∆∞·ª£t: %s | Phase: %s | Turn count: %d" % [state["turn"], state["phase"], state["current_turn_count"]])
	print("Ng∆∞·ªùi ch∆°i %s: LP=%d, Hand=%d, Deck=%d" % [human_player, player["life_points"], len(player["hand"]), len(player["deck"])])
	for i in range(5):
		if player["monster_zones"][i]:
			var card = CardDatabase.get(player["monster_zones"][i].card_id)
			print("  Monster zone %d: %s (%s, ATK=%d, DEF=%d)" % [i, card["name"], player["monster_zones"][i].position, card["atk"], card["def"]])
		if player["spell_trap_zones"][i]:
			var card = CardDatabase.get(player["spell_trap_zones"][i].card_id)
			print("  Spell/Trap zone %d: %s (%s)" % [i, card["name"], player["spell_trap_zones"][i].status])
	print("ƒê·ªëi th·ªß %s: LP=%d, Hand=%d, Deck=%d" % [opponent_id, opponent["life_points"], len(opponent["hand"]), len(opponent["deck"])])
	for i in range(5):
		if opponent["monster_zones"][i]:
			var card = CardDatabase.get(opponent["monster_zones"][i].card_id)
			print("  Opponent Monster zone %d: %s (%s, ATK=%d, DEF=%d)" % [i, card["name"], opponent["monster_zones"][i].position, card["atk"], card["def"]])
		if opponent["spell_trap_zones"][i]:
			var card = CardDatabase.get(opponent["spell_trap_zones"][i].card_id)
			print("  Opponent Spell/Trap zone %d: %s (%s)" % [i, card["name"], opponent["spell_trap_zones"][i].status])
	if not state["chain"].empty():
		print("Chain: %s" % state["chain"])
	if state["winner"]:
		print("Ng∆∞·ªùi th·∫Øng: %s | L√Ω do: %s" % [state["winner"], state["win_reason"]])
	print("==========================")


# ===========================================================================
# _get_opponent_id(state)
# L·∫•y ID c·ªßa ƒë·ªëi th·ªß
# ===========================================================================
func _get_opponent_id(state):
	for pid in state["players"]:
		if pid != state["turn"]:
			return pid
	return null




================================================================================

--- FILE: core\TrainBot.gd ---
# ===========================================================================
# train_agent.gd - Hu·∫•n luy·ªán Agent h·ªçc t·ª´ tr·∫≠n ƒë·∫•u Yu-Gi-Oh!
# D√πng Agent.gd (hybrid: Q-Learning + Rule-based response)
# ===========================================================================

extends Node

# S·ªë tr·∫≠n ƒë·ªÉ hu·∫•n luy·ªán
const TRAINING_GAMES = 100

# B·ªô b√†i m·∫´u
var deck = [
	"BLUE_EYES_WHITE_DRAGON",
	"DARK_MAGICIAN",
	"MIRROR_FORCE",
	"GYOUKI",
	"SACK",
	"EFFECT_VEILER",
	"BOOK_OF_MOON",
	"CARD_001",
	"CARD_002",
	"CARD_003"
]

# ===========================================================================
# _ready()
# B·∫Øt ƒë·∫ßu hu·∫•n luy·ªán
# ===========================================================================
func _ready():
	print("üöÄ B·∫Øt ƒë·∫ßu hu·∫•n luy·ªán Agent cho %d tr·∫≠n..." % TRAINING_GAMES)
	
	for i in range(TRAINING_GAMES):
		print("üéÆ Tr·∫≠n #%d" % (i + 1))
		_train_one_game(deck, deck)
	
	# L∆∞u model sau khi h·ªçc xong
	Agent.save_q_table()
	print("üéâ Ho√†n th√†nh hu·∫•n luy·ªán %d tr·∫≠n! Model ƒë√£ ƒë∆∞·ª£c l∆∞u." % TRAINING_GAMES)


# ===========================================================================
# _train_one_game(deck_a, deck_b)
# Ch·∫°y m·ªôt tr·∫≠n ƒë·∫•u gi·ªØa Agent v√† Bot (random)
# ===========================================================================
func _train_one_game(deck_a, deck_b):
	# Kh·ªüi t·∫°o tr·∫≠n ƒë·∫•u
	var room_id = BattleCore.start_duel("agent", "bot", deck_a, deck_b)
	if not room_id:
		print("‚ùå Kh√¥ng th·ªÉ kh·ªüi t·∫°o tr·∫≠n ƒë·∫•u")
		return
	
	var game_over = false
	var current_state = BattleCore.get_game_state(room_id, "agent")
	
	# V√≤ng l·∫∑p tr·∫≠n ƒë·∫•u
	while not game_over:
		var game_data = BattleCore.active_duels[room_id]
		if not game_data:
			break
		
		var current_player = game_data.turn
		
		if current_player == "agent":
			# L∆∞·ª£t c·ªßa Agent
			var available_actions = BattleCore.get_available_actions(room_id, "agent")
			if available_actions.empty():
				game_over = true
				continue
			
			# 1. Agent ch·ªçn h√†nh ƒë·ªông ch√≠nh
			var action_type = Agent.get_action(current_state, "agent", available_actions)
			var action = {
				"player_id": "agent",
				"type": action_type
			}
			
			# 2. ƒêi·ªÅn payload (c√≥ th·ªÉ m·ªü r·ªông sau)
			action.payload = _build_payload(action_type, current_state, "agent")
			
			# 3. G·ª≠i h√†nh ƒë·ªông
			var result = BattleCore.submit_action(room_id, action)
			
			# 4. H·ªçc t·ª´ k·∫øt qu·∫£
			Agent.learn_from_result(current_state, action, result)
			
			# 5. C·∫≠p nh·∫≠t tr·∫°ng th√°i
			var new_state = BattleCore.get_game_state(room_id, "agent")
			current_state = new_state
			
			# 6. X·ª≠ l√Ω s·ª± ki·ªán: c√≥ c·∫ßn ph·∫£n ·ª©ng kh√¥ng?
			var response = Agent.on_event(new_state, result.events, "agent")
			if response:
				var response_result = BattleCore.submit_action(room_id, response)
				# C√≥ th·ªÉ h·ªçc th√™m t·ª´ ph·∫£n ·ª©ng
				Agent.learn_from_result(new_state, response, response_result)
				current_state = BattleCore.get_game_state(room_id, "agent")
			
			# 7. Ki·ªÉm tra k·∫øt th√∫c
			if result.events.find({"type": "WIN"}) or new_state.status == "finished":
				game_over = true
				
		else:
			# L∆∞·ª£t c·ªßa bot ƒë·ªëi th·ªß (random)
			var available = BattleCore.get_available_actions(room_id, "bot")
			if available.empty():
				game_over = true
				continue
			
			var action_type = available[randi() % available.size()]
			var action = {
				"player_id": "bot",
				"type": action_type
			}
			
			# T·∫°o payload ƒë∆°n gi·∫£n
			action.payload = _build_payload(action_type, BattleCore.get_game_state(room_id, "bot"), "bot")
			
			BattleCore.submit_action(room_id, action)
		
		# Ki·ªÉm tra tr·∫°ng th√°i tr·∫≠n
		var duel = BattleCore.active_duels.get(room_id)
		if not duel or duel.status == "finished":
			game_over = true
	
	print("‚úÖ Tr·∫≠n ƒë·∫•u k·∫øt th√∫c.")


# ===========================================================================
# _build_payload(action_type, game_state, player_id)
# T·∫°o payload h·ª£p l·ªá cho h√†nh ƒë·ªông
# (C√≥ th·ªÉ m·ªü r·ªông th√†nh logic ch·ªçn b√†i th√¥ng minh)
# ===========================================================================
func _build_payload(action_type, game_state, player_id):
	var payload = {}
	var player = game_state.players[player_id]
	
	match action_type:
		"PLAY_MONSTER":
			# Ch·ªçn qu√°i ƒë·∫ßu ti√™n tr√™n tay
			for card_id in player.hand:
				if CardDatabase.exists(card_id):
					var card = CardDatabase.get(card_id)
					if card.type == "Monster":
						payload.card_id = card_id
						payload.from_zone = "hand"
						payload.to_zone = _find_empty_zone(player.monster_zones)
						payload.position = "face_up_attack"
						return payload
			return null  # Kh√¥ng c√≥ qu√°i
			
		"SET_MONSTER", "SET_SPELL", "SET_TRAP":
			payload.to_zone = _find_empty_zone(
				player.spell_trap_zones if "SPELL" in action_type or "TRAP" in action_type 
				else player.monster_zones
			)
			# T√¨m b√†i ph√π h·ª£p
			for card_id in player.hand:
				if CardDatabase.exists(card_id):
					var card = CardDatabase.get(card_id)
					if ("SPELL" in action_type and card.type == "Spell") or \
					   ("TRAP" in action_type and card.type == "Trap") or \
					   ("MONSTER" in action_type and card.type == "Monster"):
						payload.card_id = card_id
						return payload
			return null
			
		"PLAY_SPELL", "PLAY_TRAP":
			payload.to_zone = _find_empty_zone(player.spell_trap_zones)
			# T∆∞∆°ng t·ª± nh∆∞ tr√™n
			for card_id in player.hand:
				if CardDatabase.exists(card_id):
					var card = CardDatabase.get(card_id)
					if ("SPELL" in action_type and card.type == "Spell") or \
					   ("TRAP" in action_type and card.type == "Trap"):
						payload.card_id = card_id
						return payload
			return null
			
		"DECLARE_ATTACK":
			# T√¨m qu√°i t·∫•n c√¥ng
			for i in range(5):
				var card = player.monster_zones[i]
				if card and card.position == "face_up_attack" and not card.has("attacked_this_turn"):
					var opp = game_state.players[_get_opponent_id(game_state, player_id)]
					# T√¨m m·ª•c ti√™u
					for j in range(5):
						if opp.monster_zones[j]:
							payload.attacker = card.card_id
							payload.target = opp.monster_zones[j].card_id
							return payload
					# N·∫øu kh√¥ng c√≥ qu√°i ‚Üí t·∫•n c√¥ng tr·ª±c ti·∫øp
					payload.attacker = card.card_id
					payload.target = null
					return payload
			return null
			
		"CHANGE_POSITION":
			for i in range(5):
				var card = player.monster_zones[i]
				if card and card.position == "face_up_attack":
					payload.card_id = card.card_id
					payload.to_position = "defense"
					payload.face = "up"
					return payload
			return null
			
		"ACTIVATE_EFFECT":
			# T√¨m b√†i c√≥ th·ªÉ k√≠ch ho·∫°t
			for zone in player.monster_zones:
				if zone:
					payload.card_id = zone.card_id
					return payload
			for zone in player.spell_trap_zones:
				if zone and zone.status == "face_up":
					payload.card_id = zone.card_id
					return payload
			return null
			
		"END_TURN", "END_PHASE", "DRAW_CARD", "SURRENDER":
			# Kh√¥ng c·∫ßn payload
			pass
	
	return payload


# ===========================================================================
# H√†m h·ªó tr·ª£
# ===========================================================================
func _find_empty_zone(zones):
	for i in range(zones.size()):
		if zones[i] == null:
			return i
	return 0  # M·∫∑c ƒë·ªãnh

func _get_opponent_id(game_state, player_id):
	for pid in game_state.players.keys():
		if pid != player_id:
			return pid
	return null

================================================================================

--- FILE: core\types\GameState.gd ---
# res://types/GameState.gd
class_name GameState

var room_id: String
var turn: String
var phase: String  # "draw", "standby", "main1", "battle", "main2", "end"
var players: Dictionary  # player_id ‚Üí PlayerState
var chain: Array = []    # Danh s√°ch hi·ªáu ·ª©ng ƒëang x·ª≠ l√Ω
var status: String = "active"
================================================================================

--- FILE: core\types\PlayerState.gd ---
# res://types/PlayerState.gd
class_name PlayerState

var life_points: int = 8000
var deck: Array
var hand: Array
var graveyard: Array
var monster_zones: Array  # 5 √¥
var spell_trap_zones: Array  # 5 √¥
var extra_deck: Array
var field_zone  = null
================================================================================

--- FILE: data\cards.json ---
{
  "BLUE_EYES_WHITE_DRAGON": {
    "id": "BLUE_EYES_WHITE_DRAGON",
    "name": "Blue-Eyes White Dragon",
    "type": "monster",
    "atk": 3000,
    "def": 2500,
    "level": 8,
    "attribute": "light",
    "effect": ""
  },
  "DARK_MAGICIAN": {
    "id": "DARK_MAGICIAN",
    "name": "Dark Magician",
    "type": "monster",
    "atk": 2500,
    "def": 2100,
    "level": 7,
    "attribute": "dark",
    "effect": ""
  },
  "SUMMONED_SKULL": {
    "id": "SUMMONED_SKULL",
    "name": "Summoned Skull",
    "type": "monster",
    "atk": 2500,
    "def": 1200,
    "level": 6,
    "attribute": "dark",
    "effect": ""
  },
  "GYOUKI": {
    "id": "GYOUKI",
    "name": "Gyouki",
    "type": "monster",
    "atk": 1500,
    "def": 1000,
    "level": 4,
    "attribute": "dark",
    "effect": ""
  },
  "POT_OF_GREED": {
    "id": "POT_OF_GREED",
    "name": "Pot of Greed",
    "type": "spell",
    "effect": "draw_2"
  },
  "MONSTER_REBORN": {
    "id": "MONSTER_REBORN",
    "name": "Monster Reborn",
    "type": "spell",
    "effect": "special_summon_graveyard"
  },
  "DARK_HOLE": {
    "id": "DARK_HOLE",
    "name": "Dark Hole",
    "type": "spell",
    "effect": "destroy_all_monsters"
  },
  "MIRROR_FORCE": {
    "id": "MIRROR_FORCE",
    "name": "Mirror Force",
    "type": "trap",
    "effect": "destroy_all_attackers"
  },
  "TRAP_HOLE": {
    "id": "TRAP_HOLE",
    "name": "Trap Hole",
    "type": "trap",
    "effect": "destroy_summoned_monster"
  },
  "SUIJIN": {
    "id": "SUIJIN",
    "name": "Suijin",
    "type": "monster",
    "atk": 2500,
    "def": 2400,
    "level": 7,
    "attribute": "water",
    "effect": "reduce_atk_0"
  }
}



================================================================================

