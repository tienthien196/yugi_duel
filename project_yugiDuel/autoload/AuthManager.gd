# ===========================================================================
# AuthManager.gd - Qu·∫£n l√Ω x√°c th·ª±c & b·∫£o m·∫≠t ng∆∞·ªùi ch∆°i (Godot 3.6)
# Autoload Singleton
# Ch·ª©c nƒÉng:
#   - ƒêƒÉng nh·∫≠p / t·∫°o session
#   - T·∫°o v√† ki·ªÉm tra token
#   - Li√™n k·∫øt player_id v·ªõi peer_id
#   - G·ª≠i t√≠n hi·ªáu khi x√°c th·ª±c th√†nh c√¥ng
# ===========================================================================
extends Node

# Th·ªùi h·∫°n token (gi√¢y) - 1 gi·ªù
const TOKEN_EXPIRE_TIME = 3600

# C·∫•u tr√∫c session: token ‚Üí { player_id, peer_id, created_time }
var sessions = {}

# Signal
signal player_authenticated(player_id, session_token, peer_id)
signal player_logged_out(player_id)
signal auth_failed(peer_id, error_code)

# Tham chi·∫øu ƒë·∫øn NetworkManager
onready var network_manager = NetworkManager

# ===========================================================================
# _ready()
# K·∫øt n·ªëi v·ªõi NetworkManager ƒë·ªÉ l·∫Øng nghe k·∫øt n·ªëi
# ===========================================================================
func _ready():
	# yield(get_tree().create_timer(1), "timeout")
	#if not Engine.has_singleton("NetworkManager"):
	if not network_manager:
		push_error("‚ùå AuthManager: NetworkManager kh√¥ng t·ªìn t·∫°i trong Autoload!")
		return
	# L·∫Øng nghe khi client k·∫øt n·ªëi
	network_manager.connect("client_connected", self, "_on_client_connected")
	network_manager.connect("message_received", self, "_on_message_received")

# ===========================================================================
# _on_client_connected(player_id, peer_id)
# Khi client k·∫øt n·ªëi ‚Üí y√™u c·∫ßu ƒëƒÉng nh·∫≠p
# player_id ·ªü ƒë√¢y ch·ªâ l√† t·∫°m "player_X"
# ===========================================================================
func _on_client_connected(player_id, peer_id):
	print("üîê AuthManager: Client peer=%d c·∫ßn x√°c th·ª±c." % peer_id)
	# G·ª≠i y√™u c·∫ßu ƒëƒÉng nh·∫≠p
	var msg = {
		"type": "AUTH_REQUEST",
		"message": "Vui l√≤ng g·ª≠i AUTH_LOGIN ƒë·ªÉ x√°c th·ª±c."
	}
	network_manager.send_message_to_player(player_id, msg)

# ===========================================================================
# _on_message_received(player_id, message)
# X·ª≠ l√Ω tin nh·∫Øn, ƒë·∫∑c bi·ªát l√† AUTH_LOGIN
# ===========================================================================
func _on_message_received(player_id, message):
	if message.type == "AUTH_LOGIN":
		_handle_auth_login(message, player_id)
	elif message.type == "AUTH_VERIFY":
		_handle_auth_verify(message, player_id)
	elif message.type == "LOGOUT":
		_handle_logout(message, player_id)
	else:
		# N·∫øu ch∆∞a x√°c th·ª±c, ch·∫∑n m·ªçi tin nh·∫Øn kh√¥ng ph·∫£i AUTH
		if not _is_player_authenticated(player_id):
			_send_error(player_id, "AUTH_REQUIRED")
			return

# ===========================================================================
# _handle_auth_login(message, temp_player_id)
# X·ª≠ l√Ω ƒëƒÉng nh·∫≠p: client g·ª≠i username, c√≥ th·ªÉ k√®m guest/token
# ===========================================================================
func _handle_auth_login(message, temp_player_id):
	var username = message.get("username", "").strip_edges()
	var token = message.get("token", "")  # N·∫øu d√πng token tr∆∞·ªõc ƒë√≥
	var peer_id = _get_peer_from_player(temp_player_id)
	if peer_id == 0:
		_send_error(temp_player_id, "INVALID_PEER")
		return
	# Ki·ªÉm tra username
	if username == "":
		# T·∫°o username t·∫°m (guest)
		username = "guest_%d" % OS.get_unix_time() % 10000
		print("üéÆ T·∫°o guest user: %s" % username)
	# N·∫øu c√≥ token ‚Üí ki·ªÉm tra l·∫°i
	if token != "" and _is_valid_token(token):
		var existing = sessions[token]
		if existing.player_id == username:
			# D√πng l·∫°i session
			_renew_session(token)
			_complete_auth(username, token, peer_id)
			return
	# T·∫°o session m·ªõi
	var new_token = _generate_token()
	sessions[new_token] = {
		"player_id": username,
		"peer_id": peer_id,
		"created_time": OS.get_unix_time(),
		"last_active": OS.get_unix_time()
	}
	print("‚úÖ AuthManager: '%s' ƒë√£ ƒëƒÉng nh·∫≠p v·ªõi token: %s" % [username, new_token])
	_complete_auth(username, new_token, peer_id)

# ===========================================================================
# _handle_auth_verify(message, temp_player_id)
# Client g·ª≠i token ƒë·ªÉ x√°c minh
# ===========================================================================
func _handle_auth_verify(message, temp_player_id):
	var token = message.get("token", "")
	var peer_id = _get_peer_from_player(temp_player_id)
	if not _is_valid_token(token):
		_send_error(temp_player_id, "INVALID_TOKEN")
		return
	var session = sessions[token]
	if session.peer_id != peer_id:
		_send_error(temp_player_id, "TOKEN_MISMATCH")
		return
	_complete_auth(session.player_id, token, peer_id)

# ===========================================================================
# _handle_logout(message, temp_player_id)
# Ng∆∞·ªùi ch∆°i ƒëƒÉng xu·∫•t
# ===========================================================================
func _handle_logout(message, temp_player_id):
	var token = message.get("token", "")
	if token in sessions:
		var player_id = sessions[token].player_id
		sessions.erase(token)
		emit_signal("player_logged_out", player_id)
		print("üîê AuthManager: '%s' ƒë√£ ƒëƒÉng xu·∫•t." % player_id)
	# G·ª≠i ph·∫£n h·ªìi
	network_manager.send_message_to_player(temp_player_id, {
		"type": "LOGOUT_SUCCESS"
	})

# ===========================================================================
# _complete_auth(player_id, token, peer_id)
# Ho√†n t·∫•t x√°c th·ª±c ‚Üí c·∫≠p nh·∫≠t player_id th·∫≠t, ph√°t t√≠n hi·ªáu
# ===========================================================================
func _complete_auth(player_id, token, peer_id):
	# C·∫≠p nh·∫≠t l·∫°i √°nh x·∫° trong NetworkManager
	network_manager.peer_to_player[peer_id] = player_id
	# Ph√°t t√≠n hi·ªáu cho ServerManager
	emit_signal("player_authenticated", player_id, token, peer_id)
	# G·ª≠i ph·∫£n h·ªìi th√†nh c√¥ng
	var response = {
		"type": "AUTH_SUCCESS",
		"player_id": player_id,
		"token": token,
		"server_time": OS.get_unix_time()
	}
	network_manager.send_message_to_player(player_id, response)
	print("üü¢ AuthManager: '%s' ƒë√£ x√°c th·ª±c th√†nh c√¥ng (peer=%d)" % [player_id, peer_id])

# ===========================================================================
# _is_player_authenticated(player_id) ‚Üí bool
# Ki·ªÉm tra player_id ƒë√£ x√°c th·ª±c ch∆∞a
# ===========================================================================
func _is_player_authenticated(player_id):
	for token in sessions:
		if sessions[token].player_id == player_id:
			return true
	return false

# ===========================================================================
# is_token_valid(token) ‚Üí bool
# D√πng b√™n ngo√†i ƒë·ªÉ ki·ªÉm tra token (vd: trong ServerManager)
# ===========================================================================
func is_token_valid(token):
	return _is_valid_token(token)

# ===========================================================================
# get_player_id_by_token(token) ‚Üí String
# Tr·∫£ v·ªÅ player_id n·∫øu token h·ª£p l·ªá
# ===========================================================================
func get_player_id_by_token(token):
	if _is_valid_token(token):
		return sessions[token].player_id
	return ""

# ===========================================================================
# get_peer_id_by_player(player_id) ‚Üí int
# Tr·∫£ v·ªÅ peer_id
# ===========================================================================
func get_peer_id_by_player(player_id):
	for token in sessions:
		if sessions[token].player_id == player_id:
			return sessions[token].peer_id
	return 0

# ===========================================================================
# _is_valid_token(token) ‚Üí bool
# Ki·ªÉm tra token t·ªìn t·∫°i v√† ch∆∞a h·∫øt h·∫°n
# ===========================================================================
func _is_valid_token(token):
	if not sessions.has(token):
		return false
	var session = sessions[token]
	var now = OS.get_unix_time()
	if now - session.created_time > TOKEN_EXPIRE_TIME:
		sessions.erase(token)
		return false
	# C·∫≠p nh·∫≠t last_active
	session.last_active = now
	return true

# ===========================================================================
# _renew_session(token)
# L√†m m·ªõi th·ªùi gian session
# ===========================================================================
func _renew_session(token):
	if sessions.has(token):
		sessions[token].created_time = OS.get_unix_time()


# ===========================================================================
# _generate_token() ‚Üí String
# T·∫°o token ng·∫´u nhi√™n 32 k√Ω t·ª± (ch·ªâ d√πng t√≠nh nƒÉng Godot 3.6)
# ===========================================================================
func _generate_token():
	var chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	var len_ = chars.length()
	var rand_str = ""
	for i in range(32):
		var c = chars[randi() % len_]
		rand_str += c
	return rand_str

# ===========================================================================
# _get_peer_from_player(temp_player_id) ‚Üí int
# L·∫•y peer_id t·ª´ NetworkManager
# ===========================================================================
func _get_peer_from_player(player_id):
	return network_manager._get_peer_from_player(player_id)

# ===========================================================================
# _send_error(player_id, error_code)
# G·ª≠i l·ªói x√°c th·ª±c
# ===========================================================================
func _send_error(player_id, error_code):
	var msg = {
		"type": "AUTH_ERROR",
		"code": error_code,
		"message": _get_error_message(error_code)
	}
	network_manager.send_message_to_player(player_id, msg)

# ===========================================================================
# _get_error_message(code) ‚Üí String
# B·∫£n m√¥ t·∫£ l·ªói
# ===========================================================================
func _get_error_message(code):
	match code:
		"AUTH_REQUIRED": return "C·∫ßn ƒëƒÉng nh·∫≠p tr∆∞·ªõc khi th·ª±c hi·ªán h√†nh ƒë·ªông."
		"INVALID_TOKEN": return "Token kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ h·∫øt h·∫°n."
		"TOKEN_MISMATCH": return "Token kh√¥ng kh·ªõp v·ªõi k·∫øt n·ªëi hi·ªán t·∫°i."
		"INVALID_PEER": return "Kh√¥ng t√¨m th·∫•y peer."
		"INVALID_CREDENTIALS": return "T√™n ƒëƒÉng nh·∫≠p ho·∫∑c m·∫≠t kh·∫©u sai."
		_:
			return "L·ªói x√°c th·ª±c kh√¥ng x√°c ƒë·ªãnh."

# ===========================================================================
# cleanup_expired_sessions()
# D·ªçn d·∫πp session h·∫øt h·∫°n (g·ªçi t·ª´ ServerManager._process)
# ===========================================================================
func cleanup_expired_sessions():
	var now = OS.get_unix_time()
	var expired = []
	for token in sessions:
		if now - sessions[token].created_time > TOKEN_EXPIRE_TIME:
			expired.append(token)
	for token in expired:
		var player_id = sessions[token].player_id
		sessions.erase(token)
		print("üßπ AuthManager: Session h·∫øt h·∫°n ƒë√£ x√≥a: %s" % player_id)
